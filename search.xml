<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Costa项目：经验总结</title>
    <url>/2019/02/15/cs-business/Costa%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>Costa项目从18年7月份入职开始做，一直到19年1月份，为期7个月。</p>
<p>这期间我主要负责的工作为：<strong>外送管理、分类管理、促销管理、券管理、券包管理、数据报表。</strong></p>
<p><strong>最大的心得体会是：“写代码不难，难的是如何把代码写好了。”</strong></p>
<p>遇到的最大的难点是数据报表相关的工作，数据报表最重要一点是<strong>“准确”</strong>，可是因为系统还在不断的迭代以及修复bug，在这个过程<strong>各个表的数据难免会受影响</strong>，最终所有小的影响汇聚在报表上，表现出来的就是很大的问题（因为数据对不上）。</p>
<p><strong>总的来说，这半年工作给我的感触就是，公司里面流程更规范。对代码质量要求更高。所以接下来，我会先刷一遍算法题，再着重学习，总结一下代码模式相关内容，最后加深一下数据库、redis、mq、框架等内容的理解。这就是我19年的技能方面的学习计划了。</strong></p>
]]></content>
      <categories>
        <category>业务思考</category>
      </categories>
      <tags>
        <tag>业务思考</tag>
      </tags>
  </entry>
  <entry>
    <title>Dcoker 学习资料</title>
    <url>/2019/04/17/cs-development/Dcoker-%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<p><strong>Docker 入门实例</strong></p>
<ul>
<li><a href="https://juejin.im/post/5cacbfd7e51d456e8833390c?utm_source=gold_browser_extension">30 分钟快速入门 Docker 教程</a></li>
<li><a href="https://www.fengbohello.top/archives/go-env-docker">使用 Docker 镜像构建 GO 语言环境</a></li>
</ul>
<p><strong>Docker 文档</strong></p>
<ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/tag/">官方文档</a></li>
</ul>
<p><strong>Docker 电子书</strong></p>
<ul>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/">Docker — 从入门到实践</a></li>
</ul>
]]></content>
      <categories>
        <category>发展规划</category>
      </categories>
      <tags>
        <tag>发展规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 学习资料</title>
    <url>/2019/02/21/cs-development/Go-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E8%B5%84%E6%96%99%EF%BC%89/</url>
    <content><![CDATA[<p>本人最近刚刚经历了痛苦的入门过程，现想将自己的学习过程&amp;学习资料整理、分享给有需要的人。</p>
<p><strong>最后更新时间：2019年8月14日</strong></p>
<h1 id="Go-学习路径"><a href="#Go-学习路径" class="headerlink" title="Go 学习路径"></a>Go 学习路径</h1><p><strong>基础知识</strong></p>
<ul>
<li><a href="https://tour.golang.org/">官方教程</a></li>
<li><a href="https://gobyexample.com/">Go By Example</a></li>
<li><a href="https://geektutu.com/post/quick-golang.html">Go 语言简明教程</a></li>
</ul>
<p><strong>入门项目</strong></p>
<ul>
<li><a href="https://github.com/hoisie/web">实现路由</a></li>
<li><a href="https://github.com/icub3d/home/">实现 API</a></li>
</ul>
<p><strong>进阶项目</strong></p>
<ul>
<li><a href="https://github.com/astaxie/beego">beego框架</a></li>
<li><a href="https://www.docker.com/">docker</a></li>
<li><a href="https://github.com/skynetservices/skynet-archive">分布式</a></li>
<li><a href="https://github.com/etcd-io/etcd">分布式应用</a></li>
</ul>
<h1 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h1><ul>
<li><a href="https://github.com/astaxie/build-web-application-with-golang">《Go Web 编程》开源项目</a></li>
<li><a href="https://astaxie.gitbooks.io/build-web-application-with-golang/zh/">《Go Web 编程》在线阅读</a></li>
</ul>
<h1 id="交流社区"><a href="#交流社区" class="headerlink" title="交流社区"></a>交流社区</h1><ul>
<li><a href="https://studygolang.com/">Go 语言中文网</a></li>
<li><a href="https://www.golangtc.com/">Golang 中国</a></li>
<li><a href="https://gocn.vip/">Go 中国技术社区</a></li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.zhihu.com/question/23486344/answer/24770195">怎么学习 Golang</a></li>
<li><a href="https://github.com/Unknwon/go-study-index">go-study-index</a></li>
<li><a href="https://www.processon.com/view/link/5a9ba4c8e4b0a9d22eb3bdf0#map">知识图谱</a></li>
</ul>
<hr>
<p><a href="https://github.com/haxianhe/go-resource">本项目Github地址</a></p>
<p>欢迎大家和我一起学习👍</p>
<hr>
]]></content>
      <categories>
        <category>发展规划</category>
      </categories>
      <tags>
        <tag>发展规划</tag>
      </tags>
  </entry>
  <entry>
    <title>从小厂逆袭快手，我是如何从PHP转Java的</title>
    <url>/2021/04/21/cs-interview/%E4%BB%8E%E5%B0%8F%E5%8E%82%E9%80%86%E8%A2%AD%E5%BF%AB%E6%89%8B%EF%BC%8C%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E4%BB%8EPHP%E8%BD%ACJava%E7%9A%84/</url>
    <content><![CDATA[<p>我将我本次面试遇到的面试题整理成了一份面经，大家可以<strong>关注我的公众号【haxianhe】，回复 “面经” 领取</strong>。</p>
<hr>
<p>这篇文章拖了好久了，这篇文章是面试三部曲的最后一篇。</p>
<p>本篇文章将从如下三个角度讲述：</p>
<ol>
<li>我为什么要转语言</li>
<li>面试对要转语言的要求是什么</li>
<li>如何转语言</li>
</ol>
<h2 id="我为什么要转语言"><a href="#我为什么要转语言" class="headerlink" title="我为什么要转语言"></a>我为什么要转语言</h2><p>其实我刚上大学的时候学的是C++，后面大一下学期进入实验室学的C#（大学期间的项目也以C#为主），大二开始跟着课程学Java。</p>
<p>所以，在校期间我接触过C++，C#，Java，其中有C#的项目经验。</p>
<p>但是，毕业之后我却开始做了 PHP（不得不说人生无常），也是我的第一门脚本语言。</p>
<p>其实接触了这么多编程语言之后，也认可很多人常说的这句 <strong>“语言只是个工具，做什么语言不重要”</strong> 这句话，但是这句话没有提到的是，<strong>不同语言背后的生态圈中新人的概念理解成本、学习成本却截然不同</strong>。</p>
<p>简单来说就是：<strong>用什么语言对工作很多年的人来说没什么区别，但是对新手的成长有区别（大佬随意…）。</strong></p>
<h2 id="面试对要转语言的要求有多高"><a href="#面试对要转语言的要求有多高" class="headerlink" title="面试对要转语言的要求有多高"></a>面试对要转语言的要求有多高</h2><p>这里我仅以 PHP 转 Java 为例，面试过程中对Java的要求如下：</p>
<ul>
<li>会 Java 的基本语法（可以用 Java 写算法题）</li>
<li>会一些 Java 常见的面试题（基础、容器、并发、JVM 等）</li>
</ul>
<h2 id="如何转语言"><a href="#如何转语言" class="headerlink" title="如何转语言"></a>如何转语言</h2><p>可以看到其实没有我们想象的那么高，因为面试官也知道他是在面你一门不平事不用的语言，所以他的心里期待没有那么高。</p>
<p><strong>会 Java 的基本语法</strong></p>
<p>关于这一点其实很简单，反正面试前也要刷题，那直接以你要转的语言去刷题就好了。</p>
<p><strong>会一些 Java 常见的面试题</strong></p>
<p>都是一些老生常谈的问题，面试前复习复习就行，这里分享给大家一个 Github 开源项目：<a href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide</a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总的说来，转语言没有那么难，平时用要转语言去刷刷题，面试前看看要转语言的常见面试题，基本语言这块就没有太大问题，至于其他的中间件，技术方案，项目等等则和转不转语言没关系了。</p>
<p>面试三部曲</p>
<ul>
<li><a href="https://haxianhe.com/2021/02/27/CS-Interview/social-interview/">涨薪50%，从小厂逆袭快手 - 附面经</a></li>
<li><a href="https://haxianhe.com/2021/03/04/CS-Interview/how-to-ready-interview/">从小厂逆袭快手，我是如何准备面试的</a></li>
<li><a href="https://haxianhe.com/2021/04/21/CS-Interview/from_php2java/">从小厂逆袭快手，我是如何从PHP转Java的</a></li>
</ul>
<hr>
<p>此外，我还将我本次面试遇到的面试题整理成了一份面经，大家可以<strong>关注我的公众号【haxianhe】，回复 “面经” 领取</strong>。</p>
]]></content>
      <categories>
        <category>面试晋升</category>
      </categories>
      <tags>
        <tag>面试晋升</tag>
      </tags>
  </entry>
  <entry>
    <title>从小厂逆袭快手，我是如何准备面试的</title>
    <url>/2021/03/04/cs-interview/%E4%BB%8E%E5%B0%8F%E5%8E%82%E9%80%86%E8%A2%AD%E5%BF%AB%E6%89%8B%EF%BC%8C%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E9%9D%A2%E8%AF%95%E7%9A%84/</url>
    <content><![CDATA[<p>我将文中提到的的 MySQL、Redis、Kafka 思维导图放到了我的公众号中，大家可以<strong>关注我的公众号【haxianhe】，回复 “思维导图” 领取高清pdf版思维导图</strong>。</p>
<hr>
<p>在上一篇文章 <a href="https://haxianhe.com/2021/02/27/CS-Interview/social-interview/">涨薪50%，从小厂逆袭快手 - 附面经</a> 中，我概述性的给出了社招跳槽有哪些环节要去准备，那么今天我会给出面试复习比较推荐的复习资料、如何复习以及有哪些常见的注意事项。</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/20210304111340.png"></p>
<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>自我介绍是面试的一场面试第一个环节，而一个好的自我介绍是可以引导整场面试的节奏的，下面就简单介绍一下如何准备一份“合适”的自我介绍。</p>
<p>首先，我们要知道面试官想通过自我介绍了解什么信息。</p>
<p>在技术面试中，面试官除了想在你自我介绍的时间看应聘者的简历之外，一般会想了解以下几点信息：年龄，毕业院校，工作年限，工作经历，行业背景，项目经验，技术面等这些基础信息，然后根据自我介绍和简历信息就可以深入的聊一下具体的项目经验，技术问题等。</p>
<p>一般在进行自我介绍的时候概述性的介绍一下自己的学历背景、工作经历、项目经验，以及自己擅长的技术面即可。如果面试官对你介绍的哪部分内容感兴趣，他会具体问你的。</p>
<h2 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h2><p>这部分是社招面试的重头戏，总的原则是 <strong>以“项目经验”容纳“线上问题”，支撑“技术亮点”。</strong></p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/20210303181238.png"></p>
<p>面试提到的技术亮点是需要项目经验来支撑的。</p>
<p>大多数人在日常的工作中，用到的技术是非常有限的，可能就是 CRUD 外带一些调优，这也是普遍现象。反之，如果一个初级开发，在面试中说，之前开发的模块既有jvm调优、又有分布式组件，再外带数据库性能优化，似乎可信度也不高。</p>
<p>对此，你需要用“解决过的线上问题”去支撑想要展开的技术亮点，需要你平时工作中积极主动的去参与线上问题的解决，比如有 oom 问题、redis缓存被击穿，或者其他分布式组件的case，你参与排查并解决，那么将来面试的时候，你自然可以以此为基础去展开你事先准备好的技术亮点。</p>
<p>这样的话，就像上面的那张图一样，你就有足够的支撑物去支撑你的分布式组件以及其他值钱的技能了。</p>
<p>总之，<strong>技术本身不值钱，面试官只关心你如何使用技术去解决线上问题的。</strong></p>
<h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><p>在面试时，经过寒暄后，一般面试官会让介绍项目经验，常见的问法是：“说下你最近的（或最拿得出手的）一个项目”。</p>
<p><strong>在面试前准备项目描述，别害怕，因为面试官什么都不知道</strong></p>
<p>面试官是人，不是神，拿到你的简历的时候，是没法核实你的项目细节的（一般公司会到录用后，用背景调查的方式来核实）。</p>
<p>更何况，你做的项目是以月为单位算的，而面试官最多用3分钟来从你的简历上了解你的项目经验，所以你对项目的熟悉程度要远远超过面试官，所以你一点也不用紧张。</p>
<p>如果你的工作经验比面试官还丰富的话，甚至还可以控制整个面试流程。</p>
<p>下面给出了你和面试官的情况对比：</p>
<table>
<thead>
<tr>
<th></th>
<th>你</th>
<th>面试官</th>
</tr>
</thead>
<tbody><tr>
<td>对你以前的项目和技能</td>
<td>很了解</td>
<td>只能听你说，只能根据你说的内容做出判断</td>
</tr>
<tr>
<td>在面试过程中的职责</td>
<td>在很短的时间内防守成功即可</td>
<td>如果找不出漏洞，就只能算你以前做过</td>
</tr>
<tr>
<td>准备时间</td>
<td>面试前你有充足的时间准备</td>
<td>一般在面试前用3分钟阅读你的简历</td>
</tr>
<tr>
<td>沟通过程</td>
<td>你可以出错，但别出关键性的错误</td>
<td>不会太为难你，除非你太差</td>
</tr>
<tr>
<td>技巧</td>
<td>你有足够的技巧，也可以从网上找到足够多的面试题</td>
<td>其实就问些通用的有规律的问题</td>
</tr>
</tbody></table>
<p> 既然面试官无法了解你的底细，那么他们怎么来验证你的项目经验和技术？</p>
<p> 下面总结了一些常用的提问方式：</p>
<table>
<thead>
<tr>
<th>提问方式</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td>让你描述工作经验和项目（极有可能是最近的），看看你说的是否和简历上一致</td>
<td>看你是否真的做过这些项目</td>
</tr>
<tr>
<td>看你简历上项目里用到的技术，比如框架、数据库，然后针对这些技术提些基本问题</td>
<td>还是验证你是否做过项目，同时看你是否了解这些技术，为进一步提问做准备</td>
</tr>
<tr>
<td>针对某个项目，不断深入地问一些技术上的问题，或者从不同侧面问一些技术实现，看你前后回答里面是否有矛盾</td>
<td>深入核实你的项目细节</td>
</tr>
<tr>
<td>针对某技术，问些项目里一定会遇到的问题，比如候选人说做过数据库，那么就会问索引方面的问题</td>
<td>通过这类问题，核实候选人是否真的有过项目经验（或者还仅仅是学习经验）</td>
</tr>
</tbody></table>
<p><strong>准备项目的各种细节，一旦被问倒了，就说明你没做过</strong></p>
<p> 一般来说，在面试前，大家应当准备项目描述的说辞，自信些，因为这部分你说了算，流利些，因为你经过充分准备后，可以知道你要说些什么。</p>
<p> 而且这些是你实际的项目经验（不是学习经验，也不是培训经验），那么一旦让面试官感觉你都说不上来，那么可信度就很低了。</p>
<p>不少人是拘泥于“项目里做了什么业务，以及代码实现的细节”，这就相当于把后继提问权直接交给面试官。</p>
<p>下表列出了一些不好的回答方式：</p>
<table>
<thead>
<tr>
<th>回答方式</th>
<th>后果</th>
</tr>
</thead>
<tbody><tr>
<td>我在XX软件公司做了XX门户网站项目，这个项目做到了XX功能，具体是XX和XX模块，各模块做了XX功能，客户是XX，最后这个项目挣了XX钱</td>
<td>直接打断，因为业务需求我不需要了解，我会直接问他项目里的技术</td>
</tr>
<tr>
<td>（需要招聘一个Java后端开发，会Spring MVC）最近一个项目我是用C#（或其他非Java技术）实现的，实现了……或者我最近做的不是开发，而是测试……或者我最近的项目没有用到Spring MVC</td>
<td>提问，你最近用到SSH技术的项目是什么时候，然后在评语上写：最近XX时间没接触过SSH</td>
</tr>
<tr>
<td>在毕业设计的时候（或者在读书的时候，在学习的时候，在XX培训学校，在XX实训课程中），……</td>
<td>直接打断，提问你这个是否是商业项目，如果不是，你有没有其他的商业经验。如果没商业项目经验，除非是校招，否则就直接结束面试</td>
</tr>
<tr>
<td>描述项目时，一些关键要素（比如公司、时间、所用技术等）和简历上的不匹配</td>
<td>我们会深究这个不一致的情况，如果是简历造假，那么可能直接中断面试，如果真的是笔误，那么就需要提供合理的解释</td>
</tr>
</tbody></table>
<p>在避免上述不好的回答的同时，大家可以按下表所给出的要素准备项目介绍。</p>
<table>
<thead>
<tr>
<th>要素</th>
<th>样式</th>
</tr>
</thead>
<tbody><tr>
<td>控制在1分钟里面，讲出项目基本情况，比如项目名称，背景，给哪个客户做，完成了基本的事情，做了多久，项目规模多大，用到哪些技术，数据库用什么，然后酌情简单说一下模块。重点突出背景，技术，数据库和其他和技术有关的信息。</td>
<td>我在XX公司做了XX外汇保证金交易平台，客户是XX银行，主要完成了挂盘，实盘成交，保证金杠杆成交等功能，数据库是Oracle，前台用到JS等技术，后台用到Java的SSH，几个人做了X个月。不需要详细描述各功能模块，不需要说太多和业务有关但和技术无关的。如果面试官感兴趣，等他问。</td>
</tr>
<tr>
<td>要主动说出你做了哪些事情，这部分的描述一定需要和你的技术背景一致。</td>
<td>我做了外汇实盘交易系统，挂单成交系统，XXX模块，做了X个月</td>
</tr>
<tr>
<td>描述你在项目里的角色</td>
<td>我主要是做了开发，但在开发前，我在项目经理的带领下参与了业务调研，数据库设计等工作，后期我参与了测试和部署工作。</td>
</tr>
<tr>
<td>可以描述用到的技术细节，特别是你用到的技术细节，这部分尤其要注意，你说出口的，一定要知道，因为面试官后面就根据这个问的。你如果做了5个模块，宁可只说你能熟练说上口的2个。</td>
<td>用到了Java里面的集合，JDBC，…等技术，用到了Spring MVC等框架，用技术连接数据库。</td>
</tr>
<tr>
<td>这部分你风险自己承担，如果可以，不露声色说出一些热门的要素，比如Linux，大数据，大访问压力等。但一旦你说了，面试官就会直接问细节。</td>
<td>这个系统里，部署在Linux上，每天要处理的数据量是XX，要求是在4小时，1G内存是的情况下处理完5千万条数据。平均访客是每分钟XXX。</td>
</tr>
</tbody></table>
<h3 id="线上问题"><a href="#线上问题" class="headerlink" title="线上问题"></a>线上问题</h3><p>大家平时工作中一定要 <strong>把握住出现“线上问题”的机会。</strong> </p>
<p>因为，功能做了只是具备了项目经验，但是面试的时候真正“值钱”的其实是技术的难点与解决方案，而一般技术难点普遍伴随着“线上问题”。所以，平时工作中积极主动点，出现了线上问题不管是不是自己的都去查、去解决，事后围绕着“问题现象、问题分析、问题影响、解决方案、问题扩展”等去总结、记录到自己的笔记总，后续都是自己最宝贵的财富。</p>
<h3 id="技术亮点"><a href="#技术亮点" class="headerlink" title="技术亮点"></a>技术亮点</h3><p>结合自己遇到过的线上问题，优先准备分布式组件方面的技术亮点，常用的分布式组件主要有 MySQL、Redis、Kafka等。</p>
<p>这部分内容可以参考JD上对技术要求，有针对性的去准备，也可以参考我下面介绍的关于中间件部分的内容。</p>
<h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><p>关于这部分内容，转语言的同学可能更需要关注一下。</p>
<p>首先，需要明确的是你想转到什么语言，那你就需要事先准备好那个语言面试可能要问的内容，因为企业招你进去是干活的而不是再像校招那样，先把你招进去再去培养你。投简历前你是能看到JD的，JD上一般都有关于需要掌握的技术的明确的要求。</p>
<p>关于Java的复习材料，推荐开源项目 </p>
<ul>
<li><a href="https://github.com/Snailclimb/JavaGuide">JavaGuide</a></li>
</ul>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>常见的中间件主要有：MySQL、Redis、Kafka，接下来我简单介绍一下我的复习经验。</p>
<h3 id="复习材料"><a href="#复习材料" class="headerlink" title="复习材料"></a>复习材料</h3><p>关于中间件的复习材料，推荐开源项目 </p>
<ul>
<li><a href="https://github.com/doocs/advanced-java">advanced-java</a></li>
</ul>
<p>MySQL复习的话，还有两本书给大家推荐一下：</p>
<ul>
<li>《MySQL 技术内幕：InnoDB 存储引擎》</li>
<li>《高性能 MySQL》</li>
</ul>
<p>Redis 复习的话，也给大家推荐一本书：</p>
<ul>
<li>《Redis 设计与实现》</li>
</ul>
<h3 id="复习方法"><a href="#复习方法" class="headerlink" title="复习方法"></a>复习方法</h3><p>一般我会结合上面推荐的书和开源项目去整理一份自己的思维导图（思维导图我在下面放了截图）和笔记。</p>
<p><strong>MySQL</strong></p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/20210303221921.png"><br><img src="https://gitee.com/haxianhe/image/raw/master/image/20210303222907.png"></p>
<p><strong>Redis</strong></p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/20210303222024.png"><br><img src="https://gitee.com/haxianhe/image/raw/master/image/20210303223004.png"></p>
<p><strong>Kafka</strong></p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/20210303223409.png"><br><img src="https://gitee.com/haxianhe/image/raw/master/image/20210303223156.png"></p>
<p>完整的思维导图太长了不好截图，有需要的同学可以 <strong>关注我的公众号【haxianhe】，回复 “思维导图” 领取高清pdf版思维导图</strong>。</p>
<h2 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h2><p>推荐一个秒杀的开源学习项目</p>
<ul>
<li><a href="https://github.com/qiurunze123/miaosha">miaosha</a></li>
</ul>
<p>一篇比较好的关于秒杀的场景设计的文章</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/z2S1EjWQDwKm5Ud36IenNw">秒杀系统设计</a></li>
</ul>
<h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><p>算法的话推荐大家最起码刷一下牛客网上的 <a href="https://www.nowcoder.com/ta/coding-interviews">《剑指offer》67题</a></p>
<p>答案的话大家可以在网上搜一下“牛客网《剑指Offer》66题题解”，我本人参考的leetcode上的《画解剑指 Offer》不过这个要开会员，大家可以根据自己的需求进行选择。</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/20210303235814.png"></p>
<p>之后要是还有时间和精力的话推荐大家再刷一下 <a href="https://www.nowcoder.com/ta/job-code-high-rd">牛客霸题</a>，上面可以筛选企业和考察次数等</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/20210303235643.png"></p>
<h2 id="提问环节"><a href="#提问环节" class="headerlink" title="提问环节"></a>提问环节</h2><p>最后，就是提问环节了，这个环节和第一个环节一样是唯二应聘者可以掌握主动权的环节，一般透过这个环节你可以表现自己的面试团队的兴趣，也可以表现出自己的虚心好学都可以。</p>
<p>下面我给出我给自己准备的几个经典问题，给大家用作参考：</p>
<p>1.能和我介绍一下你们的业务嘛？<br>2.能和我介绍一下你们的技术栈嘛？<br>3.如果有我有幸能拿到offer，你认为我入职之后最需要注意的点是什么？<br>4.这个职位在公司的发展前景是怎样的？有什么晋升机制？在什么条件下，可以获得晋升机会？<br>5.团队成员有多少人？大家怎么分工？目前团队的核心工作是哪些？</p>
<ul>
<li><a href="https://www.jianshu.com/p/16c493710c2d">当面试官说，“你有什么要问我？”怎样回答最加分？</a></li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到这这篇文章大体上把我想要分享的东西都讲清楚了，但是其实这里面还是有很多细节没有展开去讲，比如我总结的 MySQL、Redis、Kafka的学习笔记等等，这部分内容后续我会简单整理一下陆陆续续到我的公众号和个人博客上，可能就不会放到牛客网这种讨论区了，所以有需要的同学可以关注我的公众号【haxianhe】第一时间阅读。</p>
<hr>
<p>我将文中提到的的 MySQL、Redis、Kafka 思维导图放到了我的公众号中，大家可以<strong>关注我的公众号【haxianhe】，回复 “思维导图” 领取高清pdf版思维导图</strong>。</p>
]]></content>
      <categories>
        <category>面试晋升</category>
      </categories>
      <tags>
        <tag>面试晋升</tag>
      </tags>
  </entry>
  <entry>
    <title>涨薪50%，从小厂逆袭快手 - 附面经</title>
    <url>/2021/02/27/cs-interview/%E6%B6%A8%E8%96%AA50%25%EF%BC%8C%E4%BB%8E%E5%B0%8F%E5%8E%82%E9%80%86%E8%A2%AD%E5%BF%AB%E6%89%8B%20-%20%E9%99%84%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<p>我将我本次面试遇到的面试题整理成了一份面经，大家可以<strong>关注我的公众号【haxianhe】，回复 “面经” 领取</strong>。</p>
<hr>
<p>一会儿就要办离职手续了，趁着这会儿没啥事，简单写一篇文章，分享一下自己的跳槽经验给大家，希望能对大家有所帮助。</p>
<h2 id="个人经历"><a href="#个人经历" class="headerlink" title="个人经历"></a>个人经历</h2><p>我18年从华北电力大学毕业，毕业之后校招进入一家中小厂，这里就不提名字了。</p>
<p>工作了两年多了，这中间负责过单独的项目，设计过有深度的技术方案，也干过无脑的CRUD。</p>
<p>总的来说这段经历让我收获了很多，让我从一名懵懂无知的学生成长为一个可以扛起事的社会人。</p>
<p>因为还没有正式离职，很多东西就不具体说了，简单总结几点这期间的收获：</p>
<p><strong>1.积累很重要</strong></p>
<p>从入职的第一天起就应该养成一个积累笔记的好习惯，比如技术文档、线上问题、技术方案、线上总结、技术分享等等。这些内容的积累对于自己后面无论是提高工作效率（不走重复的路），还是晋升、面试都特别重要。</p>
<p><strong>2.思考很重要,多想想我还能做什么</strong></p>
<p>工作之后一定要养成“完成工作后多想想我还能做点什么”的习惯。需求实现很简单，那就考虑一下能不能加一个降级逻辑让功能更健壮，或者考虑一下除了当前实现方案，业内还有哪些比较成熟的实现方案，各自的优缺点各是什么等等，总之只要想做能做的事情很多很多。很多人都说自己一直在CRUD，但是究竟是你只能CRUD，还是你选择了CRUD呢，毕竟你做的更好也没有人会批评你。</p>
<p><strong>3.把握住出现“线上问题”的机会</strong></p>
<p>功能做了只是具备了项目经验，但是面试的时候真正“值钱”的其实是技术的难点与解决方案，而一般技术难点普遍伴随着“线上问题”。所以，平时工作中积极主动点，出现了线上问题不管是不是自己的都去查、去解决，事后围绕着“问题现象、问题分析、问题影响、解决方案、问题扩展”等去总结、记录到自己的笔记总，后续都是自己最宝贵的财富。</p>
<h2 id="面试经验"><a href="#面试经验" class="headerlink" title="面试经验"></a>面试经验</h2><p>我是跨语言面的 Java 开发岗，前前后后面了很多一二线互联网公司，其中包括腾讯，阿里，字节、快手、美团、滴滴、微博等等，累计拿到了快手、微博、好未来等大小公司的offer，最后决定去快手了。</p>
<p>下面概括性介绍一下我的面试经历，希望能对大家换工作的时候有所借鉴。</p>
<p>首先在考虑好确实想要跳槽之后，可以从下面这几点着手准备面试复习：</p>
<ul>
<li>目标企业</li>
<li>时间节点</li>
<li>简历制作</li>
<li>面试复习</li>
<li>简历内推</li>
<li>进行面试</li>
<li>拿到offer</li>
</ul>
<p><strong>目标企业</strong></p>
<p>如果经过仔细思考觉得自己确实想要面试换工作的话，那首先要考虑的就是自己的目标企业是什么，是去大公司当螺丝钉、还是去一个中小公司当万金油。</p>
<p>也可以结合自己的领域知识进行选择，比如想做视频那就去抖音、快手、视频号，想做物流那就去顺丰、菜鸟、京东物流，想做娱乐内容那就去腾讯、字节、快手、微博，想做教育那就去猿辅导、作业帮、好未来。</p>
<p><strong>时间节点</strong></p>
<p>时间节点问题，包括面试时间点、离职时间点等。</p>
<p>首先是面试时间点，你选择不同的时间节点去面试，拿到offer的难易程度完全不同。同一个岗位，不同时间点面试，难度和要求是不一样的，因为这要看缺人的程度和岗位HC的数量。</p>
<p>一般两种情况下比较容易通过面试拿到offer：</p>
<ol>
<li>急着招人干活的时候 </li>
<li>年底坑比较多的时候</li>
</ol>
<p>先来说说急着招人干活的情况，由于团队招人总是滞后于需求的，所以很多团队总是不定时的会出现“人不够用”的情况，每当这个时候由于急着找人进来干活所以对应聘者的要求也就没那么高。</p>
<p>再就是年底的时候，由于每年年底各个团队都需要做来年的计划，所以这个时候普遍需要多招一些人进来做更多的事情。再就是年底的时候每个公司为了应对来年可能出现的人员流失，都会战略性的储备一些人。</p>
<p>所以，综上如果有熟人联系你某个岗位急招人是比较好的机会，此外就是年底的时候换工作难度相对会小一些。</p>
<p>如果你选择了年底离职，这个时候你就需要考虑你们公司的年终奖是什么时候发，你在哪个时间点离职，进而你也就知道了自己在哪个时间内面试、拿offer是最划算的了，毕竟出来打工都是为了赚钱，没有道理和钱过不去。</p>
<p><strong>简历制作</strong></p>
<p>这部分我推荐一篇阮一峰的文章给大家 </p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2020/01/technical-resume.html">如何写一份有效的技术简历？</a></li>
</ul>
<p>我这里简单给大家总结一下，有需要的人去看具体的文章内容。</p>
<ul>
<li>以项目为主体，设计你的简历</li>
<li>针对企业的需要，突出你的技能</li>
<li>项目的三要素（项目 &#x3D; 产品 + 技术 + 结果）</li>
<li>量化你的项目，给出数字</li>
</ul>
<p><strong>面试复习</strong></p>
<p>面试复习总体可以从下面这几个方面入手，大家可以参照着进行复习、准备，后续这块我会单独写一篇文章来进行分享，有兴趣的朋友可以关注一下我的公众号，也就这一两天。</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/20210226214946.png"></p>
<p><strong>简历内推</strong></p>
<p>假设此时你已经有心仪的公司、简历也准备好了、面试复习也已经进行的差不多了，那么就可以开始找人内推简历了，但是注意不要一上来就试自己想去的公司（ps：你要是大神就当我没说…），建议先找两到三个公司试试水，比如你特别想去字节，那就可以先投递一下百度、滴滴、美团，面完之后根据自己的情况是再弥补弥补自己的不足还是去投递自己想去的公司。</p>
<p>下面再介绍一下具体的内推渠道，一般来说有两个比较好的内推方式（ps：指的是技术人员）：</p>
<ul>
<li>熟人内推，联系自己在各个大厂的同学、校友、前同事等等，一般来说熟人的内推质量会比较高，通过的概率也会大一些。</li>
<li>BOSS直聘，在上面有很多技术leader在找人，一般来找你的都是最近比较有找人需求的，质量也很高。</li>
</ul>
<p><strong>进行面试</strong></p>
<p>关于进行面试有两点需要注意：</p>
<ul>
<li>面试时间，对于像字节、快手这种大小周的公司可以把面试时间约在周末他们上班的时候，其他的公司可以把面试时间约在工作日的晚上。</li>
<li>面试节奏，不要短时间内高频面试，面试完需要反思、总结的，短时间高频面试会让你没有时间思考总结，面试质量没有提升不说，时间长了还会让你疲惫不堪，建议一周以一到两场面试为宜。</li>
</ul>
<p><strong>拿到offer</strong></p>
<p>拿到offer之后主要就是配合背调，确定入职时间等，最重要的是要记得和上家公司和下家公司分别确定好社保缴纳问题，别断缴。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>简单介绍了一下过去几年工作中的几点心得，总结了一下过去几个月的面试阶段。</p>
<p>后续还会写一篇文章介绍面试复习的具体内容，比如有哪些比较推荐的面试内容开源项目、我整理的mysql、redis、kafka等中间件的面试的面试复习笔记、如何通过自我介绍引导面试官进行提问等等。</p>
<p>可能还会单开一篇文章介绍我是如何从PHP转的Java，讲讲社招如何转语言，说实话都说什么语言都一样，可是我遇到的除了字节之外就没有不看你语言的，所以也想以自己的亲身经历给大家介绍一下这方面如何去准备。</p>
<hr>
<p>此外，我还将我本次面试遇到的面试题整理成了一份面经，大家可以<strong>关注我的公众号【haxianhe】，回复 “面经” 领取</strong>。</p>
]]></content>
      <categories>
        <category>面试晋升</category>
      </categories>
      <tags>
        <tag>面试晋升</tag>
      </tags>
  </entry>
  <entry>
    <title>面试总结-2023版</title>
    <url>/2023/08/01/cs-interview/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-2023%E7%89%88/</url>
    <content><![CDATA[<p>本文受众主要为，互联网技术研发人员。</p>
<p>技术面试一般三面和HRBP面不太会卡人，主要都是停在了一面和二面上。我这次换工作前期主要是一面通过率比较低，后面主要是二面通过低。</p>
<p>总结影响面试通过的几点因素：</p>
<ol>
<li>是否真的招人（招几个人）</li>
<li>业务匹配度（谁都想招个有经验的）</li>
<li>面试得分（择优录取）</li>
</ol>
<p>此外，面试有的时候真的很看眼缘，看缘分，所以心态放平和，多面试，多总结，总会有offer的。</p>
<h2 id="面试流程"><a href="#面试流程" class="headerlink" title="面试流程"></a>面试流程</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ol>
<li><p>自我介绍（1-5分钟）<br>了解过往工作经历，对候选人初步了解。</p>
</li>
<li><p>聊一下项目（20分钟）<br>1、 项目的整体介绍，所负责的内容，承担的角色<br>2、根据简历内容进行提问，挖掘候选人优秀的一面<br>3、有哪些挑战与困难，如何解决的。<br>4、做完这个项目在哪方面有提高，收获了什么。是否有不足的地方，是否有改进计划</p>
</li>
<li><p>基础知识（10-15分钟）<br>常见面试题汇总（持续更新）</p>
</li>
<li><p>算法（20分钟）<br>控制在20分钟左右，不出hard级别的，主要考察思维能力、代码整洁度、代码的时间复杂度、空间复杂度&#x3D;</p>
</li>
<li><p>设计题（3-5分钟）<br>2年以内，可以出简单的一些设计题，<br>3-10年的可以出一些比较复杂的设计题，主要考察一下候选人的架构与设计能力。</p>
</li>
<li><p>问答环节（1-5分钟）<br>询问候选人是否有问题，予以解答</p>
</li>
</ol>
<h3 id="二、三面"><a href="#二、三面" class="headerlink" title="二、三面"></a>二、三面</h3><ol>
<li><p>自我介绍（1-5分钟）<br>了解过往工作经历，对候选人初步了解。</p>
</li>
<li><p>聊一下项目（40分钟）<br>1、 项目的整体介绍，所负责的内容，承担的角色<br>2、根据简历内容进行提问，挖掘候选人优秀的一面<br>3、有哪些挑战与困难，如何解决的。<br>4、做完这个项目在哪方面有提高，收获了什么。是否有不足的地方，是否有改进计划<br>5、结合项目问一些技术原理性的问题，考察候选人技术深度。<br>6、结合项目问一些业务标准解决方案，考察候选人技术广度。</p>
</li>
<li><p>问答环节（1-5分钟）<br>询问候选人是否有问题，予以解答</p>
</li>
</ol>
<h3 id="HRBP面"><a href="#HRBP面" class="headerlink" title="HRBP面"></a>HRBP面</h3><ol>
<li><p>自我介绍（1-5分钟）<br>了解过往工作经历，对候选人初步了解。</p>
</li>
<li><p>综合问题（20分钟）<br>从素质文化层面考察候选人，了解候选人是否适合团队，能否长期为公司服务等。</p>
</li>
<li><p>问答环节（1-5分钟）<br>询问候选人是否有问题，予以解答</p>
</li>
</ol>
<h3 id="薪资沟通"><a href="#薪资沟通" class="headerlink" title="薪资沟通"></a>薪资沟通</h3><p>todo</p>
<h2 id="如何写简历"><a href="#如何写简历" class="headerlink" title="如何写简历"></a>如何写简历</h2><p>这部分我推荐一篇阮一峰的文章给大家</p>
<ul>
<li><a href="https://www.ruanyifeng.com/blog/2020/01/technical-resume.html">如何写一份有效的技术简历？</a></li>
</ul>
<p>我这里简单给大家总结一下，有需要的人去看具体的文章内容。</p>
<ul>
<li>以项目为主体，设计你的简历</li>
<li>针对企业的需要，突出你的技能</li>
<li>项目的三要素（项目 &#x3D; 产品 + 技术 + 结果）</li>
<li>化你的项目，给出数字</li>
</ul>
<p>推荐一个制作简历的网站：</p>
<ul>
<li><a href="https://www.wondercv.com/">超级简历 https://www.wondercv.com/</a></li>
</ul>
<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>3分钟左右</p>
<p>模版：打招呼+基本信息+工作经历+工作成果+个人优势+表达期望+谢谢</p>
<ol>
<li>基本信息：姓名+毕业年份+毕业学校+专业</li>
<li>工作经历：不要罗列！把和JD更契合的放前面重点说明。和JD关系不大但是是之前工作重点简单提一下，和JD无关的不说，HR也不太想知道。</li>
<li>工作成功：重点说明自己在以往工作中做出的贡献，取得的成绩或成果。</li>
<li>个人优势：挑1-2个关键词，最好是JD中有提及过的，说明自己的优势。</li>
<li>表达期望：自己更该岗位的匹配度，以及希望可以通过面试一起共事。</li>
</ol>
<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>在面试时，经过寒暄后，一般面试官会让介绍项目经验，常见的问法是：“说下你最近的（或最拿得出手的）一个项目”。</p>
<p><strong>在面试前准备项目介绍，别害怕，因为面试官什么都不知道</strong></p>
<p>面试官是人，不是神，拿到你的简历的时候，是没法核实你的项目细节的。</p>
<p>更何况，你做的项目是以月为单位算的，而面试官最多用3分钟来从你的简历上了解你的项目经验，所以你对项目的熟悉程度要远远超过面试官，所以你一点也不用紧张。</p>
<p>如果你的工作经验比面试官还丰富的话，甚至还可以控制整个面试流程。</p>
<p>下面给出了你和面试官的情况对比：</p>
<table>
<thead>
<tr>
<th></th>
<th>你</th>
<th>面试官</th>
</tr>
</thead>
<tbody><tr>
<td>对你以前的项目和技能</td>
<td>很了解</td>
<td>只能听你说，只能根据你说的内容做出判断</td>
</tr>
<tr>
<td>在面试过程中的职责</td>
<td>在很短的时间内防守成功即可</td>
<td>如果找不出漏洞，就只能算你以前做过</td>
</tr>
<tr>
<td>准备时间</td>
<td>面试前你有充足的时间准备</td>
<td>一般在面试前用3分钟阅读你的简历</td>
</tr>
<tr>
<td>沟通过程</td>
<td>你可以出错，但别出关键性的错误</td>
<td>不会太为难你，除非你太差</td>
</tr>
<tr>
<td>技巧</td>
<td>你有足够的技巧，也可以从网上找到足够多的面试题</td>
<td>其实就问些通用的有规律的问题</td>
</tr>
</tbody></table>
<p>既然面试官无法了解你的底细，那么他们怎么来验证你的项目经验和技术？</p>
<p>下面总结了一些常用的提问方式：</p>
<table>
<thead>
<tr>
<th>提问方式</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td>让你描述工作经验和项目（极有可能是最近的），看看你说的是否和简历上一致</td>
<td>看你是否真的做过这些项目</td>
</tr>
<tr>
<td>看你简历上项目里用到的技术，比如框架、数据库，然后针对这些技术提些基本问题</td>
<td>还是验证你是否做过项目，同时看你是否了解这些技术，为进一步提问做准备</td>
</tr>
<tr>
<td>针对某个项目，不断深入地问一些技术上的问题，或者从不同侧面问一些技术实现，看你前后回答里面是否有矛盾</td>
<td>深入核实你的项目细节</td>
</tr>
<tr>
<td>针对某技术，问些项目里一定会遇到的问题，比如候选人说做过数据库，那么就会问索引方面的问题</td>
<td>通过这类问题，核实候选人是否真的有过项目经验（或者还仅仅是学习经验）</td>
</tr>
</tbody></table>
<p><strong>准备项目的各种细节，一旦被问倒了，就说明你没做过</strong></p>
<p> 一般来说，在面试前，大家应当准备项目描述的说辞，自信些，因为这部分你说了算，流利些，因为你经过充分准备后，可以知道你要说些什么。</p>
<p>不少人是拘泥于“项目里做了什么业务，以及代码实现的细节”，这就相当于把后继提问权直接交给面试官。</p>
<p>下表列出了一些不好的回答方式：</p>
<table>
<thead>
<tr>
<th>回答方式</th>
<th>后果</th>
</tr>
</thead>
<tbody><tr>
<td>我在XX软件公司做了XX门户网站项目，这个项目做到了XX功能，具体是XX和XX模块，各模块做了XX功能，客户是XX，最后这个项目挣了XX钱</td>
<td>直接打断，因为业务需求我不需要了解，我会直接问他项目里的技术</td>
</tr>
<tr>
<td>（需要招聘一个Java后端开发，会Spring MVC）最近一个项目我是用C#（或其他非Java技术）实现的，实现了……或者我最近做的不是开发，而是测试……或者我最近的项目没有用到Spring MVC</td>
<td>提问，你最近用到SSH技术的项目是什么时候，然后在评语上写：最近XX时间没接触过SSH</td>
</tr>
<tr>
<td>在毕业设计的时候（或者在读书的时候，在学习的时候，在XX培训学校，在XX实训课程中），……</td>
<td>直接打断，提问你这个是否是商业项目，如果不是，你有没有其他的商业经验。如果没商业项目经验，除非是校招，否则就直接结束面试</td>
</tr>
<tr>
<td>描述项目时，一些关键要素（比如公司、时间、所用技术等）和简历上的不匹配</td>
<td>我们会深究这个不一致的情况，如果是简历造假，那么可能直接中断面试，如果真的是笔误，那么就需要提供合理的解释</td>
</tr>
</tbody></table>
<p>在避免上述不好的回答的同时，大家可以按下表所给出的要素准备项目介绍。</p>
<table>
<thead>
<tr>
<th>要素</th>
<th>样式</th>
</tr>
</thead>
<tbody><tr>
<td>控制在1分钟里面，讲出项目基本情况，比如项目名称，背景，给哪个客户做，完成了基本的事情，做了多久，项目规模多大，用到哪些技术，数据库用什么，然后酌情简单说一下模块。重点突出背景，技术，数据库和其他和技术有关的信息。</td>
<td>我在XX公司做了XX外汇保证金交易平台，客户是XX银行，主要完成了挂盘，实盘成交，保证金杠杆成交等功能，数据库是Oracle，前台用到JS等技术，后台用到Java的SSH，几个人做了X个月。不需要详细描述各功能模块，不需要说太多和业务有关但和技术无关的。如果面试官感兴趣，等他问。</td>
</tr>
<tr>
<td>要主动说出你做了哪些事情，这部分的描述一定需要和你的技术背景一致。</td>
<td>我做了外汇实盘交易系统，挂单成交系统，XXX模块，做了X个月</td>
</tr>
<tr>
<td>描述你在项目里的角色</td>
<td>我主要是做了开发，但在开发前，我在项目经理的带领下参与了业务调研，数据库设计等工作，后期我参与了测试和部署工作。</td>
</tr>
<tr>
<td>可以描述用到的技术细节，特别是你用到的技术细节，这部分尤其要注意，你说出口的，一定要知道，因为面试官后面就根据这个问的。你如果做了5个模块，宁可只说你能熟练说上口的2个。</td>
<td>用到了Java里面的集合，JDBC，…等技术，用到了Spring MVC等框架，用技术连接数据库。</td>
</tr>
<tr>
<td>这部分你风险自己承担，如果可以，不露声色说出一些热门的要素，比如Linux，大数据，大访问压力等。但一旦你说了，面试官就会直接问细节。</td>
<td>这个系统里，部署在Linux上，每天要处理的数据量是XX，要求是在4小时，1G内存是的情况下处理完5千万条数据。平均访客是每分钟XXX。</td>
</tr>
</tbody></table>
<h3 id="线上问题"><a href="#线上问题" class="headerlink" title="线上问题"></a>线上问题</h3><p>大家平时工作中一定要 <strong>把握住出现“线上问题”的机会。</strong> </p>
<p>因为，功能做了只是具备了项目经验，但是面试的时候真正“值钱”的其实是技术的难点与解决方案，而一般技术难点普遍伴随着“线上问题”。所以，平时工作中积极主动点，出现了线上问题不管是不是自己的都去查、去解决，事后围绕着“问题现象、问题分析、问题影响、解决方案、问题扩展”等去总结、记录到自己的笔记总，后续都是自己最宝贵的财富。</p>
<h3 id="技术亮点"><a href="#技术亮点" class="headerlink" title="技术亮点"></a>技术亮点</h3><p>结合自己遇到过的线上问题，优先准备分布式组件方面的技术亮点，常用的分布式组件主要有 MySQL、Redis、RocketMQ&#x2F;Kafka、ES等。</p>
<p>这部分内容可以参考JD上对技术要求，有针对性的去准备。</p>
<h2 id="技术问题"><a href="#技术问题" class="headerlink" title="技术问题"></a>技术问题</h2><p>这部分后续我会做两方面的总结：</p>
<ol>
<li>技术核心原理</li>
<li>面试高频问题及答案</li>
</ol>
<p>先简单列一下这里的知识框架</p>
<h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p><strong>Java</strong></p>
<ul>
<li>Java 基础<ul>
<li>概述</li>
<li>基础语法</li>
<li>面向对象</li>
<li>常用类</li>
<li>异常处理</li>
<li>I&#x2F;O</li>
<li>序列化</li>
<li>泛型</li>
<li>注解</li>
<li>反射</li>
<li>JDK1.8新特性</li>
</ul>
</li>
<li>Java 集合<ul>
<li>引言</li>
<li>List</li>
<li>Set</li>
<li>Map</li>
</ul>
</li>
<li>Java 并发<ul>
<li>基础</li>
<li>ThreadLocal</li>
<li>Java内存模型</li>
<li>锁</li>
<li>并发工具类</li>
<li>线程池</li>
</ul>
</li>
<li>JVM<ul>
<li>引言</li>
<li>内存管理</li>
<li>JVM调优</li>
<li>虚拟机执行</li>
</ul>
</li>
</ul>
<p><strong>Spring</strong></p>
<ul>
<li>基础</li>
<li>IOC</li>
<li>AOP</li>
<li>事务</li>
<li>MVC</li>
<li>Spring Boot</li>
<li>Spring Cloud</li>
</ul>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p><strong>MySQL</strong></p>
<ul>
<li>基础</li>
<li>数据库架构</li>
<li>存储引擎</li>
<li>日志</li>
<li>SQL 优化</li>
<li>索引</li>
<li>锁</li>
<li>事务</li>
<li>高可用&#x2F;性能</li>
<li>运维</li>
</ul>
<p><strong>Redis</strong></p>
<ul>
<li>基础</li>
<li>持久化</li>
<li>高可用</li>
<li>缓存设计</li>
<li>Redis运维</li>
<li>Redis应用</li>
<li>底层结构</li>
<li>其他问题</li>
</ul>
<p><strong>RocketMQ&#x2F;Kafka</strong></p>
<ul>
<li>基础</li>
<li>进阶</li>
<li>原理</li>
</ul>
<p><strong>ES</strong></p>
<h3 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h3><p><strong>计算机网络</strong></p>
<ul>
<li>基础</li>
<li>网络综合</li>
<li>HTTP</li>
<li>TCP</li>
<li>UDP</li>
<li>IP</li>
<li>网络安全</li>
</ul>
<p><strong>操作系统</strong></p>
<ul>
<li>引论</li>
<li>操作系统结构</li>
<li>进程和线程</li>
<li>内存管理</li>
<li>文件</li>
<li>IO</li>
</ul>
<h3 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h3><p>算法的话推荐大家最起码刷一下牛客网上的 <a href="https://www.nowcoder.com/ta/coding-interviews">《剑指offer》67题</a></p>
<p>答案的话大家可以在网上搜一下“牛客网《剑指Offer》66题题解”，我本人参考的leetcode上的《画解剑指 Offer》不过这个要开会员，大家可以根据自己的需求进行选择。</p>
<p>之后要是还有时间和精力的话推荐大家再刷一下 <a href="https://www.nowcoder.com/ta/job-code-high-rd">牛客霸题</a>，上面可以筛选企业和考察次数等</p>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><p>todo</p>
<h2 id="问答环节"><a href="#问答环节" class="headerlink" title="问答环节"></a>问答环节</h2><p>一面</p>
<ul>
<li>能给我简单介绍一下目前团队的主要业务吗？以及相应的人员情况？如果我后面有机会能加入进去大概会做哪个方向？</li>
<li>您认为在这里工作最大的挑战是什么？以及这个团队最吸引您的是什么？</li>
</ul>
<p>二面</p>
<ul>
<li>团队未来一段时间内的工作重心是什么？新人有机会接触到吗？</li>
<li>对于这个岗位您最看重应聘者什么核心能力？您认为这项工作最大的挑战是什么？如果有幸加入，我需要提前准备什么？</li>
</ul>
<p>三面</p>
<ul>
<li>您筛选人才一般最看重哪些能力？</li>
<li>您希望我最为一线员工在公司发挥出怎样的价值？</li>
<li>您对我个人提升上有哪些建议？</li>
</ul>
<p>hr面</p>
<ul>
<li>想了解下公司的员工培养机制是怎么样的？以及是否有导师之类的</li>
<li>公司薪资构成是怎么样的？</li>
<li>公司晋升的周期</li>
<li>试用期是多久？转正考核标准是什么？</li>
<li>团队的工作氛围和领导风格是怎么样的？</li>
</ul>
]]></content>
      <categories>
        <category>面试晋升</category>
      </categories>
      <tags>
        <tag>面试晋升</tag>
      </tags>
  </entry>
  <entry>
    <title>编码习惯：在数据量较大的情况下</title>
    <url>/2019/01/02/cs-sftc/%E7%BC%96%E7%A0%81%E4%B9%A0%E6%83%AF%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%87%8F%E8%BE%83%E5%A4%A7%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B/</url>
    <content><![CDATA[<p>最近在负责项目的数据报表部分的工作。上一个月数据量增长的很快，也发现了自己报表代码中的几个由数据量过大引起的问题。现简单总结一下。</p>
<h1 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h1><p>在实际业务当中经常会遇到一个模块通过rpc向另一个模块查询信息的情况。比如：</p>
<ul>
<li>根据商品id查询商品信息</li>
<li>根据门店id查询门店信息</li>
</ul>
<p>这里有两点要注意：</p>
<ol>
<li>要批量查询信息，不要在foreach中进行信息查询</li>
<li>在查询前要对id数组进行去重操作</li>
</ol>
<h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><p>因为报表是对一段时间的数据进行处理，数据量可能会比较大，所以一开始就要在关键位置进行分页操作。</p>
<h1 id="不对空数组进行foreach"><a href="#不对空数组进行foreach" class="headerlink" title="不对空数组进行foreach"></a>不对空数组进行foreach</h1><p>在PHP中对空数组进行foreach操作会报warning。</p>
<p>所以在对数组进行foreach执行要进行empty判断。</p>
<h1 id="不要再foreach中进行rpc调用，数据库操作"><a href="#不要再foreach中进行rpc调用，数据库操作" class="headerlink" title="不要再foreach中进行rpc调用，数据库操作"></a>不要再foreach中进行rpc调用，数据库操作</h1><p>在接口调用的过程中，网络耗时要远大于内存中执行的操作的耗时。</p>
<p>所以在模块与模块之间，模块与数据库之间，需要查询信息时，要通过批量的方式进行数据查询。</p>
<ul>
<li>模块与模块之间可以通过传数组参数进行数据查询</li>
<li>在查库的时候，可以通过in操作进行数据查询</li>
</ul>
<p>注：千万不要在foreach中进行rpc调用，数据库操作，否则就是在给自己挖坑。</p>
<h1 id="计算同类数据，使用相同的算法"><a href="#计算同类数据，使用相同的算法" class="headerlink" title="计算同类数据，使用相同的算法"></a>计算同类数据，使用相同的算法</h1><p>实现同样的功能，尽量去复用已经实现了这个功能的代码。</p>
<p>如果实在不方便复用这部分代码，那也要保证使用相同的算法实现这部分逻辑。否则，就是在给自己挖坑。</p>
]]></content>
      <categories>
        <category>顺丰调度</category>
      </categories>
      <tags>
        <tag>顺丰调度</tag>
      </tags>
  </entry>
  <entry>
    <title>首页接口优化</title>
    <url>/2018/10/23/cs-sftc/%E9%A6%96%E9%A1%B5%E6%8E%A5%E5%8F%A3%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h1><p>在项目中写的一个下单程序的首页接口，涉及到查询商品分组、查询各个分组下的商品、查询商品的促销信息等多个环节的操作，最后在项目压测环节发现性能与预期相差巨大…单机TPS只有10，而目标至少100以上…</p>
<p>需要对首页接口进行优化。</p>
<h1 id="问题梳理"><a href="#问题梳理" class="headerlink" title="问题梳理"></a>问题梳理</h1><p>通过分析，该接口性能瓶颈主要在访问数据库的次数太多上面，所以本次优化的重点也在于如何降低数据库访问次数。</p>
<p>简单反思了一下为什么当初会写出一个性能这么差的接口(￣∇￣)：</p>
<ul>
<li>先组织数据结构后去数据库查询数据</li>
<li>先组织数据结构后去其他方法&#x2F;RPC查询数据</li>
<li>一句话概括，<strong>“将拼装数据的过程放到了查询数据之前进行”导致了这个问题</strong></li>
</ul>
<p>举个例子：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwgy1fu9nxxrcuhj317e0faadl.jpg"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwgy1fu9nzivkpaj311m0giq6a.jpg"></p>
<p>第一遍写的接口中，到处都充斥着这种例子。</p>
<p>其实就是党哥说的那句：“<strong>不要在foreach中进行findRow、insert操作</strong>”，事实上，最好也不要在foreach中进行rpc调用、调用进行数据库操作的方法，这些都会让数据库访问次数增加。</p>
<p><strong>道理都懂，但是没遇到问题之前总是不能感同身受。</strong></p>
<h1 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h1><p>减少访问数据库次数，组装的操作尽量在内存中进行操作（ SQL 能用 in 操作尽量用 in 操作），查询的时候尽量批量操作（包括RPC）</p>
<p>坚决不在 foreach 中进行 insert、findRow 操作。</p>
<p>举个例子：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwgy1fu9o2gb9afj31a60d6tbz.jpg"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwgy1fu9o3aygarj31c40sqafd.jpg"></p>
<p>优化前，单次接口请求访问数据库250次以上（随着分类、商品、促销信息的增加访问数据库还会增加）。</p>
<p>优化后，单次接口请求访问数据库11次（不变）。</p>
<p>在开发环境中的性能对比：</p>
<p>这是优化前的单次访问响应时间：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwly1fu9ojqf2qij30vk03mq4b.jpg"></p>
<p>36ms</p>
<p>这是优化后的单次访问响应时间：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwgy1fu9olsh462j30vc08un07.jpg"></p>
<p>5ms</p>
<p>上线之后，从log日志看，<strong>代码时间从1000ms降低到了30ms左右</strong>，问题来了，可是<strong>QA反馈的结果是响应时间依旧很长，优化有限</strong>。</p>
<p>那么问题来了，问题出在哪里了？问题出在nginx上了。</p>
<h1 id="nginx-参数调优"><a href="#nginx-参数调优" class="headerlink" title="nginx 参数调优"></a>nginx 参数调优</h1><p>在开始讲具体内容之前，先给出一组数据</p>
<table>
<thead>
<tr>
<th>代码优化前：</th>
<th>代码优化后：</th>
</tr>
</thead>
<tbody><tr>
<td>线下：代码时间 36ms</td>
<td>线下：代码时间 5ms</td>
</tr>
<tr>
<td>线上：代码时间 1000ms</td>
<td>线上：代码时间 30ms</td>
</tr>
<tr>
<td>线上：响应时间 1500ms</td>
<td>线上：响应时间 450ms</td>
</tr>
</tbody></table>
<p>看到了吗，代码优化后，影响时间只不过从1000多ms降低到了500左右ms，所以QA测的TPS从10个左右上升到了20个左右，所以就是优化效果有限，那么问题出在哪里呢？出在了nginx上，nginx处理时间过长，下面讲讲平哥修改的了哪些nginx参数，以及每个参数的作用。</p>
<p>平哥改了nginx.conf的参数，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwly1fucq4f4flbj30qe03bdgo.jpg"></p>
<h2 id="fastcgi-buffer-size"><a href="#fastcgi-buffer-size" class="headerlink" title="fastcgi_buffer_size"></a>fastcgi_buffer_size</h2><table>
<thead>
<tr>
<th>Syntax:</th>
<th>fastcgi_buffer_size size;</th>
</tr>
</thead>
<tbody><tr>
<td>Default:</td>
<td>fastcgi_buffer_size 4k</td>
</tr>
<tr>
<td>Context:</td>
<td>http, server, location</td>
</tr>
</tbody></table>
<p>Sets the size of the buffer used for reading the first part of the response received from the FastCGI server.</p>
<p>This part usually contains a small response header. By default, the buffer size is equal to one memory page.</p>
<p>This is either 4K or 8K, depending on a platform. It can be made smaller, however.</p>
<p>后端服务器的响应头会放到fastcgi_buffer_size当中，这个大小默认等于fastcgi_buffers当中的设置单个缓冲区的大小。</p>
<p>fastcgi_buffer_size只是响应头的缓冲区，没有必要也跟着设置太大。 fastcgi_buffer_size最好单独设置，一般设置个4k就够了。</p>
<h2 id="fastcgi-buffers"><a href="#fastcgi-buffers" class="headerlink" title="fastcgi_buffers"></a>fastcgi_buffers</h2><table>
<thead>
<tr>
<th>Syntax:</th>
<th>fastcgi_buffers number size;</th>
</tr>
</thead>
<tbody><tr>
<td>Default:</td>
<td>fastcgi_buffers 8 4k</td>
</tr>
<tr>
<td>Context:</td>
<td>http, server, location</td>
</tr>
</tbody></table>
<p>Sets the number and size of the buffers used for reading a response from the FastCGI server,</p>
<p>for a single connection. By default, the buffer size is equal to one memory page.</p>
<p>This is either 4K or 8K, depending on a platform.</p>
<p>fastcgi_buffers的缓冲区大小一般会设置的比较大，以应付大网页。 fastcgi_buffers当中单个缓冲区的大小是由系统的内存页面大小决定的，Linux系统中一般为4k。 fastcgi_buffers由缓冲区数量和缓冲区大小组成的。总的大小为number*size。</p>
<p>若某些请求的响应过大,则超过fastcgi_buffers的部分将被缓冲到硬盘(缓冲目录由_temp_path指令指定), 当然这将会使读取响应的速度减慢, 影响用户体验. 可以使用fastcgi_max_temp_file_size指令关闭磁盘缓冲.</p>
<h2 id="fastcgi-busy-buffers-size"><a href="#fastcgi-busy-buffers-size" class="headerlink" title="fastcgi_busy_buffers_size"></a>fastcgi_busy_buffers_size</h2><table>
<thead>
<tr>
<th>Syntax:</th>
<th>fastcgi_busy_buffers_size size;</th>
</tr>
</thead>
<tbody><tr>
<td>Default:</td>
<td>fastcgi_busy_buffers_size 8k</td>
</tr>
<tr>
<td>Context:</td>
<td>http, server, location</td>
</tr>
</tbody></table>
<p>When buffering of responses from the FastCGI server is enabled, limits the total size of buffers that can be busy sending a response to the client while the response is not yet fully read.</p>
<p>In the meantime, the rest of the buffers can be used for reading the response and, if needed, buffering part of the response to a temporary file.</p>
<p>By default, size is limited by the size of two buffers set by the fastcgi_buffer_sizeand fastcgi_buffers directives.</p>
<p>fastcgi_busy_buffers_size不是独立的空间，它是fastcgi_buffers和fastcgi_buffer_size的一部分。nginx会在没有完全读完后端响应的时候就开始向客户端传送数据，</p>
<p>所以它会划出一部分缓冲区来专门向客户端传送数据(这部分的大小是由fastcgi_busy_buffers_size来控制的，建议为fastcgi_buffers中单个缓冲区大小的2倍)，</p>
<p>然后它继续从后端取数据，缓冲区满了之后就写到磁盘的临时文件中。</p>
<h2 id="fastcgi-max-temp-file-size和fastcgi-temp-file-write-size"><a href="#fastcgi-max-temp-file-size和fastcgi-temp-file-write-size" class="headerlink" title="fastcgi_max_temp_file_size和fastcgi_temp_file_write_size"></a>fastcgi_max_temp_file_size和fastcgi_temp_file_write_size</h2><table>
<thead>
<tr>
<th>Syntax:</th>
<th>fastcgi_max_temp_file_size size;</th>
</tr>
</thead>
<tbody><tr>
<td>Default:</td>
<td>fastcgi_max_temp_file_size 1024m;</td>
</tr>
<tr>
<td>Context:</td>
<td>http, server, location</td>
</tr>
</tbody></table>
<p>When buffering of responses from the FastCGI server is enabled, and the whole response does not fit into the buffers set by the fastcgi_buffer_size and fastcgi_buffers directives,</p>
<p>a part of the response can be saved to a temporary file. This directive sets the maximum size of the temporary file.</p>
<p>The size of data written to the temporary file at a time is set by the fastcgi_temp_file_write_size directive.</p>
<p>The zero value disables buffering of responses to temporary files.</p>
<p>This restriction does not apply to responses that will be cached or stored on disk.</p>
<p>临时文件由fastcgi_max_temp_file_size和fastcgi_temp_file_write_size这两个指令决定。 fastcgi_temp_file_write_size是一次访问能写入的临时文件的大小，默认是fastcgi_buffer_size和proxy_buffers中设置的缓冲区大小的2倍，Linux下一般是8k。</p>
<p>fastcgi_max_temp_file_size指定当响应内容大于proxy_buffers指定的缓冲区时, 写入硬盘的临时文件的大小. 如果超过了这个值, Nginx将与Proxy服务器同步的传递内容, 而不再缓冲到硬盘. 设置为0时, 则直接关闭硬盘缓冲.</p>
<h2 id="fastcgi-buffering"><a href="#fastcgi-buffering" class="headerlink" title="fastcgi_buffering"></a>fastcgi_buffering</h2><table>
<thead>
<tr>
<th>Syntax:</th>
<th>fastcgi_buffering on &#x2F; off;</th>
</tr>
</thead>
<tbody><tr>
<td>Default:</td>
<td>fastcgi_buffering on;</td>
</tr>
<tr>
<td>Context:</td>
<td>http, server, location</td>
</tr>
</tbody></table>
<p>Enables or disables buffering of responses from the FastCGI server.</p>
<p>fastcgi_buffering这个参数用来控制是否打开后端响应内容的缓冲区，如果这个设置为off，那么fastcgi_buffers和fastcgi_busy_buffers_size这两个指令将会失效。但是无论fastcgi_buffering是否开启，对fastcgi_buffer_size都是生效的。</p>
<p>fastcgi_buffering开启的情况下，nignx会把后端返回的内容先放到缓冲区当中，然后再返回给客户端(边收边传，不是全部接收完再传给客户端)。 临时文件由fastcgi_max_temp_file_size和fastcgi_temp_file_write_size这两个指令决定的。</p>
<p>如果fastcgi_buffering关闭，那么nginx会立即把从后端收到的响应内容传送给客户端，每次取的大小为fastcgi_buffer_size的大小，这样效率肯定会比较低。</p>
<p>注： fastcgi_buffering启用时，要提防使用的代理缓冲区太大。这可能会吃掉你的内存，限制代理能够支持的最大并发连接数。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>优化前的接口响应时间：1500ms&#x3D;1000+500</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwgy1fucqa4s7xzj30l20a1dgk.jpg"></p>
<p>优化后的接口响应时间：107.20ms&#x3D;30+70</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwgy1fucqagu7q1j31io0bmdhp.jpg"></p>
<p>优化前的接口TPS：10</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwgy1fucqatp2spj30ln035js7.jpg"></p>
<p>优化后的接口TPS：124</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwgy1fucqb2e9q6j30qm05075w.jpg"></p>
<p>优化前后在线下数据量比较少的时候后端代码处理时间相差7倍，在线上数据量多的时候后端代码处理时间相差30倍，可见随着数据的增加，代码质量的影响会更大。</p>
<h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>这是工作以来，第一次遇到性能上的问题，从业务逻辑的角度来说，我一开始那么写一点问题都没有，存在问题的是性能方面，这也不正是在公司里面和在学校写代码的区别吗。</p>
<p>在学校只要把代码写出来就行，不重视细节，不重视性能。但是在公司里面就不一样了，你不光要完成任务，还要完成的漂亮，因为你是直接面向用户的，如果你有bug，体验不好，那用户可不买单，最终吃亏的还是自己。</p>
]]></content>
      <categories>
        <category>顺丰调度</category>
      </categories>
      <tags>
        <tag>顺丰调度</tag>
      </tags>
  </entry>
  <entry>
    <title>全身分化</title>
    <url>/2018/11/14/fit-notes/%E5%85%A8%E8%BA%AB%E5%88%86%E5%8C%96/</url>
    <content><![CDATA[<h1 id="热身"><a href="#热身" class="headerlink" title="热身"></a>热身</h1><p>跑步、俯卧撑、拉胸、拉背</p>
<h1 id="腿"><a href="#腿" class="headerlink" title="腿"></a>腿</h1><p>哑铃&#x2F;杠铃深蹲、哑铃&#x2F;杠铃硬拉、坐姿器械腿举、坐姿器械举腿、俯卧器械腿屈</p>
<h1 id="胸"><a href="#胸" class="headerlink" title="胸"></a>胸</h1><p>杠铃&#x2F;哑铃卧推、杠铃&#x2F;上斜卧推、哑铃飞鸟、哑铃上斜飞鸟</p>
<h1 id="背"><a href="#背" class="headerlink" title="背"></a>背</h1><p>引体向上、高位下拉、宽度动作三直臂下拉、哑铃划船、坐姿划船、屈腿硬拉、山羊挺身</p>
<h1 id="二头肌"><a href="#二头肌" class="headerlink" title="二头肌"></a>二头肌</h1><p>哑铃交替弯举</p>
<h1 id="三头肌"><a href="#三头肌" class="headerlink" title="三头肌"></a>三头肌</h1><p>双臂哑铃颈后臂屈伸</p>
<h1 id="腹"><a href="#腹" class="headerlink" title="腹"></a>腹</h1><p>仰卧起坐（抱杠铃片、哑铃）</p>
<h1 id="拉伸"><a href="#拉伸" class="headerlink" title="拉伸"></a>拉伸</h1><p>拉胸、拉背</p>
<blockquote>
<p>注：每个动作3x10</p>
</blockquote>
]]></content>
      <categories>
        <category>健身笔记</category>
      </categories>
      <tags>
        <tag>健身笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 年终总结</title>
    <url>/2018/12/28/summary/2018%20%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>2018年发生了三件对我个人影响比较大的事情：<strong>一是考研失败，二是找工作，三是参加工作。</strong></p>
<h1 id="考研失败"><a href="#考研失败" class="headerlink" title="考研失败"></a>考研失败</h1><p>考研失败这件事情现在回想起来偶然中带着必然因素，所以也没什么好遗憾的了，失败的因素简单总结为如下几点：</p>
<ol>
<li><strong>太浮躁</strong>，不能踏踏实实坐在那把知识记到脑子里。</li>
<li>内心充满了对考研这件事的抗拒。</li>
</ol>
<p>主要还是第一点，对一些形式（习题册、视频的收集，做题方法等）的重视大于对知识内容本身的重视。</p>
<p>不管做人还是做事，还是要踏踏实实的。</p>
<p><strong>踏实的态度 x 时间的积累 &#x3D; 梦想的实现</strong></p>
<h1 id="找工作"><a href="#找工作" class="headerlink" title="找工作"></a>找工作</h1><p>在我看来，找工作是一件很成体系的事情，具有一定的<strong>可准备性（套路）和积累性。</strong></p>
<p>可准备性，包括如何写简历、投简历、笔经面经等。</p>
<p>积累性，主要指面试是一项经验性运动。随着你的面试次数的增加，你的面试经验也会随之增加。所以在面试自己心仪的企业之前，最好先面试几家其他的公司练练手。以最饱满的姿态去面试自己心仪的企业。</p>
<blockquote>
<p>注意：并不是面试的企业越多你的状态就会越好，不是这样的，当面试一定的次数之后，你就没有精力也没有心情去面试了。所以最好是2——3家心仪的企业，5——7家练手的企业。具体这个数字是多少还是要看个人的情况。</p>
</blockquote>
<h2 id="写简历"><a href="#写简历" class="headerlink" title="写简历"></a>写简历</h2><p>要提前很长一段时间去准备自己的简历，而且在每次投简历之前，要有针对性的对自己的简历进行修改。</p>
<h2 id="投简历"><a href="#投简历" class="headerlink" title="投简历"></a>投简历</h2><p><strong>联系认识的人帮忙内推</strong></p>
<p><strong>Boss直聘</strong></p>
<p><strong>企业招聘官网</strong></p>
<h2 id="笔经面经"><a href="#笔经面经" class="headerlink" title="笔经面经"></a>笔经面经</h2><p><strong>牛课网</strong></p>
<p>面试前在牛课网上刷刷该公司的笔经面经，根据刷的结果有针对性的弥补自己的知识盲区。</p>
<p>每次面试结束之后也要及时的，有针对性的进行总结。</p>
<h1 id="参加工作"><a href="#参加工作" class="headerlink" title="参加工作"></a>参加工作</h1><p>6.30号大学毕业，7.3号入职，参加工作。</p>
<p>工作了也快半年了，有几点心得简单总结一下：</p>
<ol>
<li><p>找工作一定要找一件自己喜欢的工作。</p>
<p> 只有这样，你的梦想才会有成长的土壤。</p>
</li>
<li><p>交到你手上的任务，那是你的责任，做好是你的本分。</p>
</li>
<li><p>你和企业和leader之间是雇佣关系，工作时间要把工作做好。但是，非工作时间你要有计划的去学习，去梳理自己的知识体系。因为除了你自己，没有人关心你的职业发展，没有人关心你的未来。</p>
</li>
</ol>
<blockquote>
<p>注：要学会自己对自己负责。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一年经历了很多。</p>
<p>有失败，有成功。</p>
<p>有无奈，有痛苦，也有苦尽甘来的那份喜悦。</p>
<p>时间易逝人易老，白云千载空悠悠。</p>
<p>保持一颗清醒的头脑，利用好时间的累积效应，塑造一份完美的人生。</p>
<p><strong>你的人生需要你自己去负责。</strong></p>
]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 年终总结</title>
    <url>/2019/12/16/summary/2019%20%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>2019年即将过去了，是时候开始写2019年终总结了。</p>
<p>总的来说，这一年最大的收获不是来自于工作上的成长而是来自于情感上的成长。</p>
<p>在工作方面随着工作时间的延长，工作经验更加丰富了，但是并没有达到年初预计的质的变化。而这一年的情感经历称得上多姿多彩，随着毕业前就在一起的那段感情的结束，带给了我无尽的创伤（<a href="https://blog.haxianhe.com/2019/06/17/%E7%97%9B%E8%AF%81%E6%98%8E%E4%BD%A0%E5%9C%A8%E8%9C%95%E5%8F%98%EF%BC%81/#more">痛，证明你再蜕变</a>）,而正是因为够痛所以当从这段感情走出来之后，带给我的收获也是特别特别的大。</p>
<p>这篇文章我计划从感情、读书、健身、项目等几个角度来总结我的2019.</p>
<h1 id="感情"><a href="#感情" class="headerlink" title="感情"></a>感情</h1><p><strong>1-6月</strong></p>
<p>今年的上半年一直纠结于感情问题，说来可笑，被人拿捏的死死的。</p>
<p><strong>7-8月</strong></p>
<p>而7，8月份更多则是处于感受结束后的无尽痛苦中。</p>
<p><strong>9-12</strong></p>
<p>年末终于从这段失败的感情中走了出来，而走出来之后的下一个问题则是，总会不自觉的感觉很孤独，于是这期间又经历了一段短暂感情，而最终终于明白了自己想要的到底是什么，也学会了如何和自己相处，即自处。</p>
<h1 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h1><p>这一年读的书也体现了这一年的特点，那就是相比于技术的成长对自己、对社会的认知的提升更加显著。</p>
<ul>
<li>《吃掉那只青蛙》</li>
<li>《工作前5年，决定你一生的财富》</li>
<li>《小王子》</li>
<li>《亲密关系》</li>
<li>《穷查理宝典》</li>
<li>《新生-七年就是一辈子》</li>
<li>《思考致富》</li>
<li>《高效能人士的七个习惯》</li>
<li>《财富自由之路》</li>
<li>《北京折叠》</li>
<li>《异类》</li>
<li>《蔡康永的说话之道》</li>
<li>《聪明的投资者》</li>
<li>《乌合之众》</li>
<li>《暗时间》</li>
<li>《睡眠革命》</li>
<li>《奇特的一生》</li>
<li>《高效能MySQL》</li>
<li>《活着》</li>
<li>《大型网站技术架构》</li>
<li>《少有人走的路》</li>
<li>《代码整洁之道：程序员的职业素养》</li>
<li>《非暴力沟通》</li>
<li>《娱乐至死》</li>
</ul>
<p>这一年不知不觉中读了24本书，其中技术类图书3本，非技术类图书21本。</p>
<p>明年的重点是将技术类图书的比例提升上来。</p>
<h1 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h1><p>2019年带给我的另一个变化或许是我的健身终于入门了吧。</p>
<p>由于感情受挫，所以很长一段时间内，健身房就是我精神的唯一寄托，在泽康的带领下，终于爱上了这门事业。</p>
<p>接下来的目标很明确，就是坚持下去✊</p>
<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><p>2019年开年之后随着Costa项目的收尾完成，在参与了一段时间晨配的工作之后，这一年80%的时间都在做TS-资源管理的工作，工作内容适中，难度不大（幸好在这段时间遇到的是这个项目，否则就惨了）年末的这段时间转身投入小哥排版的项目中。相比于其他项目小哥排版的复杂程度要高很多，不过我的状态也和之前不一样了，所以还是hold的住。</p>
<p>年前的这段时间，一方面要把前面做过的项目从bad case的角度简单总结一下。另一方面，需要从项目目标的角度梳理一下小哥排班的代码。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果要用一个词来总结2019的话，那我选择“自处”。</p>
<p>如果要用一个词来计划2020的话，那我选择“自律”。</p>
]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 年终总结</title>
    <url>/2021/01/05/summary/2020%20%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>技术可以从两个方向进行总结，主要是围绕着工作展开，辅之以技术原理的学习。</p>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>2020年的主要工作内容是智域系统中区域直管方向，主要分为<strong>吻合率、区域数据库、区域直管任务、AOI区域变管理</strong>等四个部分。</p>
<p>年中的几个线上问题暴露了研发流程的不够规范，所幸乾哥来了我们这边以后，在<strong>技术评审</strong>这块做了充足的建设，使得后续项目的开展井然有序。</p>
<p>今年工作过程中的主要成长体现在 <strong>”大数据规模下的性能意识“</strong>，在日均千万级订单的大背景下，实现每一个功能都要充分考虑到”性能“问题，这种性能意识为后续自己在技术深度上的成长打下了坚实的基础。</p>
<p>今年是自己工作的第三个年头，随着工作时间的增长，自己刚刚入职的那股“拼劲”也很难维持了，所以这个时候自己也在寻找“工作”与“生活”的平衡点，先阶段的想法是尽可能的<strong>提升工作效率，多思考、多总结</strong>，只有这样才能在精力减少的情况下完成好同样多的事情，甚至于未来有一天可以以有限的精力完成更多的工作内容。</p>
<h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>随着工作年限的增长，自己也开始意识到技术原理的重要性，所以今年也陆陆续续重新学习、整理了一下 <strong>MySQL、Redis 的实现原理</strong>，还是很有收获的。</p>
<p>&#x2F;&#x2F;TODO 相关内容后续发到博客上</p>
<h2 id="投资"><a href="#投资" class="headerlink" title="投资"></a>投资</h2><p><strong>股票</strong></p>
<p>今年A股总体行情不错，炒了9个月的股，收益率为 <strong>16.08%</strong>,不过因为交易过程中总是在追涨杀跌，所以10月底开始就将所有的钱都拿去买基金了，后面段时间内应该也不会参与股票交易了。</p>
<p><strong>基金</strong></p>
<p>11、12两个月的收益率是 <strong>6%</strong> ，这还是在没有没有年中的大涨的基础上，所以如果从年头持有到年尾，40%的收益还是有希望的。</p>
<h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p>今年因为没咋读书的原因所以读书笔记写的比较少，主要是写了一个MySQL和一个Redis原理解读系列，后续会放到博客上。</p>
<p>目前写作的总体思路还是 总-分-总 围绕着思维导图进行阐述。</p>
<h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>今年由于有很大一部分时间在和女朋友一起调整我们的作息，所以看的书少了点。以下是我的评分和简介：</p>
<ul>
<li><a href="https://book.douban.com/subject/10786473/">《自控力》</a>【9分】当你理解了自控的结构之后，再去看那些为什么失控的例子，你会发现都是自控的某个环节出现了问题导致的。</li>
<li><a href="https://book.douban.com/subject/30144978/">《见识》</a>【6分】最受用的两点是，一是集中力量办大事，针对你最想得到的“做减法”，二是工作中要有“大局意识”，否则一辈子只能耕耘一亩三分地。当书籍出版变成固定动作，内容就可能被膨胀了，质量就可能被缩水了。</li>
<li><a href="https://book.douban.com/subject/27199584/">《大学之路》</a>【7分】主要透过这本书了解了一下通才教育和专才教育两种教育理念。</li>
<li><a href="https://book.douban.com/subject/25900156/">《Redis 的设计与实现》</a>【10分】Redis原理学习必读书籍。</li>
</ul>
<h2 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h2><p>年中的时候立下了“不胖20斤不换头像”的目标</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/20210105083308.png"></p>
<p>然后就到现在一直没有换头像…</p>
<p>下半年因为各种原因没有坚持健身，现在副作用已经体现出来了，身体虚弱、抵抗力下降、积极性减弱等等，后面健身还是要继续坚持的，这几天计划先从每天坚持跑步开始做起。</p>
<h2 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h2><p>这一年虽然有疫情，可去的地方也挺多的，下面是这一年去过的地方：</p>
<ul>
<li>桂林</li>
<li>广州</li>
<li>深圳</li>
<li>上海</li>
<li>苏州-周庄古镇</li>
<li>广东-南澳岛</li>
</ul>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>生活方面最大的收获就是遇到了我现在的女朋友，很开心遇到了一个可以相互包容，一起成长的人，当然，两个人生活当中难免有些磕磕碰碰，我们也在不断磨合的过程中，相信新的一年我们会变得更加的有默契。</p>
<h2 id="20年回顾"><a href="#20年回顾" class="headerlink" title="20年回顾"></a>20年回顾</h2><p>看了一下去年的20年目标，很遗憾，好像两个目标都没有做到…</p>
<ul>
<li>读书：去年计划将技术类书籍占比提升上来，今年占比是 25% ，不过总量下来了…所以算是失败了吧。</li>
<li>健身：去年希望可以把健身这件事坚持下去，很可惜的是坚持了半年，后半年没有坚持住。</li>
</ul>
<h2 id="21年目标"><a href="#21年目标" class="headerlink" title="21年目标"></a>21年目标</h2><ul>
<li>技术-工作：提高一下收入，目标 <strong>年薪 50w</strong>。</li>
<li>技术-学习：从项目经验、技术原理、基础知识等三个角度去点亮自己的技术地图，坚持 <a href="https://leetcode-cn.com/progress/">每天刷一道 LeetCode 上的题目</a>。</li>
<li>投资：继续坚持基金定投，目标 <strong>年化收益达到30%</strong> 。</li>
<li>写作：以技术为主线 <strong>坚持每周发表一篇文章</strong>。</li>
<li>读书：读书还是要坚持下去的，<strong>坚持每周读一本书</strong>。</li>
<li>健身：身体才是一切的基础，没有一个好身体一切都是空谈，<strong>每周练三次，每次一个小时</strong>。</li>
<li>旅行：旅行是最好的放松方式，目标 <strong>去3个自己没去过的城市</strong>。</li>
</ul>
<h2 id="个人Milestone"><a href="#个人Milestone" class="headerlink" title="个人Milestone"></a>个人Milestone</h2><p>今年的个人Milestone肯定就是找到了一个彼此相爱的女朋友了，在这里也要感谢我的女朋友对我的包容，给我成长和自己完善的空间，我也有信心和女朋友一起打造一个幸福的家庭。</p>
]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 年终总结</title>
    <url>/2022/01/06/summary/2021%20%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>2021年工作上最大的变化就是年初换了工作，从待了两年半的上家公司离开了，来了快手。</p>
<h3 id="跳槽快手"><a href="#跳槽快手" class="headerlink" title="跳槽快手"></a>跳槽快手</h3><p>年初的时候面了很多家公司，最后接了快手的offer。</p>
<p>先说说为什么要换工作，主要有两点考虑：</p>
<ol>
<li>为了薪资，适当跳槽可以拿到更客观的薪资。</li>
<li>工作上遇到了瓶颈，党哥之前一直要求在稳定性上做更多的工作。但是一直没有懂怎么做。所以想换一个环境去学习。</li>
</ol>
<p>面试后总结，写的文章：</p>
<ul>
<li><a href="https://blog.haxianhe.com/2021/02/27/CS-Interview/social-interview/">涨薪50%，从小厂逆袭快手 - 附面经</a></li>
<li><a href="https://blog.haxianhe.com/2021/03/04/CS-Interview/how-to-ready-interview/">从小厂逆袭快手，我是如何准备面试的</a></li>
<li><a href="https://blog.haxianhe.com/2021/04/21/CS-Interview/from_php2java/">从小厂逆袭快手，我是如何从PHP转Java的</a></li>
</ul>
<h3 id="转正"><a href="#转正" class="headerlink" title="转正"></a>转正</h3><p>转正前自己压力非常大，因为当时正在降本增效，很担心自己被裁掉…还好最后还是过了。</p>
<h3 id="职业化"><a href="#职业化" class="headerlink" title="职业化"></a>职业化</h3><p>但是，转正后第一次沟通绩效也遇到了之前在顺丰时的问题：“1.技术能力有待加强。2.做事情需要更仔细，考虑更周到，简单来说就是最高标准。3.就是对外沟通方面做的比较好。”。</p>
<p>事后，结合自己换工作以来的一些思考以及学习的课程，知道了自己面对的问题——职业化。</p>
<p>职业化，被最大程度误解的一个词，职业化意味着你从原来的父子模式（你给我钱，给我空间，我去成长）、师生模式（你是老师，我是学生，你教我，我学）到交易模式（我出卖我的智力、体力、能力，你给我报酬）的转变。</p>
<p>对事：</p>
<ul>
<li>能不能在一张A4纸上把业务工作流程画出来，能不能把业务对接的上、下游流程画出来</li>
<li>明确你是来解决什么问题的，然后把它解决好（技术、需求、线上稳定性）<br>对人：</li>
<li>每周请一个新的人吃饭，弱关系</li>
</ul>
<h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>21年读书没有达成目标，这一年只看了《原则》《被讨厌的勇气》这两本书，今年上半年主要在忙着换工作，适应新的工作环境，下半年主要在忙着转正的事，此外这一年也挺折腾的，作息也不是很规律，22年还是要调整回原来的状态的✊。</p>
<p>21年的读书笔记</p>
<ul>
<li><a href="https://blog.haxianhe.com/2021/09/08/Book-Notes-Self/%E5%8E%9F%E5%88%99/">以史为鉴 - 读《原则》</a></li>
<li><a href="https://blog.haxianhe.com/2021/10/26/Book-Notes-Psycholog/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94/">人是可以改变的-读《被讨厌的勇气》</a></li>
</ul>
<h2 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h2><p>健身也没有完成目标，21年一方面调整一下设置目标的方式，另一方面降低一下目标阈值，先保证目标具有可完成性。</p>
<h2 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h2><p>21年旅行目标几乎完成（有两座城市不是第一次去…）</p>
<p>21年去过的城市：</p>
<ul>
<li>广州 </li>
<li>青岛</li>
<li>长沙</li>
<li>杭州</li>
<li>重庆</li>
</ul>
<h2 id="理财"><a href="#理财" class="headerlink" title="理财"></a>理财</h2><p>21年年初又一波大的亏损，亏了几万块钱。后面投资策略就彻底放弃了哪些乱七八糟的技巧了。</p>
<p>目前主要投资有两个：</p>
<ol>
<li>我要稳稳的幸福定投，有闲钱全部投到这个上。</li>
<li>指数基金，主要投资标的：沪深300、中证500、中证红利、上证50、深证100、创业板50、兴全合润、富国天惠、恒生ETF、恒生科技、标普500、纳斯达克100、中概互联。</li>
</ol>
<h2 id="21年目标回顾"><a href="#21年目标回顾" class="headerlink" title="21年目标回顾"></a>21年目标回顾</h2><ul>
<li>技术-学习：从项目经验、技术原理、基础知识等三个角度去点亮自己的技术地图，坚持 <a href="https://leetcode-cn.com/progress/">每天刷一道 LeetCode 上的题目</a>。<ul>
<li>没完成，差的太多。</li>
</ul>
</li>
<li>投资：继续坚持基金定投，目标 <strong>年化收益达到30%</strong> 。<ul>
<li>没完成，差的太多。</li>
</ul>
</li>
<li>写作：以技术为主线 <strong>坚持每周发表一篇文章</strong>。<ul>
<li>没完成，差的太多。</li>
</ul>
</li>
<li>读书：读书还是要坚持下去的，<strong>坚持每周读一本书</strong>。<ul>
<li>没完成，差的太多</li>
</ul>
</li>
<li>健身：身体才是一切的基础，没有一个好身体一切都是空谈，<strong>每周练三次，每次一个小时</strong>。<ul>
<li>没完成，差的太多。</li>
</ul>
</li>
<li>旅行：旅行是最好的放松方式，目标 <strong>去3个自己没去过的城市</strong>。<ul>
<li>基本完成。</li>
</ul>
</li>
</ul>
<h2 id="22年目标"><a href="#22年目标" class="headerlink" title="22年目标"></a>22年目标</h2><ul>
<li>读书24本</li>
<li>健身96次</li>
<li>旅行去2个没去过的省份</li>
<li>理财<ul>
<li>定投账户 - 年化5%</li>
<li>100份账户 - 不亏钱</li>
</ul>
</li>
<li>考研</li>
<li>写作24篇</li>
</ul>
<h2 id="个人-Milestone"><a href="#个人-Milestone" class="headerlink" title="个人 Milestone"></a>个人 Milestone</h2><ul>
<li>跳槽快手</li>
</ul>
]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2022 年终总结</title>
    <url>/2023/01/05/summary/2022%20%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>时间过的真快，一晃一年又过去了，2022年发生了太多太多值得铭记的事，比如今年成功晋升了，比如今年失恋了而且很狼狈，比如防控了三年的疫情突然放开了，比如一个人来到厦门来了场潇潇洒洒的旅行。</p>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>今年工作总的来说是“稳中有进”：</p>
<ul>
<li>年初晋升成功。</li>
<li>年中接手了权益、账单系统。</li>
</ul>
<p>目前工作上的瓶颈在于技术不够扎实，这是硬伤，也是明年的主攻点。</p>
<h3 id="晋升"><a href="#晋升" class="headerlink" title="晋升"></a>晋升</h3><p>晋升和面试有很多想通之处，比如都有迹可循，需要提前认真准备材料，反复练习等等。一句话总结就是：“唯用心尔”。</p>
<p>但是两者也有一定的区别。</p>
<p>晋升因为评审的都是团队内部的，或者公司内部的，多多少少对你做的业务有一定的了解，相对来说问的问题会更偏业务，以业务为主，以技术为辅。</p>
<p>而面试，因为面试官对你并不了解，提问的问题也主要围绕着你的简历来的，相对来说更好引导，问的问题更多的是以业务为引，以技术为主。</p>
<h3 id="权益、账单系统"><a href="#权益、账单系统" class="headerlink" title="权益、账单系统"></a>权益、账单系统</h3><p>之前一直懵懵懂懂的，最近开始把自己来了这边的团队之后做的事情梳理了一下，也逐渐抓住了一些重点。</p>
<p>总结了一下目前主R的业务：</p>
<ul>
<li>流水统计、充值、权益</li>
<li>我的钱包</li>
<li>账单系统</li>
</ul>
<p>梳理完会更有工作重心，有“负责”的感觉，也有助于在自己负责的业务上做深耕细作，做更多的建设性工作。</p>
<h2 id="爱好"><a href="#爱好" class="headerlink" title="爱好"></a>爱好</h2><h3 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h3><p>今年读了9本书：</p>
<ul>
<li>《潜规则》</li>
<li>《血酬定律》</li>
<li>《支付平台架构》</li>
<li><a href="https://blog.haxianhe.com/2022/08/10/book-notes-psycholog/%E7%9B%94%E7%94%B2%E9%AA%91%E5%A3%AB/">《为自己出征·盔甲骑士》</a></li>
<li><a href="https://blog.haxianhe.com/2022/08/21/book-notes-psycholog/%E5%BD%93%E4%B8%8B%E7%9A%84%E5%8A%9B%E9%87%8F/">《当下的力量》</a></li>
<li>《毛泽东选集（卷一）》</li>
<li><a href="https://blog.haxianhe.com/2022/10/15/book-notes-economic/%E5%85%B7%E4%BD%93%E6%83%85%E5%86%B5%E5%85%B7%E4%BD%93%E5%88%86%E6%9E%90-%E8%AF%BB%E3%80%8A%E5%A4%A7%E8%B4%A5%E5%B1%80%E3%80%8B/">《大败局 I》</a></li>
<li>《洞穴奇案》</li>
<li>《阅读的方法》</li>
</ul>
<p>最喜欢的书是《为自己出征》和《毛泽东选集》，前者让我能更好的去调整自己心里的状态，去直面自己的内心，试着去了解自己、去爱自己。后者开阔了我的视野，打开了我的格局，受限于眼界实在不知道该怎么写这本书的读书笔记，等后面N刷的时候、真的读懂了再写吧，要不是对这本书的一种亵渎。</p>
<h3 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h3><p>健身总的来说不达标：</p>
<ul>
<li>有记录的健身次数有12次（开始用训记以后）</li>
<li>找教练带着练了两次</li>
</ul>
<p>不过做的好的是在入冬之前很长一段时间每天早上都坚持晨跑，后面年后天气回到零上以后还会继续坚持。</p>
<h3 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h3><p>今年进行了三次旅行：</p>
<ul>
<li><a href="https://blog.haxianhe.com/2022/07/23/travel-notes/%E5%9C%86%E6%A2%A6%E8%8D%89%E5%8E%9F/">《内蒙古》</a></li>
<li><a href="https://blog.haxianhe.com/2022/08/05/travel-notes/%E7%9C%BA%E6%9C%9B%E5%A4%A7%E6%B5%B7/">《大连》</a></li>
<li>《厦门跨年》</li>
</ul>
<p>这三次旅行都超级超级开心！其中内蒙古和厦门我都是第一次去，内蒙古是同事自驾，一路超开心。厦门是一个人来跨年的，也超级潇洒。</p>
<h2 id="22-年目标回顾"><a href="#22-年目标回顾" class="headerlink" title="22 年目标回顾"></a>22 年目标回顾</h2><ul>
<li>读书24本<ul>
<li>这个没完成，读书习惯还有待加强，23年重点去做，目标值适当调低。</li>
</ul>
</li>
<li>健身96次<ul>
<li>统计数据不完全，大概率没完成，23年把目标调低。</li>
</ul>
</li>
<li>旅行去2个没去过的省份<ul>
<li>目标达成。目标值订的适中。</li>
</ul>
</li>
<li>考研<ul>
<li>没完成，彻底放弃考研的想法了。</li>
</ul>
</li>
<li>写作24篇<ul>
<li>没完成，只写了9篇，23年不再单独计划。</li>
</ul>
</li>
</ul>
<h2 id="23-年目标"><a href="#23-年目标" class="headerlink" title="23 年目标"></a>23 年目标</h2><ul>
<li>工作<ul>
<li>晋升成功</li>
<li>程序员练级攻略</li>
<li>leetcode</li>
</ul>
</li>
<li>爱好<ul>
<li>读书（写作）12本</li>
<li>健身（美食）52次</li>
<li>旅行（摄影）2个没去过的地方</li>
</ul>
</li>
</ul>
<h2 id="个人Milestone"><a href="#个人Milestone" class="headerlink" title="个人Milestone"></a>个人Milestone</h2><ul>
<li>恢复单身，重新去学习爱自己</li>
<li>放弃幻想，专注技术</li>
</ul>
]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>保险配置总结</title>
    <url>/2021/01/21/think/%E4%BF%9D%E9%99%A9%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="我的保险配置"><a href="#我的保险配置" class="headerlink" title="我的保险配置"></a>我的保险配置</h2><p>医保+(补充医疗险+好医保·长期医疗险)+(相互保+重疾险)</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/20210121073447.png"></p>
<p><strong>情况1:日常门诊看病</strong></p>
<p>报销型：医保+团体补充医疗险 2万以内100%报销</p>
<p><strong>情况2:住院手术</strong></p>
<p>报销型：医保+好医保·长期医疗险 200万以内100%报销</p>
<p><strong>情况3:重症疾病</strong></p>
<p>报销型：医保+好医保·长期医疗险 400万以内100%报销</p>
<p>给付型：相互保+重疾险 满足条件疾病给付30万+50万</p>
<h2 id="亲人保险建议"><a href="#亲人保险建议" class="headerlink" title="亲人保险建议"></a>亲人保险建议</h2><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20210121073805.png"></p>
<p><strong>情况1:日常门诊看病</strong></p>
<p>报销型：医保+<del>团体补充医疗险</del> 一般都不够起付线</p>
<p><strong>情况2:住院手术</strong></p>
<p>报销型：医保+好医保·长期医疗险 200万以内100%报销</p>
<p><strong>情况3:重症疾病</strong></p>
<p>报销型：医保+好医保·长期医疗险 400万以内100%报销</p>
<p>给付型：相互保+<del>重疾险</del> 满足条件疾病给付30万+<del>50万</del></p>
<h2 id="保险介绍"><a href="#保险介绍" class="headerlink" title="保险介绍"></a>保险介绍</h2><h3 id="医保"><a href="#医保" class="headerlink" title="医保"></a>医保</h3><p>中国公民基本医疗福利，每个人必须有</p>
<p><strong>特点：有起付线，门诊、住院报销金额有上限</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>门诊起付线</th>
<th>门诊报销上限</th>
<th>住院起付线</th>
<th>住院报销上限</th>
</tr>
</thead>
<tbody><tr>
<td>职工医保</td>
<td>1800</td>
<td>2万</td>
<td>1300</td>
<td>30万</td>
</tr>
<tr>
<td>新农合</td>
<td>-</td>
<td>5000</td>
<td>-</td>
<td>1.1万</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/6F84D5B5-F236-4AE2-9A81-9AC256B9F5C2.png"></p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/20210121074756.png"></p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/20210121074913.png"></p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/20210121075447.png"></p>
<h3 id="团体补充医疗险"><a href="#团体补充医疗险" class="headerlink" title="团体补充医疗险"></a>团体补充医疗险</h3><p>特点：企业团体险，个人不知道怎么买，可以报销门诊没有达到医保起付线部分，以及起付线以上医保不报部分</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/B655CFA7-A3F8-45B9-AF83-842358540EC9.png"></p>
<h3 id="好医保·长期医疗险"><a href="#好医保·长期医疗险" class="headerlink" title="好医保·长期医疗险"></a>好医保·长期医疗险</h3><p>特点：报销型，可以在支付宝上买，60周岁以下可以投保，按年续费，年龄大交的钱会多一点，可以报销住院费医保不报的部分，6年内共计1万免赔额，普通疾病上限200万，重症上限400万，需要保证自己符合投保条件否组理赔的时候会被拒赔</p>
<h3 id="相互保（给付型）"><a href="#相互保（给付型）" class="headerlink" title="相互保（给付型）"></a>相互保（给付型）</h3><p>特点：给付型，可以在支付宝上买，每月1元左右，患有清单上的疾病一次性给付30万（49周岁以前，49周岁到59周岁是10万），需要保证自己符合投保条件否组理赔的时候会被拒赔</p>
<h3 id="重疾险（给付两全型）"><a href="#重疾险（给付两全型）" class="headerlink" title="重疾险（给付两全型）"></a>重疾险（给付两全型）</h3><p>特点：保到65周岁（过程赔付或到期一次返现），年龄大了没有必要买</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>保险名称</th>
<th>保险类型</th>
<th>购买条件</th>
<th>购买途径</th>
</tr>
</thead>
<tbody><tr>
<td>职工医保</td>
<td>报销型</td>
<td>无</td>
<td>社保</td>
</tr>
<tr>
<td>新农合</td>
<td>报销型</td>
<td>无</td>
<td>新农合</td>
</tr>
<tr>
<td>团体补充医疗险</td>
<td>报销型</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>好医保·长期医疗险</td>
<td>报销型</td>
<td>60周岁以下，无既往病史</td>
<td>支付宝</td>
</tr>
<tr>
<td>相互保</td>
<td>给付型</td>
<td>无既往病史，两年内连续服药超过30天或者连续住院超过15天</td>
<td>支付宝</td>
</tr>
<tr>
<td>重疾险</td>
<td>给付型</td>
<td>略</td>
<td>略</td>
</tr>
</tbody></table>
<p>注意：购买好医保·长期医疗险和相互保之前，<strong>确认一下自己是否符合相应的投保条件（重点看一下免责条件&#x2F;健康要求）</strong>，这种产品都是<strong>“宽进严出”</strong>，不符合投保条件没人会告诉你，但是你理赔的时候就会给你拒赔，需要你<strong>自己对自己负责</strong>。</p>
]]></content>
      <categories>
        <category>认知到位</category>
      </categories>
      <tags>
        <tag>认知到位</tag>
      </tags>
  </entry>
  <entry>
    <title>回首往事，初心何在</title>
    <url>/2019/03/15/think/%E5%9B%9E%E9%A6%96%E5%BE%80%E4%BA%8B%EF%BC%8C%E5%88%9D%E5%BF%83%E4%BD%95%E5%9C%A8/</url>
    <content><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>今天在<em>极客时间</em>上看到了一篇文章，文章中作者讲述了他与程序员这个职业的缘起何方，读完文章之后我顺着作者的思路走了一遍我与程序员这个职业之间的缘分。</p>
<p>在这里简单记录一下。</p>
<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>我想了一下，我第一次接触计算机应该是在我小学五年级的计算机课上，我记得当时每次上课前要穿鞋套，课上学的是画图？大概是的。完成任务之后大家会偷偷玩玩扫雷，纸牌什么的。</p>
<p>当时的我从没想过，未来有一天我会和计算机结下不解之缘，甚至全赖计算机得以有口饭吃。</p>
<p>说来可笑，我五年级在的学校是一个村级小学。我六年级在的学校是县城里的一个小学，初中，高中也都是在县城里的学校读的。但就是这么一个村级小学一周会有一节计算机课程，可是后面条件更好的县城里的小学、初中、高中，竟然不安排计算机课程（也有可能是我忘了）。</p>
<p>仔细想想，何其可笑！</p>
<p>除了成绩，什么都不重要！！</p>
<p>这就是中国式教育（虽然我是这种体制下的既得利益者，因为没有这种模式，我也不可能从那个偏远的地方走出来，但是我还是要讽刺这种模式，因为它存在很大的问题！）</p>
<p>这就是我和计算机第一次接触，可以说，平淡的不能再平淡，彷佛身处两个不同的纬度一样。</p>
<h2 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h2><p>更多一点的接触应该发生在初中三年的过程中（高中除了学习，对任何事情都失去了兴趣）。</p>
<p>我初中开始住校，刚入学不久我的一个室友&#x2F;同学（这位同学在我初中三年的生活中起到了关键作用）带我去了网吧，我到现在都能记得那个网吧的大概位置（虽然它早就关门好多年了），从此我的世界被打开了一扇新的大门，CS、QQ飞车、地下城与勇士（练过好多号，最喜欢的还是鬼泣吧）、穿越火线…</p>
<p>这些游戏让我不可自拔，无数个夜晚翻墙而出，直奔网吧（我到现在都放佛能感受得到当时紧张的心砰砰直跳的感觉）。</p>
<p>最巅峰的成就是一次在一个冬天，东北的冬天，从寝室楼5楼，徒手（没有任务安全措施），从梯子（能爬上楼顶的那个梯子）往下爬，手握在铁上（刺骨一般的凉，但是死命的握住不敢松手），一直爬到了二楼，此时距离围墙大概隔了4，5个窗户那么远，于是脚踩着电线，手抓着楼的边缘多出来的那一点点，向着围墙移动了过去，最终跳墙出了学校。</p>
<p>以上就是我和计算机的第二次接触，用一个词可以概述，那就是“堕落”。</p>
<h2 id="缘分"><a href="#缘分" class="headerlink" title="缘分"></a>缘分</h2><p>在经历了初中三年的“堕落”生活之后，中考成功的没考上高中，幸运的是我妈给我拿了钱，让我上了高中。</p>
<p>更幸运的是高中遇到了几个很棒的室友（这三个市里来的家伙这的很棒，十分感谢他们），每天比着学习（没有什么比学习更能带给人成就感的了）。</p>
<p>更更幸运的是高考有点超常发挥，真是应了那句“考的全会，蒙的全对”。</p>
<p>平时100名到200之间的我，高考考了自己三年最好的成绩——大榜61名（622分）。</p>
<p>受限于原生家庭的影响，高考结束的我对未来没有任何想法，对于喜欢什么，不喜欢什么更是一无所知。给大家说个笑话，当时我从新闻里知道雾霾很严重，所以报考的时候，我天真的以为学”环境工程“以后一定很有前途——总得需要人去治理环境呀！写这段话的时候，我看着北京窗外的蓝天白云，默默的在心里想，幸好我当时报的“环境工程”没录取上…</p>
<p>高考第一志愿是大连理工大学，第二志愿是华北电力大学（保定），第三志愿是湖南大学，第四志愿是苏州大学，第五志愿是…记不得了。最终我被华电录取了，然后被调剂到了计算机系&#x2F;软件工程专业。</p>
<p>从此，我和计算机结下了注定一生都解不开的缘分。</p>
<p><strong>初心的种子已经种下。</strong></p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>整个大一上半年，在经历了初入学的兴奋之后，我开始迷茫了，我实在不知道路在何方。</p>
<p>在当时的我心理 <em>计算机&#x2F;软件工程 ～ C++</em> ，我实在不知道它有什么用。</p>
<p>我从来不否认理论对于计算机这门学科的重要性，但我还是想吐槽一下，计算机这个专业就注定了它是一门实践性很强的专业，没有实践，一开始就从理着手，在我这种平凡的人眼中，无异于“空中楼阁”——不现实&#x2F;没意义，自然也就学不进去。</p>
<p>直到…我遇到了组长，直到…我遇到了Dre@mtech工作组…直到我拿到了我师父给我的那份《牛腩新闻发布系统》教程。</p>
<p>不得不说做这个网站的过程中带给我了过去18年从来不曾体验过的感觉，那就是——成就感（创造感）。</p>
<p>我觉得自己是在进行创造，在从无到有的去创造一个东西，这个过程是那么的伟大，那么的不可思议。</p>
<p>直到这一刻，属于我的“初心”于一夜之间完成了，破土、成长、开花、结果的全过程。</p>
<p><strong>我想用我的智慧&#x2F;努力给别人带来些许改变，</strong></p>
<p><strong>我想世界因为我的存在而不同。</strong></p>
<p><strong>我想这就是我的初心——创造&#x2F;求知欲。</strong></p>
<h2 id="蒙尘"><a href="#蒙尘" class="headerlink" title="蒙尘"></a>蒙尘</h2><p>再后来我进入了工作组，我参与了项目，我带了项目，我会的技术越来越多，我懂得理论越来越多，我用过的工具越来越多，我越来越不知道自己想要什么了…</p>
<p>我每天兜兜转转，我学了一门又一门的课程，我学会了一门又一门的技术，我做了一个又一个的项目，我带了一个又一个的徒弟，我…到底在做什么，到底想要什么…</p>
<p>大三下学期当比人都在上课的时候，我跑到了杭州去实习。</p>
<p>从杭州实习回来之后我更迷茫了，我不知道路在何方，既然如此考研吧！</p>
<p>于是踏上了漫漫考研路…</p>
<p>其实，该有的迷茫一分未少，只不过我不去想了而已，只不过我选择了堵上了自己的耳朵而已…</p>
<p>再之后考研失败，也好，反正我感觉出来了，读研并不适合我…</p>
<p>于是，我又踏上了找工作之路…</p>
<p>不得不说，运气不错，拿到了几个很棒的offer，最终也来了一家自己很喜欢的公司，学到了很多很专业的技术。我有了长足的进步，值得庆幸。</p>
<p>可是初心早已不在，连影子都看不到了，计算机于我来说只是一份糊口的工作，和任何一份工作，没有什么不同，顶多它需要不断的保持学习而已。</p>
<p>那么，我的初心呢？我将它丢在了哪里？？</p>
<p>也许，早在2015年我大一下学期进组的那一刻就丢了吧。</p>
<p><strong>这四年是初心蒙尘的四年。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不得不说，想清楚这个问题，让我觉得自己的灵魂都轻松了很多。</p>
<p>不忘初心，方得始终。</p>
<p>可是要是初心早已不在，谈何不忘！</p>
<p>祝愿大家早日找回自己的初心</p>
]]></content>
      <categories>
        <category>认知到位</category>
      </categories>
      <tags>
        <tag>认知到位</tag>
      </tags>
  </entry>
  <entry>
    <title>如何做一个有质量的技术分享</title>
    <url>/2021/09/03/think/%E5%A6%82%E4%BD%95%E5%81%9A%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B4%A8%E9%87%8F%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://coolshell.cn/articles/21589.html">https://coolshell.cn/articles/21589.html</a></p>
</blockquote>
<p>分享信息并不难，大多数人都能做到，就算是不善言谈性格内向的技术人员，通过博客或社交媒体，或是不正式的交流，他们都能或多或少的做到。但是如果你想要做一个有质量有高度的分享，这个就难了，所谓的有质量和有高度，我心里面的定义有两点：</p>
<ol>
<li>分享内容的保鲜期是很长的，</li>
<li>会被大范围的传递。</li>
</ol>
<p>我们团队内每周都在做技术分享，虽然分享的主题都很有价值，但是分享的质量参差不齐，所以，想写下这篇文章 。供大家参考。</p>
<p>首先，我们先扪心自问一下，我们自己觉得读到的好的技术文章是什么？我不知道大家的是什么，我个人认为的好的文章是下面这样的：</p>
<ul>
<li><p><strong>把复杂的问题讲解的很简单也很清楚</strong>。比如我高中时期读到这本1978年出版的《<a href="https://book.douban.com/subject/1441922/">从一到无穷大</a>》，用各种简单通俗通懂的话把各种复杂的科学知识讲的清清楚楚。还有看过的几本很好的书，有一本是《<a href="https://book.douban.com/subject/5273955/">Windows程序设计</a>》，从一个hello world的程序开始一步一步教你Windows下的原生态编程。</p>
</li>
<li><p><strong>有各种各样的推导和方案的比较，让你知其然知其所以然</strong>。有了不同方案的比较，才可能让人有全面的认识。这个方面的经典作著是《<a href="https://book.douban.com/subject/5387403/">Effective C++</a>》。</p>
</li>
<li><p><strong>原理、为什么、思路、方法论会让人一通百通</strong>。这里面最经典的恐怕就是《<a href="https://book.douban.com/subject/5387403/">十万个为什么</a>》了，在计算机方面也有几本经典书，有《<a href="https://book.douban.com/subject/1467587/">Unix编程艺术</a>》、《<a href="https://book.douban.com/subject/1052241/">设计模式</a>》、《<a href="https://book.douban.com/subject/1230413/">深入理解计算机系统</a>》等书，以及《<a href="http://www.kegel.com/c10k.html">The C10K Problem</a>》等很多技术论文。</p>
</li>
</ul>
<p>其实，从教科书，到专业书，再到论文，都有上面这些不错的特质。</p>
<p>所以，如果你想做一个好的技术分享的话，下面是我总结出来的方法，供你参考。</p>
<ul>
<li><strong>先描述好一个问题</strong>。这样能够听众带入进来，如果这个问题是他们感同身受的，那是最好了。千万不要一上来就说What，或是直接冲进答案里。这样的分享是在灌输和填鸭。把Why说清楚。没有Why，直接谈What的技术分享，通常来说价值不大。</li>
<li><strong>How比What重要</strong>。在讲How的时候，也就是如何解这个问题。<br>先要把问题模型说清楚，有了问题模型这个框框后，方案才有意义。<br>然后要有不同技术的比较。有了比较后，听众才会更相信你。<br>直接上What的技术细节，其实没有太大意义。</li>
<li><strong>一定要有Best Practice或方法论总结</strong>，否则上不了档次的。也就是分享中大家可以得到的重要收获。</li>
</ul>
<p>说明了这个模型就是：<strong>问题 –&gt; 方案 –&gt; 总结</strong>。这其中是有一定的心理学模型的，具体表现如下：</p>
<ul>
<li>用问题来吸引受众，带着受众来一起思考</li>
<li>用问题模型来框住受众的思考范围，让受众聚焦</li>
<li>给出几种不同的解决方案，比较他们的优缺点，让受众有一种解决问题的参与感。</li>
<li>最后，给出最佳实践，方法论或套路，因为有了前三步的铺垫，受众欣然接受。</li>
<li>整个过程会让受众有强烈的成长感和收获感。</li>
</ul>
]]></content>
      <categories>
        <category>认知到位</category>
      </categories>
      <tags>
        <tag>认知到位</tag>
      </tags>
  </entry>
  <entry>
    <title>痛证明你在蜕变！</title>
    <url>/2019/06/17/think/%E7%97%9B%E8%AF%81%E6%98%8E%E4%BD%A0%E5%9C%A8%E8%9C%95%E5%8F%98%EF%BC%81/</url>
    <content><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>最近半年以来状态一直不是很好，没有了往日的那份阳光，因为总是在牵挂一个人，如今这份牵挂随风而去，我也可以重新做回自己。</p>
<p>分手之后曾一度崩溃，抽过烟喝过酒。但是一切终究已经过去，是时候整理整理心情重新上路，毕竟路还是要走下去不是吗。</p>
<p>今天状态好一些了，整理整理自己的心路历程。</p>
<h2 id="遇见"><a href="#遇见" class="headerlink" title="遇见"></a>遇见</h2><p>我和xw第一次见面是在17年10月份，当时组里招新，因为名字从而对这个人有一份格外的好感，后来带她的是yd。当时组里有一个那一届的招新大群，从那里面的加的QQ，不过加了之后也没有联系太多。</p>
<p>再后来的一次联系就是考研期间，有一天因为她的一个朋友圈还是什么的，聊了几句。</p>
<h2 id="相爱"><a href="#相爱" class="headerlink" title="相爱"></a>相爱</h2><p>18年3月份我找好工作之后，先是想把自己的书给别人，不知道为什么就想到她了，就问了她要不要，后来她来我们宿舍楼下取书。</p>
<p>后来那期间又陆陆续续联系过几次。</p>
<p>因为她要保研，所以我帮她和cd说了一声，让cd给她讲讲。可能因为聊完心里压力有点大，她走的时候心情感觉不是很好，所以我回寝室之后又关心了一下，结果发现她竟然哭了，然后我就安慰了安慰她。</p>
<p>后来因为在一起聊的多了，渐渐发现两个挺聊的来的，而且我也挺喜欢她那种要强的性格的。所以后来18年3月22那天就在一起了。</p>
<p>再后来我就去了北京实习，我实习的这段时间我俩经常聊天，因为还处于热恋期嘛，所以真的很幸福。期间她经常会送我一些小礼物，她也确实很聪明，知道我需要什么。每次送我的东西，都是我特别喜欢而且还实用的。还给我做过手链，现在想起来依然很幸福！</p>
<p>18年5月份我结束实习回到了学校。在学校的这段时间，我俩其实吵过几次，还挺生气的。后来她告诉我，其实有的时候生气的原因不重要，重要的是我要去哄她。不得不说这招我学会了，所以后面在一起，不过我对我错，我都能有一个很好的认错态度…</p>
<p>其实，在一起的这段时间是相互影响的，那段时间我其实想做点什么…不想每天腻在一起，但是xw又不想…所以也因为这个吵过几次。</p>
<p>一晃来到了6月初，我们一起去了苏州，前两天其实玩的挺开心的，后来因为一些原因，很生气的回来了…不得不说，其实我到现在都没搞懂，女生是大姨妈前心情不好还是大姨妈后心情不好…</p>
<p>我来关系最好的时候除了我实习的那段时间，应该就属我毕业后的7月到11月这期间了，这期间我俩偶尔虽然也会生气，但真的是心里想的都是彼此。</p>
<p>也是这期间，让我死心塌地的爱上了她，但是我想不到的是这是我俩最后的爱情。</p>
<h2 id="天真"><a href="#天真" class="headerlink" title="天真"></a>天真</h2><p>从进入18年12月开始，我就再也没见过她了…这期间我俩会聊天，也是从这个时候开始，她家里发生了一些不好的事情，导致她没有心情搭理我…然后就再也回不来了…</p>
<p>中间断断续续约过几个见面时间，后来也都推掉了。</p>
<p>因为我的状态其实一直处于去年11月份那种热恋状态，所以这期间其实我挺痛苦的，但是因为她要忙着保研，所以我一直告诉自己，她忙！！！多理解理解，等她忙完了就好了。</p>
<p>这中间也不是没人劝过我，忙也不至于连个见面时间，聊天的时间都没有…其实我也不是没想过，今天她能为了别的事情放弃我，明天呢？以后会不会因为别的事情同样放弃我？可是可能真的就是就是因为喜欢吧，所以我不愿意去面对这些，一心想等着她忙完。</p>
<p>这中间我曾数次蹦不住了，拼命的给她发消息，表达我的思念，甚至一度达到做梦都是她的地步！！</p>
<p>后来，6月初我觉得这样下去我会病的，于是我回了一趟学校，准备摊牌。但是当我真的回到学校，她出现在我的面前的时候，我知道我还是舍不得她，我拉着她在学校里走了一圈又一圈，说了自己所有的心里话。虽然她那天最后还是毅然的丢下了我，让我一个人去外面住，但是，当我第二天一个人离开的时候，我内心还是充满爱的。</p>
<p>回来以后，她也和我说原来她也没想到她会这么爱我！！！</p>
<p>一晃，端午结束了，不知道为什么，从端午结束开始，我每天都会梦到她，于是我没忍住，上周四（2019年6月13）我5点多醒了之后就一直给她发消息。她醒了之后，看到很生气！！！</p>
<p>就说了很多，中间她有说到，分手，我鬼使神差的说了一句“我看到你说分手，竟然有一种解脱的感觉”，后来又说了其他的话，挽回了。</p>
<p>到下午的时候，觉得早上可能气到她了，于是就主动发消息道歉，结果她忽然和我说让我读研吧，我一开始没太看懂，也没回这句，后来聊着聊着就聊到了不合适上面。于是我说，我给你打电话。然后我就给她打了电话，打电话之后她给我解释了她的想法。</p>
<p>想法大致如下：</p>
<ul>
<li>不知道为什么，想法变了。</li>
<li>她读研&#x2F;直博，我工作，走的不是一条路，以后没有共同话题。</li>
<li>继续在一起只能互相伤害。</li>
</ul>
<p>我同意了，其实我同意的原因只有一点，那就是<strong>我这半年的感觉是真的，她不是因为忙，而是因为不在乎我，所以不搭理我。</strong></p>
<p>说实话，当自己想法被证实的那一刻，真的很难受！</p>
<p>放下电话，我就后悔了，心里充满的无限的不舍，整个人很崩溃，浑浑噩噩。</p>
<p>所以我决定回学校尝试挽回。</p>
<p>我回公司拿上东西，踏上了返回学校的路上，在上火车前，我给她打了电话，她不让我回去，说不管我做什么都没用了，不要回去了，我没听，我心里的想法只有一个，我不能失去你！！！</p>
<p>我回到学校之后，按照之前的计划，和垚姐买了两箱酒做到她宿舍楼下开始喝（我想用这种方式告别我的青春），后来见到面了，见面聊了一会儿，但是她明确告诉我，我们不可能礼物，我不要白费力气了…后来她说她要早点回去了，她明天还要验收试验…当我听到这句，我彻底疯了，我这么爱的一个人，分手之后，此时此刻竟然只想着一个肯定能过的实验验收。我就想问，她到底是有多么的不在乎我！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</p>
<p>所以，我当时就抱住她不放手（当时就想气她），她很生气，无论如何让我放手，我也没放，我就那么静静地抱住她。后来她给她室友打电话，我看她心意已决我放开她了，在往回走的路上，真的很绝望，我就是想不通，为什么从始至终我们在乎你，那么包容你，你最后要这么对我。</p>
<p>于是，我疯狂的打自己，是的，你没有看错，是打自己！事后我分析自己的想法大概原因有二，一方面想气她，另一方面是我想让自己记住，记住这个让我伤心、绝望的场面并引以为戒！！</p>
<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>后来通过其他人了解过她的想法，她说本来还在意我，但是看到了那天我的表现之后，就彻底放下了。</p>
<p>其实，我后来也反思过，我那么做肯定是不对的，不理智，不成熟。但是，我想说的是，我那么做的原因是你后面的不在意我！！！</p>
<p>首先反思一下，在一起期间和最后分手的这种不成熟。有时候在过于情绪化了，做人，尤其是一个男人，拿得起放得下，这是最起码的，但是不得不说，这确实需要经历的洗礼。经历了这段感情，不得不承认我确实在感情上成长了很多。</p>
<p>再就是，什么是合适的两个人，这要分两点来聊。一方面呢，相互包容，相互理解是最基本的条件，包括性格，成熟度，三观等。另一方面刚在一起的人肯定都是相互理解、相互包容的，这个时候就需要时间去检验，你们是不是真的合适了。比如我的这段感情，明显就是在过了一段时间，遇到了事情，发现彼此不合适了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我相信在这段感情中，两个人都是真诚的，哪怕她后来的不想搭理我，我也相信就像她说的那样，是因为她不知道怎么面对我，她也不想改变自己的想法，可是想法就是变了，这是事实。</p>
<p>所以，无论男生，女生，不能太过于天真。人有的时候可能自己都不知道自己将来会怎么想。所以，海誓山盟固然美好，但是理智的去爱才对彼此更好。</p>
<p>当有一天你们经历了风风雨雨却依然站在一起，并且还想和她或他继续携手前行的时候，那才能说明你真的遇到了对的那个人。</p>
]]></content>
      <categories>
        <category>认知到位</category>
      </categories>
      <tags>
        <tag>认知到位</tag>
      </tags>
  </entry>
  <entry>
    <title>职业生涯实用经验</title>
    <url>/2020/06/18/think/%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E5%AE%9E%E7%94%A8%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="学会深入思考，总结沉淀"><a href="#学会深入思考，总结沉淀" class="headerlink" title="学会深入思考，总结沉淀"></a>学会深入思考，总结沉淀</h2><p>我想说的第一条就是要学会深入思考，总结沉淀，这是我觉得最重要也是最有意义的一件事。</p>
<p>先来说深入思考。在程序员这个圈子里，常能听到一些言论：我这个工作一点技术含量都没有，每天就CRUD，再写写if-else，这TM能让我学到什么东西？抛开一部分调侃和戏谑的论调不谈，这可能确实是一部分同学的真实想法，至少曾经的我，就这么认为过。后来随着工作经验的积累，加上和一些高level的同学交流探讨之后，我发现这个想法其实是非常错误的。</p>
<p>之所以出现没什么可学的这样的看法，基本上是思维懒惰的结果。任何一件看起来很不起眼的小事，只要进行深入思考，稍微纵向挖深或者横向拓宽一下，都是足以让人沉溺的知识海洋。</p>
<p>举一个例子。</p>
<p>某次有个同学跟我说，这周有个服务OOM了，查了一周发现有个地方defer写的有问题，改了几行代码上线修复了，周报都没法写。可能大家也遇到过这样的场景，还算是有一定的代表性。</p>
<p>其实就查bug这件事来说，是一个发现问题，排查问题，解决问题的过程，包含了触发、定位、复现、根因、修复、复盘等诸多步骤，花了一周来做这件事，一定有不断尝试与纠错的过程，这里面其实就有很多思考的空间。比如说定位，如何缩小范围的？走了哪些弯路？用了哪些分析工具？</p>
<p>比如说根因，可以研究的点起码有linux的OOM，k8s的OOM，go的内存管理，defer机制，函数闭包的原理等等。如果这些真的都不涉及，仍然花了一周时间做这件事，那复盘应该会有很多思考，提出来几十个WHY没问题吧…</p>
<p>再来说下总结沉淀。这个我觉得也是大多数程序员比较欠缺的地方，只顾埋头干活，可以把一件事做的很好。但是几乎从来不做抽象总结，以至于工作好几年了，所掌握的知识还是零星的几点，不成体系，不仅容易遗忘，而且造成自己视野比较窄，看问题比较局限。</p>
<p>适时地做一些总结沉淀是很重要的，这是一个从术到道的过程，会让自己看问题的角度更广，层次更高。遇到同类型的问题，可以按照总结好的方法论，系统化、层次化地推进和解决。</p>
<p>还是举一个例子。做后台服务，今天优化了1G内存，明天优化了50%的读写耗时，是不是可以做一下性能优化的总结？</p>
<p>比如说在应用层，可以管理服务对接的应用方，梳理他们访问的合理性；在架构层，可以做缓存、预处理、读写分离、异步、并行等等；在代码层，可以做的事情更多了，资源池化、对象复用、无锁化设计、大key拆分、延迟处理、编码压缩、gc调优还有各种语言相关的高性能实践…等下次再遇到需要性能优化的场景，一整套思路立马就能套用过来了，剩下的就是工具和实操的事儿了。</p>
<p>还有的同学说了，我就每天跟PM撕撕逼，做做需求，也不做性能优化啊。先不讨论是否可以搞性能优化，单就做业务需求来讲，也有可以总结的地方。比如说，如何做系统建设？系统核心能力，系统边界，系统瓶颈，服务分层拆分，服务治理这些问题有思考过吗？每天跟PM讨论需求，那作为技术同学该如何培养产品思维，引导产品走向，如何做到架构先行于业务，这些问题也是可以思考和总结的吧</p>
<p>就想一下，连接手维护别人烂代码这种蛋疼的事情，都能让Martin Fowler整出来一套重构理论，还显得那么高大上，我们确实也没啥必要对自己的工作妄自菲薄…</p>
<p>所以说学习和成长是一个自驱的过程，如果觉得没什么可学的，大概率并不是真的没什么可学的，而是因为自己太懒了，不仅是行动上太懒了，思维上也太懒了。</p>
<p><em><strong>可以多写技术文章，多分享，强迫自己去思考和总结，毕竟如果文章深度不够，大家也不好意思公开分享。</strong></em></p>
<h2 id="积极学习，保持技术热情"><a href="#积极学习，保持技术热情" class="headerlink" title="积极学习，保持技术热情"></a>积极学习，保持技术热情</h2><p><strong>最近两年在互联网圈里广泛传播的一种焦虑论叫做35岁程序员现象，大意是说程序员这个行业干到35岁就基本等着被裁员了。</strong> 不可否认，互联网行业在这一点上确实不如公务员等体制内职业。但是这个问题里35岁程序员并不是绝对生理意义上的35岁，应该是指那些工作十几年和工作两三年没什么太大区别的程序员。后面的工作基本是在吃老本，没有主动学习与充电，35岁和25岁差不多，而且没有了25岁时对学习成长的渴望，反而添了家庭生活的诸多琐事，薪资要求往往也较高，在企业看来这确实是没什么竞争力。</p>
<p>而如果我们积极学习，保持技术能力、知识储备与工作年限成正比，这到了35岁哪还有什么焦虑呢，这样的大牛我觉得应该也是各大公司抢着要吧？但是学习这件事，其实是一个反人类的过程，这就需要我们强迫自己跳出自己的安逸区，主动学习，保持技术热情。在滴滴时有一句话大概是，主动跳出自己的舒适区，感到挣扎与压力的时候，往往是黎明前的黑暗，那才是成长最快的时候。相反如果感觉自己每天都过得很安逸，工作只是在混时长，那可能真的是温水煮青蛙了。</p>
<p>刚毕业的这段时间，往往空闲时间还比较多，正是努力学习技术的好时候。借助这段时间夯实基础，培养出良好的学习习惯，保持积极的学习态度，应该是受益终身的。至于如何高效率学习，网上有很多大牛写这样的帖子，到了公司后内网也能找到很多这样的分享，我就不多谈了。</p>
<p><em><strong>可以加入学习小组和技术社区，公司内和公司外的都可以，关注前沿技术。</strong></em></p>
<h2 id="主动承担，及时交流反馈"><a href="#主动承担，及时交流反馈" class="headerlink" title="主动承担，及时交流反馈"></a>主动承担，及时交流反馈</h2><p>前两条还是从个人的角度出发来说的，希望大家可以提升个人能力，保持核心竞争力，但从公司角度来讲，公司招聘员工入职，最重要的是让员工创造出业务价值，为公司服务。</p>
<p>虽然对于校招生一般都会有一定的培养体系，但实际上公司确实没有帮助我们成长的义务。而在能为公司办成事，创造价值这一点上，我觉得最重要的两个字就是主动，主动承担任务，主动沟通交流，主动推动项目进展，主动协调资源，主动向上反馈，主动创造影响力等等。</p>
<p>我当初刚入职的时候，基本就是leader给分配什么任务就把本职工作做好，然后就干自己的事了，几乎从来不主动去跟别人交流或者主动去思考些能帮助项目发展的点子。自以为把本职工作保质保量完成就行了，后来发现这么做其实是非常不够的，这只是最基本的要求。</p>
<p>而有些同学的做法则是leader只需要同步一下最近要做什么方向，下面的一系列事情基本不需要leader操心了 ，这样的同学我是leader我也喜欢啊。入职后经常会听到的一个词叫owner意识，大概就是这个意思吧。</p>
<p>在这个过程中，另外很重要的一点就是及时向上沟通反馈。项目进展不顺利，遇到什么问题，及时跟leader同步，技术方案拿捏不准可以跟leader探讨，一些资源协调不了可以找leader帮忙，不要有太多顾忌，认为这些会太麻烦，leader其实就是干这个事的。</p>
<p>如果项目进展比较顺利，确实也不需要leader介入，那也需要及时把项目的进度，取得的收益及时反馈，自己有什么想法也提出来探讨，问问leader对当前进展的建议，还有哪些地方需要改进，消除信息误差。做这些事一方面是合理利用leader的各种资源，另一方面也可以让leader了解到自己的工作量，对项目整体有所把控，毕竟leader也有leader，也是要汇报的。</p>
<p>可能算是大家比较反感的向上管理吧，有内味了，这个其实我也做得不好。但是最基本的一点，不要接了一个任务闷着头干活甚至与世隔绝了，一个月了也没跟leader同步过，想着憋个大招之类的，那基本凉凉。</p>
<p><em><strong>一定要主动，可以先从强迫自己在各种公开场合发言开始，有问题或想法及时one-one。</strong></em></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="第一件事建立信任"><a href="#第一件事建立信任" class="headerlink" title="第一件事建立信任"></a>第一件事建立信任</h3><p>无论是校招还是社招，刚入职的第一件事是非常重要的，直接决定了leader和同事对自己的第一印象。入职后要做的第一件事一定要做好，最起码的要顺利完成而且不能出线上事故。</p>
<p>这件事的目的就是为了建立信任，让团队觉得自己起码是靠谱的。如果这件事做得比较好，后面一路都会比较顺利。如果这件事就搞杂了，可能有的leader还会给第二次机会，再搞不好，后面就很难了，这一条对于社招来说更为重要。</p>
<p>而刚入职，公司技术栈不熟练，业务繁杂很难理清什么头绪，压力确实比较大。这时候一方面需要自己投入更多的精力，另一方面要多跟组内的同学交流，不懂就问。最有效率的学习方式，我觉得不是什么看书啊学习视频啊，而是直接去找对应的人聊，让别人讲一遍自己基本就全懂了，这效率比看文档看代码快多了，不仅省去了过滤无用信息的过程，还了解到了业务的演变历史。当然，这需要一定的沟通技巧，毕竟同事们也都很忙。</p>
<p><em><strong>脸皮要厚一点，多找人聊，快速融入，最忌讳有问题也不说，自己把自己孤立起来。</strong></em></p>
<h3 id="超出预期"><a href="#超出预期" class="headerlink" title="超出预期"></a>超出预期</h3><p>超出预期这个词的外延范围很广，比如leader让去做个值周，解答用户群里大家的问题，结果不仅解答了大家的问题，还收集了这些问题进行分类，进而做了一个智能问答机器人解放了值周的人力，这可以算超出预期。</p>
<p>比如leader让给运营做一个小工具，结果建设了一系列的工具甚至发展成了一个平台，成为了一个完整的项目，这也算超出预期。超出预期要求我们有把事情做大的能力，也就是想到了leader没想到的地方，并且创造了实际价值，拿到了业务收益。</p>
<p>这个能力其实也比较重要，在工作中发现，有的人能把一个小盘子越做越大，而有的人恰好反之，那么那些有创新能力，经常超出预期的同学发展空间显然就更大一点。</p>
<p><em><strong>这块其实比较看个人能力，暂时没想到什么太好的捷径，多想一步吧。</strong></em></p>
<h3 id="体系化思考，系统化建设"><a href="#体系化思考，系统化建设" class="headerlink" title="体系化思考，系统化建设"></a>体系化思考，系统化建设</h3><p>这句话是晋升时候总结出来的，大意就是做系统建设要有全局视野，不要局限于某一个小点，应该有良好的规划能力和清晰的演进蓝图。比如，今天加了一个监控，明天加一个报警，这些事不应该成为一个个孤岛，而是属于稳定性建设一期其中的一小步。</p>
<p>这一期稳定性建设要做的工作是报警配置和监控梳理，包括机器监控、系统监控、业务监控、数据监控等，预期能拿到XXX的收益。这个工作还有后续的roadmap，稳定性建设二期要做容量规划，接入压测，三期要做降级演练，多活容灾，四期要做…给人的感觉就是这个人思考非常全面，办事有体系有规划。</p>
<p><em><strong>平时积极总结沉淀，多跟别人交流，形成方法论。</strong></em></p>
<h3 id="提升自己的软素质能力"><a href="#提升自己的软素质能力" class="headerlink" title="提升自己的软素质能力"></a>提升自己的软素质能力</h3><p>这里的软素质能力其实想说的就是PPT、沟通、表达、时间管理、设计、文档等方面的能力。</p>
<p>说实话，我觉得我当时能晋升就是因为PPT做的好了一点…可能大家平时对这些能力都不怎么关注，以前我也不重视，觉得比较简单，用时候直接上就行了，但事实可能并不像想象得那样简单。比如晋升时候PPT+演讲+答辩这个工作，其实有很多细节的思考在里面，内容如何选取，排版怎么设计，怎样引导听众的情绪，如何回答评委的问题等等。</p>
<p>晋升时候我见过很多同学PPT内容编排杂乱无章，演讲过程也不流畅自然，虽然确实做了很多实际工作，但在表达上欠缺了很多，属于会做不会说，如果再遇到不了解实际情况的外部门评委，吃亏是可以预见的。</p>
<p><em><strong>公司内网一般都会有一些软素质培训课程，可以找一些场合刻意训练。</strong></em></p>
<h3 id="拍马屁是真的香"><a href="#拍马屁是真的香" class="headerlink" title="拍马屁是真的香"></a>拍马屁是真的香</h3><p>拍马屁这东西入职前我是很反感的，我最初想加入互联网公司的原因就是觉得互联网公司的人情世故没那么多，事实证明，我错了…入职前几天，部门群里大leader发了一条消息，后面几十条带着大拇指的消息立马跟上，学习了，点赞，真不错，优秀，那场面，说是红旗招展锣鼓喧天鞭炮齐鸣一点也不过分。</p>
<p>除了惊叹大家超强的信息接收能力和处理速度外，更进一步我还发现，连拍马屁都是有队形的，一级部门leader发消息，几个二级部门leader跟上，后面各组长跟上，最后是大家的狂欢，让我一度怀疑拍马屁的速度就决定了职业生涯的发展前景（没错，现在我已经不怀疑了）。</p>
<p>坦诚地说，我到现在也没习惯在群里拍马屁，但也不反感了，可以说把这个事当成一乐了。倒不是说我没有那个口才和能力（事实上也不需要什么口才，大家都简单直接），在某些场合，为活跃气氛的需要，我也能小嘴儿抹了蜜，甚至能把古诗文彩虹屁给leader安排上。而是我发现我的直属leader也不怎么在群里拍马屁，所以我表面上不公开拍马屁其实属于暗地里事实上迎合了leader的喜好…</p>
<p>但是拍马屁这个事只要掌握好度，整体来说还是香的，最多是没用，至少不会有什么坏处嘛。大家能力都差不多，每一次在群里拍马屁的机会就是一次露脸的机会，按某个同事的说法，这就叫打造个人技术影响力…</p>
<p><em><strong>想舔就舔，不想舔也没必要酸别人，Respect Greatness。</strong></em></p>
<h3 id="永不缺席的撕逼甩锅实战"><a href="#永不缺席的撕逼甩锅实战" class="headerlink" title="永不缺席的撕逼甩锅实战"></a>永不缺席的撕逼甩锅实战</h3><p>有人的地方，就有江湖。虽然搞技术的大多城府也不深，但撕逼甩锅邀功抢活这些闹心的事儿基本也不会缺席，甚至我还见到过公开群发邮件撕逼的…这部分话题涉及到一些敏感信息就不多说了，而且我们低职级的遇到这些事儿的机会也不会太多。只是给大家提个醒，在工作的时候迟早都会吃到这方面的瓜，到时候留个心眼。</p>
<p><em><strong>稍微注意一下，咱不会去欺负别人，但也不能轻易让别人给欺负了。</strong></em></p>
<h3 id="不要被画饼蒙蔽了双眼"><a href="#不要被画饼蒙蔽了双眼" class="headerlink" title="不要被画饼蒙蔽了双眼"></a>不要被画饼蒙蔽了双眼</h3><p>说实话，我个人是比较反感灌鸡汤、打鸡血、谈梦想、讲奋斗这一类行为的，9102年都快过完了，这一套 *** 治还在大行其道，真不知道是该可笑还是可悲。当然，这些词本身并没有什么问题，但是这些东西应该是自驱的，而不应该成为外界的一种强push。</p>
<p>『我必须努力奋斗』这个句式我觉得是正常的，但是『你必须努力奋斗』这种话多少感觉有点诡异，努力奋斗所以让公司的股东们发家致富？尤其在钱没给够的情况下，这些行为无异于耍流氓。我们需要对leader的这些画饼操作保持清醒的认知，理性分析，作出决策。比如感觉钱没给够（或者职级太低，同理）的时候，可能有以下几种情况：</p>
<ol>
<li>leader并没有注意到你薪资较低这一事实</li>
<li>leader知道这个事实，但是不知道你有多强烈的涨薪需求</li>
<li>eader知道你有涨薪的需求，但他觉得你能力还不够</li>
<li>leader知道你有涨薪的需求，能力也够，但是他不想给你涨</li>
<li>leader想给你涨，也向上反馈和争取了，但是没有资源</li>
</ol>
<p>这时候我们需要做的是向上反馈，跟leader沟通确认。如果是1和2，那么通过沟通可以消除信息误差。如果是3，需要分情况讨论。如果是4和5，已经可以考虑撤退了。对于这些事儿，也没必要抱怨，抱怨解决不了任何问题。我们要做的就是努力提升好个人能力，保持个人竞争力，等一个合适的时机，跳槽就完事了。</p>
<p><em><strong>时刻准备着，技术在手就没什么可怕的，哪天干得不爽了直接跳槽。</strong></em></p>
<h3 id="学会包装"><a href="#学会包装" class="headerlink" title="学会包装"></a>学会包装</h3><p>这一条说白了就是，要会吹。忘了从哪儿看到的了，能说、会写、善做是对职场人的三大要求。能说是很重要的，能说才能要来项目，拉来资源，招来人。同样一件事，不同的人能说出来完全不一样的效果。比如我做了个小工具上线了，我就只能说出来基本事实，而让leader描述一下，这就成了，打造了XXX的工具抓手，改进了XXX的完整生态，形成了XXX的业务闭环。老哥，我服了，硬币全给你还不行嘛。据我的观察，每个互联网公司都有这么几个词，抓手、生态、闭环、拉齐、梳理、迭代、owner意识等等等等，我们需要做的就是熟读并背诵全文，啊不，是牢记并熟练使用。</p>
<p>这是对事情的包装，对人的包装也是一样的，尤其是在晋升和面试这样的应试型场合，特点是流程短一锤子买卖，包装显得尤为重要。晋升和面试这里就不展开说了，这里面的道和术太多了。。下面的场景提炼自面试过程中和某公司面试官的谈话，大家可以感受一下：</p>
<ul>
<li>我们背后是一个四五百亿美金的市场…</li>
<li>我负责过每天千亿级别访问量的系统…</li>
<li>工作两年能达到这个程度挺不错的…</li>
<li>贵司技术氛围挺好的，业务发展前景也很广阔…</li>
<li>啊，彼此彼此…</li>
<li>嗯，久仰久仰…</li>
</ul>
<p><em><strong>人生如戏，全靠演技。可以多看leader的PPT，多听老板的向上汇报和宣讲会。</strong></em></p>
<h3 id="选择和努力哪个更重要？"><a href="#选择和努力哪个更重要？" class="headerlink" title="选择和努力哪个更重要？"></a>选择和努力哪个更重要？</h3><p>这还用问么，当然是选择。在完美的选择面前，努力显得一文不值，我有个多年没联系的高中同学今年已经在时代广场敲钟了…但是这样的案例太少了，做出完美选择的随机成本太高，不确定性太大。对于大多数刚毕业的同学，对行业的判断力还不够成熟，对自身能力和创业难度把握得也不够精准，此时拉几个人去创业，显得风险太高。我觉得更为稳妥的一条路是，先加入规模稍大一点的公司，找一个好leader，抱好大腿，提升自己的个人能力。好平台加上大腿，再加上个人努力，这个起飞速度已经可以了。等后面积累了一定人脉和资金，深刻理解了市场和需求，对自己有信心了，可以再去考虑创业的事。</p>
<p>转载自：<a href="https://xie.infoq.cn/article/9c9bdc7cba67bc47f8f5686c3">https://xie.infoq.cn/article/9c9bdc7cba67bc47f8f5686c3</a></p>
]]></content>
      <categories>
        <category>认知到位</category>
      </categories>
      <tags>
        <tag>认知到位</tag>
      </tags>
  </entry>
  <entry>
    <title>论如何学习新的技能</title>
    <url>/2021/02/21/think/%E8%AE%BA%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E6%96%B0%E7%9A%84%E6%8A%80%E8%83%BD/</url>
    <content><![CDATA[<p>今天晚上和泽康聊了一下春节期间的各自生活，有趣的是我们俩都列举了通过短时间快速学习做好一件事情的例子。</p>
<h2 id="两个例子"><a href="#两个例子" class="headerlink" title="两个例子"></a>两个例子</h2><p>例子1，先来看看我举的例子</p>
<p>春节期间和家人在家打牌，</p>
<p>第一天，我们伙抓了一手好牌，但是被打的很惨。</p>
<p>第二天，我观察到对方每次都透过一轮推测我们每局的牌大小，从而采取相应的策略。</p>
<p>第三天，我模仿着敌方策略，成功翻盘。</p>
<p>例子2，再看看泽康举的例子</p>
<p>泽康假期对狼人杀和杀人游戏这两个游戏挺感兴趣的，</p>
<p>他看了杀人游戏的国家级比赛，学到了很多，</p>
<p>后面他再去玩狼人杀的时候就可以带飞了。</p>
<h2 id="学习新技能"><a href="#学习新技能" class="headerlink" title="学习新技能"></a>学习新技能</h2><p>在我看来新的技能的学习分为两个大的阶段，</p>
<ul>
<li><p>第一个阶段是入门从0到60分，假期中我和泽康的两个例子都是入门的典型例子。</p>
</li>
<li><p>第二个阶段是进阶从60分到100分，这个阶段的典型例子是工作中你想成为一个技术专家、好的leader等。</p>
</li>
</ul>
<p>接下来我们就具体来看看每个阶段比较好的学习方式以及特点。</p>
<h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>入门阶段最佳的学习方式为：</p>
<p>从<strong>优秀的学习资料</strong>中，通过<strong>观察、思考、总结、模仿</strong>将前人身上的经验、技能固化自己身上。</p>
<p>这句话有两个重点：</p>
<ul>
<li><p>第一个是“优秀的学习资料”，那么什么是优秀的学习资料呢？可以是一个优秀的人，一场水平很高的比赛，一堂名师的课程等等。</p>
</li>
<li><p>第二个是“观察、思考、总结、模仿”，观察是输入、收集信息，思考是处理信息，总结是输出信息，至于模仿则是ctrl+c、ctrl+v。</p>
</li>
</ul>
<p>通过这种方式可以快速的前人身上优秀的经验、技能复制到我们自己的身上。</p>
<p>有了上述结论，再举两个发生在我身上的例子：</p>
<ol>
<li>我大一的时候几个月就出来一个网站的原因是当时学长给了我一套牛腩新闻发布系统的视频教程，我通过“观察、思考、总结、模仿”，快速的做了一个自己的新闻发布系统，并且具备了使用C#做一个自己网站的能力。</li>
<li>而相反，我这几年数次尝试去新学点什么，但是最后都失败了，现在我知道为什么这几年我在新知识的学习上这么差了，因为我只做了优秀资料的收集，但是没有去“观察、思考、总结、模仿”。</li>
</ol>
<p>在这两个例子中，我要做的事情都是“入门”，但是一个没有想那么多反而采取了正确的学习方式快速的入门了，而另一个例子中由于自己有一定的基础，入门过程中“想”了很多，但是并没有按照正确的学习方式去学习，导致入门失败。</p>
<p>可见，<strong>知其然知其所以然</strong> 的重要性。</p>
<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>聊完了如何“入门”，那么接下来我们再聊聊入门之后如何进阶。</p>
<p>进阶的最佳方式为：</p>
<p>在实践中去<strong>观察、思考、总结</strong>，然后<strong>不断的去迭代</strong>。</p>
<p>这句话中同样有两个重点：</p>
<ul>
<li><p>第一个就是“观察、思考、总结”，同样观察是输入、收集信息，思考是处理信息，总结是输出信息。</p>
</li>
<li><p>第二个是“不断的去迭代”，每一次的“观察、思考、总结”是一次迭代，但是每次迭代只是一次有限的优化，就和软件需要不断的发新的版本去升级一样，人也是如此，随着人生阅历的增加，你的人生操作系统一定是在不断更新换代中的，这就要求你你的迭代是不断的。</p>
</li>
</ul>
<p>细心的朋友可以发现，“进阶”相比于“入门”的实际操作方案少了点什么，那少了什么呢？</p>
<p>那就是“模仿”，进阶的实操是“观察、思考、总结”，而入门的实操是“观察、思考、总结、模仿”。</p>
<p>这就好比于，入门是你直接把别人的一套代码拿过来简单改改部署上就是一个自己的系统了，快速又有质量。而进阶则要求你去根据自己的需求不断的去迭代这个套系统，而这个迭代的过程注定是缓慢而又持久的。</p>
<p>所以，入门只要掌握了对的方法一点不难，难的是入门之后的进阶，那才是考验人的阶段。</p>
<hr>
<blockquote>
<p>文章每周六持续更新，可以微信搜一搜「 荒古传说 」抢先阅读。</p>
</blockquote>
]]></content>
      <categories>
        <category>认知到位</category>
      </categories>
      <tags>
        <tag>认知到位</tag>
      </tags>
  </entry>
  <entry>
    <title>圆梦草原-达达线+热阿线</title>
    <url>/2022/07/23/travel-notes/%E5%9C%86%E6%A2%A6%E8%8D%89%E5%8E%9F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>从大学的时候就一直想去 内蒙古 看一眼一样无垠的大草原，可惜拿了驾照之后一直也没机会练车，而去 内蒙古 大草原这种地方如果不是自驾的话就太麻烦了，所以一直也没去上。</p>
<p>这次很偶然的，在公司内部旅游群看到冠廷在问有没人一起去草原玩，正好是周末就第一时间报名了。</p>
<h2 id="出游计划"><a href="#出游计划" class="headerlink" title="出游计划"></a>出游计划</h2><p>（ps：该出游计划来自冠廷大佬，这里再次感谢冠廷大佬带大家玩耍～）</p>
<p>7月16日（周六）<br>高铁G3665（ 北京 朝阳 - 赤峰 ） 10点-12:22<br>落地租车<br>赤峰 -热水塘镇（路过）-黄岗梁景区-阿斯哈图石阵景区（世界地质公园）【热阿线】<br>4’30&amp;amp;quot;  330km<br>宿  阿斯哈图附近</p>
<p>7月17日（周日）<br>阿斯哈图-达里湖【达达线】- 赤峰<br>5’52&amp;amp;quot; 465km<br>高铁G3680（ 赤峰 - 北京 朝阳 ） 20:16-22:42<br>解散</p>
<h2 id="D1-北京-赤峰-热阿线-阿斯哈图"><a href="#D1-北京-赤峰-热阿线-阿斯哈图" class="headerlink" title="D1 北京 - 赤峰 - 热阿线 - 阿斯哈图"></a>D1 北京 - 赤峰 - 热阿线 - 阿斯哈图</h2><p>早起8点多大家组队拼车来到了 北京 朝阳 站，到了之后时间刚刚好。</p>
<p>12点多坐高铁到了 赤峰 之后，冠廷和越鸣分别取了车，由于我们有两个人核酸前一天出来的早，所以我们这车到附近的松山医院去做了核酸。然后我们去宴宾楼饭店和冠廷他们车汇合一起吃了出来的第一顿午饭。</p>
<p>午饭点了很多当地特色的食物，但是不是很吃的惯，不过有两个女生很喜欢。</p>
<p>第一次喝了大窑，有点甜～还挺好喝的。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220723115113.png"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220723115132.png"></p>
<p>吃过午饭，我们开始驱车往阿斯图赶，途径热水塘镇（路过）、黄岗梁景区，也就是走了一遍热阿线。</p>
<p>这里还有个小插曲，越鸣我们车下了高速以后，我们以为我们在前面，所以在停车等后面这辆车，结果他们把我们超过了，我们等了大半天才发现，不过等的过程我们几个人拍了好看的合照。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220723115152.png"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220723115207.png"></p>
<p>远处的阳光洒下来也很美～</p>
<p>发现我们被落在了后面之后，我们也出发踏上了热阿线。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220723115226.png"></p>
<p>路上渐渐的开始下起了雨，雨越下越大，手机也没了信号，能见度一度不足几米，有一种爱丽丝梦游仙境的奇幻感，事后回想起来格外舒爽。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220723115246.png"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220723115300.png"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220723115312.png"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220723115325.png"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220723115339.png"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220723115350.png"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220723115404.png"></p>
<p>终于在两位大佬高超车技的带领下，我们一行8人安全的来到我们此行的目的地阿斯哈图附近的一家民俗。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220723115422.png"></p>
<p>这里不得不这次夸赞一下冠廷大佬，大佬找的这家民宿远超我的预期。</p>
<p>住的很舒服，吃的也十分对大家的胃口，吃的饱饱的。</p>
<p>晚上大家玩了游戏，打了 德州 （我一如既然的输了😭），大家玩的很开心，彼此也更熟悉了些许。</p>
<h2 id="D2-阿斯哈图-达达线-赤峰-北京"><a href="#D2-阿斯哈图-达达线-赤峰-北京" class="headerlink" title="D2 阿斯哈图 - 达达线 - 赤峰 - 北京"></a>D2 阿斯哈图 - 达达线 - 赤峰 - 北京</h2><p>早上下过雨，本来越鸣说爬山，我说你去吧，我穿拖鞋去不了，可是还是按耐不住对美丽景色的向往，穿着拖鞋爬了一段，上图中白色的房子就是我们住的民宿，体验相当好👍</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220723115459.png"></p>
<p>早上9点半我们出发踏上了达达线，由于今天天气会好一点，终于看到了一望无垠的大草原。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220723115521.png"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220723115535.png"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220723115552.png"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220723115608.png"></p>
<p>在达里湖吃过午饭之后，彻底踏上了返程，高速上两位大佬还飙了一会儿车，更好笑的是对面车上的三位同学竟然都不知道，都在睡觉😂</p>
<p>到了 赤峰 之后我们吃的思琴阿妈，中规中矩，也可能是大家略感疲惫不太饿。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220723115633.png"></p>
<p>吃完晚饭，我们就到高铁站还车，踏上了回 北京 的高铁。</p>
<p>最后一段极美的视频来结束这段旅程。</p>
<ul>
<li>视频可以在马蜂窝看，<a href="http://www.mafengwo.cn/i/23778458.html">马蜂窝链接</a></li>
</ul>
]]></content>
      <categories>
        <category>旅行游记</category>
      </categories>
      <tags>
        <tag>内蒙古</tag>
      </tags>
  </entry>
  <entry>
    <title>眺望大海 - 大连之旅</title>
    <url>/2022/08/05/travel-notes/%E7%9C%BA%E6%9C%9B%E5%A4%A7%E6%B5%B7/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>上上周刚去了草原，回来之后就想去看看大海，吃吃海鲜，结果上周三中午的时茹萱大佬正好问问周末去不去大连，一拍即合！</p>
<h2 id="出游计划"><a href="#出游计划" class="headerlink" title="出游计划"></a>出游计划</h2><p>三个人，分三个时间出发，时间参考意义不大，贴一下行程安排吧。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220805214218.png"></p>
<p>ps：行程康教授安排的，再次感谢康教授！</p>
<h2 id="D1-北京-大连-棒棰岛"><a href="#D1-北京-大连-棒棰岛" class="headerlink" title="D1 北京 - 大连 - 棒棰岛"></a>D1 北京 - 大连 - 棒棰岛</h2><p>我是周六早上从北京做的高铁去的大连，全程大概4个小时左右。</p>
<p>有意思的是我这次做的这趟车和上次去赤峰的车是一个检票口，并且顺序也是紧挨着的，不得不再次感叹一下，世间之事的奇妙。</p>
<p>走的前一天网上，希望不让我收拾东西，各种捣乱：<br><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220805214621.png"></p>
<p>大连北站：<br><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220805215142.png"></p>
<p>下车饥肠辘辘的去投奔茹萱大佬和康教授，虽然等的时间略长，但是第一顿吃的就有海鲜，还是很开心的。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220805221321.png"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220805215433.png"></p>
<p>口感还是很不错的👍</p>
<p>吃完饭去了本次最满意的一个景点 —— 棒棰岛</p>
<p>话不多说，上图：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220805215859.png"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220805215841.png"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220805215825.png"></p>
<p>本场最佳文案：“海的那边，是敌人”</p>
<p>除了美景之外，最开心的就是给两位大佬的拍照了，在两位高级班同学的赞扬声中，我愉快的拍着照。</p>
<p>ps：这里也再一次的感谢康教授的指导。</p>
<p>拍完照，哦不，看完棒棰岛我们就返回市里，去威尼斯水城看喷泉，结果没想到峰回路转喷泉没看到体验了一把夜晚的帆船！</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220805220644.png"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220805220709.png"></p>
<p>苦海无边～</p>
<p>上岸后，一起吃了鱿鱼歇息了一会儿，打车去吃了正黄旗烧烤，还挺好吃的👍</p>
<p>由于第一天玩的太晚，所以回酒店之后5 10k活动被鸽了.鸽了..鸽了…</p>
<p>一业无话</p>
<h2 id="D2-牧场拍照-爱国主义教育-老友小聚-星海广场"><a href="#D2-牧场拍照-爱国主义教育-老友小聚-星海广场" class="headerlink" title="D2 牧场拍照 - 爱国主义教育 - 老友小聚 - 星海广场"></a>D2 牧场拍照 - 爱国主义教育 - 老友小聚 - 星海广场</h2><p>早上怀揣着满腔热血起床来到了酒店的健身房，结果被狠狠地打脸了，只有几台跑步机孤零零的摆在那里，想跑步我去海边跑不好吗？</p>
<p>回房间洗了个澡之后来到楼下吃饭，结果又遇到了一个熊孩子，到处摸大家的食物，实在少兴，本来看到东北气息十足的酒店早餐的高兴劲没了一大半。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220805221427.png"></p>
<p>早上大家打车来到了牧场，又开开心心的拍了一上午的照骗。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220805221713.png"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220805221735.png"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220805222116.png"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220805221750.png"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220805221820.png"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220805221836.png"></p>
<p>从牧场出来之后，我们打车来到了旅顺日俄监狱，看到了日俄对我们的先辈犯下的种种罪行，这份屈辱，我们中华儿女当永远牢记心中。</p>
<p>落后就要挨打，只有我们的国家，我们的民族强大起来，重新屹立世界之巅，我们每一个普通的中国人才能真正过的幸福。</p>
<p>过去几千年我们都是世界上最强大的霸主，不过近代这几百年才给了西方蛮夷以可乘之机罢了，早有周总理的为中华之崛起而读书，今有我们每一个人的为中华之冲顶而奋斗！</p>
<p>从日俄监狱离开之后我们来到了军港，远远的眺望到了军舰。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220805222933.png"></p>
<p>然后这个时候突然发现我的手、脖子、脸都被晒伤了…这真是智者千虑，必有一失。</p>
<p>此时，我们已经累极，找了一家咖啡厅，休息了一下，环境还不错👍（也可能是听优秀的人聊天比较开心）</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220805223112.png"></p>
<p>后面晚上去和心语她们汇合一起吃了晚饭，也见到了心语的男朋友，很帅，和心语很般配👍</p>
<p>回去的路上路过跨江大桥，在大桥上看到了星海广场，景色十分漂亮，于是我们让司机师傅带我们到了星海广场。</p>
<p>我们租了一辆脚踏船，在海里漂了很长时间～很安静的感觉</p>
<p>上岸后，我们又愉快的玩了碰碰车、飞椅、小跳楼机。</p>
<p>不得不说累了一天，晚上玩这个真的很难控制情绪，吓得我哇哇大叫…不过还很开心怎么回事？</p>
<p>最最最开心的，莫过于回到酒店之后终于把5 10 k活动给安排上了，最终大家打了一个小时之后平分秋色，各有千秋👍</p>
<h2 id="D3-海上日出-海洋公园-大连-北京"><a href="#D3-海上日出-海洋公园-大连-北京" class="headerlink" title="D3 海上日出 - 海洋公园 - 大连 - 北京"></a>D3 海上日出 - 海洋公园 - 大连 - 北京</h2><p>回房间睡了一个睡眠周期之后，我成功的把大家叫起来去东港看了回海上日出🌄</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220805224204.png"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220805224228.png"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220805224243.png"></p>
<p>看完日出大家回酒店补了个觉。</p>
<p>中午吃了饭之后去了海洋公园看海洋动物～</p>
<p>全程没有兴致拍照，比较有趣的是海狮表演前的开场动画</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220805224441.png"></p>
<p>从海洋公园出来之后，就踏上了返程的列车。</p>
<p>不得不说快乐的日子总是短暂的，每次出去玩完回来之后总是要适应两天。</p>
<p><strong>PS：最后再次感谢本次旅行的发起者康教授以及为大家垫付开销的<br>茹萱大佬，是你们的辛勤付出让我能躺的更开心一点，感谢！！！</strong></p>
]]></content>
      <categories>
        <category>旅行游记</category>
      </categories>
      <tags>
        <tag>辽宁</tag>
      </tags>
  </entry>
  <entry>
    <title>Yaf 框架学习</title>
    <url>/2019/07/25/cs-basic/cs-basic-framework/Yaf-%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Yaf-是什么"><a href="#Yaf-是什么" class="headerlink" title="Yaf 是什么"></a>Yaf 是什么</h1><p>Yaf，全称 Yet Another Framework，是一个C语言编写的、基于PHP扩展开发的PHP框架。</p>
<p>相比于一般的PHP框架，它更快，快到被誉为最快的PHP开发框架。</p>
<p>它提供了Bootstrap、路由、分发、视图、插件功能。</p>
<p>注：</p>
<blockquote>
<p>百度的odp框架，以及我们公司的PIE框架都是基于yaf开发的。</p>
</blockquote>
<h1 id="Yaf-的优点"><a href="#Yaf-的优点" class="headerlink" title="Yaf 的优点"></a>Yaf 的优点</h1><ul>
<li><em>用C语言开发的PHP框架, 相比原生的PHP, 几乎不会带来额外的性能开销.</em></li>
<li><em>所有的框架类, 不需要编译, 在PHP启动的时候加载, 并常驻内存.</em></li>
<li><em>更短的内存周转周期, 提高内存利用率, 降低内存占用率.</em></li>
<li><em>灵巧的自动加载. 支持全局和局部两种加载规则, 方便类库共享.</em></li>
<li><em>高性能的视图引擎.</em></li>
<li><em>高度灵活可扩展的框架, 支持自定义视图引擎, 支持插件, 支持自定义路由等等.</em></li>
<li><em>内建多种路由, 可以兼容目前常见的各种路由协议.</em></li>
<li><em>强大而又高度灵活的配置文件支持. 并支持缓存配置文件, 避免复杂的配置结构带来的性能损失.</em></li>
<li><em>在框架本身,对危险的操作习惯做了禁止.</em></li>
<li><em>更快的执行速度, 更少的内存占用.</em></li>
</ul>
<p>以上内容引用鸟哥的官方介绍，当然，Yaf不是一个Full-Stack的web框架，它没有对数据库操作的封装，更不用说ORM；很多人认为这是Yaf的不足，但我认为这又是Yaf的优点，这代表着一种精神，就是追求简单，追求高效，追求”简单可依赖“, 所以Yaf专注于实现最核心的功能，提供最稳定的实现。</p>
<p>尽管Yaf的功能有限，但Yaf是可扩展的！它提供的插件机制，可以和其它类库整合在一起。Yaf非常适合基于Yaf再扩展一套适合自己的业务层框架。总之Yaf非常适合互联网产品的开发。</p>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p>Yaf提供了完善的API, 并支持Bootstrap和插件机制. 整体流程图如下:</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/yaf_sequence.png"></p>
<h1 id="使用-Bootstrap"><a href="#使用-Bootstrap" class="headerlink" title="使用 Bootstrap"></a>使用 Bootstrap</h1><p>Bootstrap, 也叫做引导程序. 它是Yaf提供的一个全局配置的入口, 在Bootstrap中, 你可以做很多全局自定义的工作.</p>
<p>注：</p>
<blockquote>
<p>在PIE框架中webroot目录下各个模块对应的文件里的index.php起初始化作用，部分替代了yaf中Bootstrap文件的作用：          </p>
</blockquote>
<p>index.php文件：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$objApplication</span> = <span class="title class_">Sf\Init</span>::<span class="title function_ invoke__">init</span>();      </span><br><span class="line"><span class="variable">$objResponse</span> = <span class="variable">$objApplication</span>-&gt;<span class="title function_ invoke__">bootstrap</span>()-&gt;<span class="title function_ invoke__">run</span>(); </span><br></pre></td></tr></table></figure>

<h1 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h1><p>PIE 框架中的路由协议采用默认协议，由请求url中指定要路由的app、controller、action名称。</p>
<blockquote>
<p><a href="http://www.laruence.com/manual/index.html">Yaf(Yet Another Framework)用户手册</a></p>
</blockquote>
]]></content>
      <categories>
        <category>专业知识</category>
        <category>框架组件</category>
      </categories>
      <tags>
        <tag>yaf</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac-Command-Line技巧</title>
    <url>/2018/11/08/cs-basic/cs-basic-linux/Mac-Command-Line%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<ul>
<li>Command + n   新建窗口</li>
<li>Command + t   新建tap</li>
<li>Command + q   关闭窗口</li>
<li>Command + w   关闭tap</li>
<li>Command + l   清屏</li>
<li>Command + d   水平分屏</li>
<li>Command + shift + d   取消水平分屏</li>
<li>Command + shift + 方向键  切换到指定tap</li>
<li>输入 <strong>open .</strong> 可以用finder打开当前的位置</li>
<li>可以用 <strong>history</strong> 命令查看历史记录</li>
</ul>
]]></content>
      <categories>
        <category>专业知识</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc 命令</title>
    <url>/2018/12/11/cs-basic/cs-basic-linux/gcc-%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><strong>gcc命令</strong>使用GNU推出的基于C&#x2F;C++ 的编译器，是开放源代码领域应用最广泛的编译器，具有功能强大，编译代码支持性能优化等特点。现在很多程序员都应用GCC，怎样才能更好的应用GCC。目前，GCC可以用来编译C&#x2F;C++、FORTRAN、JAVA、OBJC、ADA等语言的程序，可根据需要选择安装支持的语言。</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc(选项)(参数)</span><br></pre></td></tr></table></figure>

<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-o：指定生成的输出文件；</span><br><span class="line">-E：仅执行编译预处理；</span><br><span class="line">-S：将C代码转换为汇编代码；</span><br><span class="line">-wall：显示警告信息；</span><br><span class="line">-c：仅执行编译操作，不进行连接操作</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>C源文件：指定C语言源代码文件。</p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="常用编译命令选项"><a href="#常用编译命令选项" class="headerlink" title="常用编译命令选项"></a><font color='#006400'>常用编译命令选项</font></h2><p>假设源程序文件名为test.c</p>
<p><strong>无选项编译链接</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc test.c</span><br></pre></td></tr></table></figure>

<p>将test.c预处理、汇编、编译并链接形成可执行文件。这里未指定输出文件，默认输出为a.out。</p>
<p><strong>选项 -o</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc test.c -o test</span><br></pre></td></tr></table></figure>

<p>将test.c预处理、汇编、编译并链接形成可执行文件test。-o选项用来指定输出文件的文件名。</p>
<p><strong>选项 -E</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -E test.c -o test.i</span><br></pre></td></tr></table></figure>

<p>test.c预处理输出test.i文件。</p>
<p><strong>选项 -S</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -S test.i</span><br></pre></td></tr></table></figure>


<p>将预处理输出文件test.i汇编成test.s文件。</p>
<p><strong>选项 -c</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c test.s</span><br></pre></td></tr></table></figure>

<p>将汇编输出文件test.s编译输出test.o文件。</p>
<p><strong>无选项链接</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc test.o -o test</span><br></pre></td></tr></table></figure>

<p>将编译输出文件test.o链接成最终可执行文件test。</p>
<p><strong>选项 -O</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -O1 test.c -o test</span><br></pre></td></tr></table></figure>

<p>使用编译优化级别1编译程序。级别为1~3，级别越大优化效果越好，但编译时间越长。</p>
<h2 id="多源文件的编译方法"><a href="#多源文件的编译方法" class="headerlink" title="多源文件的编译方法"></a><font color='#006400'>多源文件的编译方法</font></h2><p>如果有多个源文件，基本上有两种编译方法：</p>
<p>假设有两个源文件为test.c和testfun.c</p>
<p><strong>多个文件一起编译</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc testfun.c test.c -o test</span><br></pre></td></tr></table></figure>

<p>将testfun.c和test.c分别编译后链接成test可执行文件。</p>
<p><strong>分别编译各个源文件，之后对编译后输出的目标文件链接。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -c testfun.c    #将testfun.c编译成testfun.o</span><br><span class="line">gcc -c test.c       #将test.c编译成test.o</span><br><span class="line">gcc -o testfun.o test.o -o test    #将testfun.o和test.o链接成test</span><br></pre></td></tr></table></figure>

<p>以上两种方法相比较，第一中方法编译时需要所有文件重新编译，而第二种方法可以只重新编译修改的文件，未修改的文件不用重新编译。</p>
]]></content>
      <categories>
        <category>专业知识</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>mac 终端连接阿里云服务器报错</title>
    <url>/2018/12/13/cs-basic/cs-basic-linux/mac%E7%BB%88%E7%AB%AF%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<blockquote>
<p>今天将阿里云的服务器重新安装的系统盘，然后再用ssh远程登陆就会报错。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line"></span><br><span class="line">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class="line"></span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line"></span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line"></span><br><span class="line">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class="line"></span><br><span class="line">It is also possible that a host key has just been changed.</span><br><span class="line"></span><br><span class="line">The fingerprint for the RSA key sent by the remote host is</span><br><span class="line"></span><br><span class="line">SHA256:这里每个人都不同</span><br><span class="line"></span><br><span class="line">Please contact your system administrator.</span><br><span class="line"></span><br><span class="line">Add correct host key in /Users/Anan/.ssh/known_hosts to get rid of this message.</span><br><span class="line"></span><br><span class="line">Offending RSA key in /Users/Anan/.ssh/known_hosts:1</span><br><span class="line"></span><br><span class="line">RSA host key for 这里是服务器的IP has changed and you have requested strict checking.</span><br><span class="line"></span><br><span class="line">Host key verification failed.</span><br></pre></td></tr></table></figure>

<p>会出现这些信息是因为，第一次SSH连接时，会生成一个认证，储存在客户端（也就是用SSH连线其他电脑的那个，自己操作的那个）中的known_hosts，但是如果服务器验证过了，认证资讯当然也会更改，服务器端与客户端不同时，就会跳出错误啦～因此，只要把电脑中的认证资讯删除，连线时重新生成，就一切完美啦～要删除很简单，只要在客户端输入一个指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -R +输入服务器的IP</span><br></pre></td></tr></table></figure>
<p>接下來再次连接一次，会出现</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure>

<p>输入yes，<br>就完成连接啦！同時，新的认证也生成了<br>在mac下使用终端连接服务器方式   </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh root@服务器地址</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>专业知识</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>scp 跨机远程拷贝</title>
    <url>/2018/12/11/cs-basic/cs-basic-linux/scp-%E8%B7%A8%E6%9C%BA%E8%BF%9C%E7%A8%8B%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p>scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。</p>
<blockquote>
<p>注解：<br>类似的工具有rsync；scp消耗资源少，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。rsync比scp会快一点，但当小文件多的情况下，rsync会导致硬盘I&#x2F;O非常高，而scp基本不影响系统正常使用。</p>
</blockquote>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>scp [参数] [原路径] [目标路径]</p>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><ul>
<li>-1 强制scp命令使用协议ssh1</li>
<li>-2 强制scp命令使用协议ssh2</li>
<li>-4 强制scp命令只使用IPv4寻址</li>
<li>-6 强制scp命令只使用IPv6寻址</li>
<li>-B 使用批处理模式（传输过程中不询问传输口令或短语）</li>
<li>-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</li>
<li>-p 留原文件的修改时间，访问时间和访问权限。</li>
<li>-q 不显示传输进度条。</li>
<li>-r 递归复制整个目录。</li>
<li>-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</li>
<li>-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。</li>
<li>-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。</li>
<li>-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</li>
<li>-l limit 限定用户所能使用的带宽，以Kbit&#x2F;s为单位。</li>
<li>-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式，</li>
<li>-P port 注意是大写的P, port是指定数据传输用到的端口号</li>
<li>-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</li>
</ul>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p><strong>从本地服务器复制到远程服务器</strong></p>
<p>复制文件:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">scp local_file remote_username@remote_ip:remote_folder</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">scp local_file remote_username@remote_ip:remote_file</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">scp local_file remote_ip:remote_folder</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">scp local_file remote_ip:remote_file</span></span><br></pre></td></tr></table></figure>

<p>指定了用户名，命令执行后需要输入用户密码；如果不指定用户名，命令执行后需要输入用户名和密码；</p>
<p>复制目录:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">scp -r local_folder remote_username@remote_ip:remote_folder</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">scp -r local_folder remote_ip:remote_folder</span></span><br></pre></td></tr></table></figure>

<p>第1个指定了用户名，命令执行后需要输入用户密码； 第2个没有指定用户名，命令执行后需要输入用户名和密码；</p>
<blockquote>
<p>注解<br>从远程复制到本地的scp命令与上面的命令一样，只要将从本地复制到远程的命令后面2个参数互换顺序就行了。</p>
</blockquote>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p><strong>实例1：从远处复制文件到本地目录</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">scp root@10.6.159.147:/opt/soft/demo.tar /opt/soft/</span></span><br></pre></td></tr></table></figure>
<p>说明： 从10.6.159.147机器上的&#x2F;opt&#x2F;soft&#x2F;的目录中下载demo.tar 文件到本地&#x2F;opt&#x2F;soft&#x2F;目录中</p>
<p><strong>实例2：从远处复制目录到本地</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">scp -r root@10.6.159.147:/opt/soft/test /opt/soft/</span></span><br></pre></td></tr></table></figure>
<p>说明： 从10.6.159.147机器上的&#x2F;opt&#x2F;soft&#x2F;中下载test目录到本地的&#x2F;opt&#x2F;soft&#x2F;目录来。</p>
<p><strong>实例3：上传本地文件到远程机器指定目录</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">scp /opt/soft/demo.tar root@10.6.159.147:/opt/soft/scptest</span></span><br></pre></td></tr></table></figure>
<p>说明： 复制本地opt&#x2F;soft&#x2F;目录下的文件demo.tar 到远程机器10.6.159.147的opt&#x2F;soft&#x2F;scptest目录</p>
<p><strong>实例4：上传本地目录到远程机器指定目录</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">scp -r /opt/soft/test root@10.6.159.147:/opt/soft/scptest</span></span><br></pre></td></tr></table></figure>
<p>说明： 上传本地目录 &#x2F;opt&#x2F;soft&#x2F;test到远程机器10.6.159.147上&#x2F;opt&#x2F;soft&#x2F;scptest的目录中</p>
]]></content>
      <categories>
        <category>专业知识</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务架构详解</title>
    <url>/2021/04/29/cs-basic/cs-basic-microservices/microservices/</url>
    <content><![CDATA[<blockquote>
<p>文章每周六持续更新，可以微信搜一搜「 haxianha 」抢先阅读。</p>
</blockquote>
<p>微服务框架（RPC）：Spring Boot、Spring Cloud、Dubbo、gRPC、Thrift、go-micro、Motan</p>
<p>服务支撑（运行时）：</p>
<ul>
<li>服务注册与发现 - 动态扩&#x2F;缩容：Zookeeper、Eureka、Consul、Etcd、Nacos</li>
<li>服务配置 - 动态配置：Apollo、Spring Cloud Config</li>
<li>服务网关 - 权限控制：Kong、APISIX、Zuul、Spring Cloud Gateway</li>
<li>服务治理 - 熔断、服务降级、限流：Sentinel</li>
</ul>
<p>服务监控：</p>
<ul>
<li>服务监控 - 发现故障的征兆：Prometheus、Grafana</li>
<li>定位问题 - 链路跟踪：Zipkin、SkyWalking</li>
<li>分析问题 - 日志采集：Elasticsearch、Logstash、Kibana</li>
</ul>
<hr>
<p>本文将介绍微服务架构和相关的组件，介绍他们是什么以及为什么要使用微服务架构和这些组件。本文侧重于简明地表达微服务架构的全局图景，因此不会涉及具体如何使用组件等细节。</p>
<p>要理解微服务，首先要先理解不是微服务的那些。通常跟微服务相对的是单体应用，即将所有功能都打包成在一个独立单元的应用程序。从单体应用到微服务并不是一蹴而就的，这是一个逐渐演变的过程。本文将以一个网上超市应用为例来说明这一过程。</p>
<h2 id="最初的需求"><a href="#最初的需求" class="headerlink" title="最初的需求"></a>最初的需求</h2><p>几年前，小明和小皮一起创业做网上超市。小明负责程序开发，小皮负责其他事宜。当时互联网还不发达，网上超市还是蓝海。只要功能实现了就能随便赚钱。所以他们的需求很简单，只需要一个网站挂在公网，用户能够在这个网站上浏览商品、购买商品；另外还需一个管理后台，可以管理商品、用户、以及订单数据。</p>
<p>我们整理一下功能清单：</p>
<ul>
<li>网站<ul>
<li>用户注册、登录功能</li>
<li>商品展示</li>
<li>下单</li>
</ul>
</li>
<li>管理后台<ul>
<li>用户管理</li>
<li>商品管理</li>
<li>订单管理</li>
</ul>
</li>
</ul>
<p>由于需求简单，小明左手右手一个慢动作，网站就做好了。管理后台出于安全考虑，不和网站做在一起，小明右手左手慢动作重播，管理网站也做好了。总体架构图如下：</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210429013233.png"></p>
<p>小明挥一挥手，找了家云服务部署上去，网站就上线了。上线后好评如潮，深受各类肥宅喜爱。小明小皮美滋滋地开始躺着收钱。</p>
<h2 id="随着业务发展……"><a href="#随着业务发展……" class="headerlink" title="随着业务发展……"></a>随着业务发展……</h2><p>好景不长，没过几天，各类网上超市紧跟着拔地而起，对小明小皮造成了强烈的冲击。</p>
<p>在竞争的压力下，小明小皮决定开展一些营销手段：</p>
<ul>
<li>开展促销活动。比如元旦全场打折，春节买二送一，情人节狗粮优惠券等等。</li>
<li>拓展渠道，新增移动端营销。除了网站外，还需要开发移动端APP，微信小程序等。</li>
<li>精准营销。利用历史数据对用户进行分析，提供个性化服务。</li>
<li>……</li>
</ul>
<p>这些活动都需要程序开发的支持。小明拉了同学小红加入团队。小红负责数据分析以及移动端相关开发。小明负责促销活动相关功能的开发。</p>
<p>因为开发任务比较紧迫，小明小红没有好好规划整个系统的架构，随便拍了拍脑袋，决定把促销管理和数据分析放在管理后台里，微信和移动端APP另外搭建。通宵了几天后，新功能和新应用基本完工。这时架构图如下：</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210429013341.png"></p>
<p>这一阶段存在很多不合理的地方：</p>
<ul>
<li>网站和移动端应用有很多相同业务逻辑的重复代码。</li>
<li>数据有时候通过数据库共享，有时候通过接口调用传输。接口调用关系杂乱。</li>
<li>单个应用为了给其他应用提供接口，渐渐地越改越大，包含了很多本来就不属于它的逻辑。应用边界模糊，功能归属混乱。</li>
<li>管理后台在一开始的设计中保障级别较低。加入数据分析和促销管理相关功能后出现性能瓶颈，影响了其他应用。</li>
<li>数据库表结构被多个应用依赖，无法重构和优化。</li>
<li>所有应用都在一个数据库上操作，数据库出现性能瓶颈。特别是数据分析跑起来的时候，数据库性能急剧下降。</li>
<li>开发、测试、部署、维护愈发困难。即使只改动一个小功能，也需要整个应用一起发布。有时候发布会不小心带上了一些未经测试的代码，或者修改了一个功能后，另一个意想不到的地方出错了。为了减轻发布可能产生的问题的影响和线上业务停顿的影响，所有应用都要在凌晨三四点执行发布。发布后为了验证应用正常运行，还得盯到第二天白天的用户高峰期……</li>
<li>团队出现推诿扯皮现象。关于一些公用的功能应该建设在哪个应用上的问题常常要争论很久，最后要么干脆各做各的，或者随便放个地方但是都不维护。</li>
</ul>
<p>尽管有着诸多问题，但也不能否认这一阶段的成果：快速地根据业务变化建设了系统。不过紧迫且繁重的任务容易使人陷入局部、短浅的思维方式，从而做出妥协式的决策。在这种架构中，每个人都只关注在自己的一亩三分地，缺乏全局的、长远的设计。长此以往，系统建设将会越来越困难，甚至陷入不断推翻、重建的循环。</p>
<h2 id="是时候做出改变了"><a href="#是时候做出改变了" class="headerlink" title="是时候做出改变了"></a>是时候做出改变了</h2><p>幸好小明和小红是有追求有理想的好青年。意识到问题后，小明和小红从琐碎的业务需求中腾出了一部分精力，开始梳理整体架构，针对问题准备着手改造。</p>
<blockquote>
<p>要做改造，首先你需要有足够的精力和资源。如果你的需求方（业务人员、项目经理、上司等）很强势地一心追求需求进度，以致于你无法挪出额外的精力和资源的话，那么你可能无法做任何事……</p>
</blockquote>
<p>在编程的世界中，最重要的便是抽象能力。微服务改造的过程实际上也是个抽象的过程。小明和小红整理了网上超市的业务逻辑，抽象出公用的业务能力，做成几个公共服务：</p>
<ul>
<li>用户服务</li>
<li>商品服务</li>
<li>促销服务</li>
<li>订单服务</li>
<li>数据分析服务</li>
</ul>
<p>各个应用后台只需从这些服务获取所需的数据，从而删去了大量冗余的代码，就剩个轻薄的控制层和前端。这一阶段的架构如下：</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210429013513.png"></p>
<p>这个阶段只是将服务分开了，数据库依然是共用的，所以一些烟囱式系统的缺点仍然存在：</p>
<ol>
<li>数据库成为性能瓶颈，并且有单点故障的风险。</li>
<li>数据管理趋向混乱。即使一开始有良好的模块化设计，随着时间推移，总会有一个服务直接从数据库取另一个服务的数据的现象。</li>
<li>数据库表结构可能被多个服务依赖，牵一发而动全身，很难调整。</li>
</ol>
<p>如果一直保持共用数据库的模式，则整个架构会越来越僵化，失去了微服务架构的意义。因此小明和小红一鼓作气，把数据库也拆分了。所有持久化层相互隔离，由各个服务自己负责。另外，为了提高系统的实时性，加入了消息队列机制。架构如下：</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210429013552.png"></p>
<p>完全拆分后各个服务可以采用异构的技术。比如数据分析服务可以使用数据仓库作为持久化层，以便于高效地做一些统计计算；商品服务和促销服务访问频率比较大，因此加入了缓存机制等。</p>
<blockquote>
<p>还有一种抽象出公共逻辑的方法是把这些公共逻辑做成公共的框架库。这种方法可以减少服务调用的性能损耗。但是这种方法的管理成本非常高昂，很难保证所有应用版本的一致性。</p>
</blockquote>
<blockquote>
<p>数据库拆分也有一些问题和挑战：比如说跨库级联的需求，通过服务查询数据颗粒度的粗细问题等。但是这些问题可以通过合理的设计来解决。总体来说，数据库拆分是一个利大于弊的。</p>
</blockquote>
<p>微服务架构还有一个技术外的好处，它使整个系统的分工更加明确，责任更加清晰，每个人专心负责为其他人提供更好的服务。在单体应用的时代，公共的业务功能经常没有明确的归属。最后要么各做各的，每个人都重新实现了一遍；要么是随机一个人（一般是能力比较强或者比较热心的人）做到他负责的应用里面。在后者的情况下，这个人在负责自己应用之外，还要额外负责给别人提供这些公共的功能——而这个功能本来是无人负责的，仅仅因为他能力较强&#x2F;比较热心，就莫名地背锅（这种情况还被美其名曰能者多劳）。结果最后大家都不愿意提供公共的功能。长此以往，团队里的人渐渐变得各自为政，不再关心全局的架构设计。</p>
<p>从这个角度上看，使用微服务架构同时也需要组织结构做相应的调整。所以说做微服务改造需要管理者的支持。</p>
<p>改造完成后，小明和小红分清楚各自的锅。两人十分满意，一切就像是麦克斯韦方程组一样漂亮完美。</p>
<p>然而……</p>
<h2 id="没有银弹"><a href="#没有银弹" class="headerlink" title="没有银弹"></a>没有银弹</h2><p>春天来了，万物复苏，又到了一年一度的购物狂欢节。眼看着日订单数量蹭蹭地上涨，小皮小明小红喜笑颜开。可惜好景不长，乐极生悲，突然嘣的一下，系统挂了。</p>
<p>以往单体应用，排查问题通常是看一下日志，研究错误信息和调用堆栈。而微服务架构整个应用分散成多个服务，定位故障点非常困难。小明一个台机器一台机器地查看日志，一个服务一个服务地手工调用。经过十几分钟的查找，小明终于定位到故障点：促销服务由于接收的请求量太大而停止响应了。其他服务都直接或间接地会调用促销服务，于是也跟着宕机了。在微服务架构中，一个服务故障可能会产生雪崩效用，导致整个系统故障。其实在节前，小明和小红是有做过请求量评估的。按照预计，服务器资源是足以支持节日的请求量的，所以肯定是哪里出了问题。不过形势紧急，随着每一分每一秒流逝的都是白花花的银子，因此小明也没时间排查问题，当机立断在云上新建了几台虚拟机，然后一台一台地部署新的促销服务节点。几分钟的操作后，系统总算是勉强恢复正常了。整个故障时间内估计损失了几十万的销售额，三人的心在滴血……</p>
<p>事后，小明简单写了个日志分析工具（量太大了，文本编辑器几乎打不开，打开了肉眼也看不过来），统计了促销服务的访问日志，发现在故障期间，商品服务由于代码问题，在某些场景下会对促销服务发起大量请求。这个问题并不复杂，小明手指抖一抖，修复了这个价值几十万的Bug。</p>
<p>问题是解决了，但谁也无法保证不会再发生类似的其他问题。微服务架构虽然逻辑设计上看是完美的，但就像积木搭建的华丽宫殿一样，经不起风吹草动。微服务架构虽然解决了旧问题，也引入了新的问题：</p>
<ul>
<li>微服务架构整个应用分散成多个服务，定位故障点非常困难。</li>
<li>稳定性下降。服务数量变多导致其中一个服务出现故障的概率增大，并且一个服务故障可能导致整个系统挂掉。事实上，在大访问量的生产场景下，故障总是会出现的。</li>
<li>服务数量非常多，部署、管理的工作量很大。</li>
<li>开发方面：如何保证各个服务在持续开发的情况下仍然保持协同合作。</li>
<li>测试方面：服务拆分后，几乎所有功能都会涉及多个服务。原本单个程序的测试变为服务间调用的测试。测试变得更加复杂。</li>
</ul>
<p>小明小红痛定思痛，决心好好解决这些问题。对故障的处理一般从两方面入手，一方面尽量减少故障发生的概率，另一方面降低故障造成的影响。</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210429013806.png"></p>
<h2 id="监控-发现故障的征兆"><a href="#监控-发现故障的征兆" class="headerlink" title="监控 - 发现故障的征兆"></a>监控 - 发现故障的征兆</h2><p>在高并发分布式的场景下，故障经常是突然间就雪崩式爆发。所以必须建立完善的监控体系，尽可能发现故障的征兆。</p>
<p>微服务架构中组件繁多，各个组件所需要监控的指标不同。比如Redis缓存一般监控占用内存值、网络流量，数据库监控连接数、磁盘空间，业务服务监控并发数、响应延迟、错误率等。因此如果做一个大而全的监控系统来监控各个组件是不大现实的，而且扩展性会很差。一般的做法是让各个组件提供报告自己当前状态的接口（metrics接口），这个接口输出的数据格式应该是一致的。然后部署一个指标采集器组件，定时从这些接口获取并保持组件状态，同时提供查询服务。最后还需要一个UI，从指标采集器查询各项指标，绘制监控界面或者根据阈值发出告警。</p>
<p>大部分组件都不需要自己动手开发，网络上有开源组件。小明下载了RedisExporter和MySQLExporter，这两个组件分别提供了Redis缓存和MySQL数据库的指标接口。微服务则根据各个服务的业务逻辑实现自定义的指标接口。然后小明采用Prometheus作为指标采集器，Grafana配置监控界面和邮件告警。这样一套微服务监控系统就搭建起来了：</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210429013846.png"></p>
<h2 id="定位问题-链路跟踪"><a href="#定位问题-链路跟踪" class="headerlink" title="定位问题 - 链路跟踪"></a>定位问题 - 链路跟踪</h2><p>在微服务架构下，一个用户的请求往往涉及多个内部服务调用。为了方便定位问题，需要能够记录每个用户请求时，微服务内部产生了多少服务调用，及其调用关系。这个叫做链路跟踪。</p>
<p>我们用一个Istio文档里的链路跟踪例子来看看效果：</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210429013914.png"></p>
<blockquote>
<p>图片来自Istio文档</p>
</blockquote>
<p>从图中可以看到，这是一个用户访问productpage页面的请求。在请求过程中，productpage服务顺序调用了details和reviews服务的接口。而reviews服务在响应过程中又调用了ratings的接口。整个链路跟踪的记录是一棵树：</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210429013942.png"></p>
<p>要实现链路跟踪，每次服务调用会在HTTP的HEADERS中记录至少记录四项数据：</p>
<ul>
<li>traceId：traceId标识一个用户请求的调用链路。具有相同traceId的调用属于同一条链路。</li>
<li>spanId：标识一次服务调用的ID，即链路跟踪的节点ID。</li>
<li>parentId：父节点的spanId。</li>
<li>requestTime &amp; responseTime：请求时间和响应时间。</li>
</ul>
<p>另外，还需要调用日志收集与存储的组件，以及展示链路调用的UI组件。</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210429014236.png"></p>
<p>以上只是一个极简的说明，关于链路跟踪的理论依据可详见Google的Dapper</p>
<p>了解了理论基础后，小明选用了Dapper的一个开源实现Zipkin。然后手指一抖，写了个HTTP请求的拦截器，在每次HTTP请求时生成这些数据注入到HEADERS，同时异步发送调用日志到Zipkin的日志收集器中。这里额外提一下，HTTP请求的拦截器，可以在微服务的代码中实现，也可以使用一个网络代理组件来实现（不过这样子每个微服务都需要加一层代理）。</p>
<p>链路跟踪只能定位到哪个服务出现问题，不能提供具体的错误信息。查找具体的错误信息的能力则需要由日志分析组件来提供。</p>
<h2 id="分析问题-日志分析"><a href="#分析问题-日志分析" class="headerlink" title="分析问题 - 日志分析"></a>分析问题 - 日志分析</h2><p>日志分析组件应该在微服务兴起之前就被广泛使用了。即使单体应用架构，当访问数变大、或服务器规模增多时，日志文件的大小会膨胀到难以用文本编辑器进行访问，更糟的是它们分散在多台服务器上面。排查一个问题，需要登录到各台服务器去获取日志文件，一个一个地查找（而且打开、查找都很慢）想要的日志信息。</p>
<p>因此，在应用规模变大时，我们需要一个日志的“搜索引擎”。以便于能准确的找到想要的日志。另外，数据源一侧还需要收集日志的组件和展示结果的UI组件：</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210429014313.png"></p>
<p>小明调查了一下，使用了大名鼎鼎地ELK日志分析组件。ELK是Elasticsearch、Logstash和Kibana三个组件的缩写。</p>
<ul>
<li>Elasticsearch：搜索引擎，同时也是日志的存储。</li>
<li>Logstash：日志采集器，它接收日志输入，对日志进行一些预处理，然后输出到Elasticsearch。</li>
<li>Kibana：UI组件，通过Elasticsearch的API查找数据并展示给用户。</li>
</ul>
<p>最后还有一个小问题是如何将日志发送到Logstash。一种方案是在日志输出的时候直接调用Logstash接口将日志发送过去。这样一来又（咦，为啥要用“又”）要修改代码……于是小明选用了另一种方案：日志仍然输出到文件，每个服务里再部署个Agent扫描日志文件然后输出给Logstash。</p>
<h2 id="网关（服务治理）-权限控制"><a href="#网关（服务治理）-权限控制" class="headerlink" title="网关（服务治理） - 权限控制"></a>网关（服务治理） - 权限控制</h2><p>拆分成微服务后，出现大量的服务，大量的接口，使得整个调用关系乱糟糟的。经常在开发过程中，写着写着，忽然想不起某个数据应该调用哪个服务。或者写歪了，调用了不该调用的服务，本来一个只读的功能结果修改了数据……</p>
<p>为了应对这些情况，微服务的调用需要一个把关的东西，也就是网关。在调用者和被调用者中间加一层网关，每次调用时进行权限校验。另外，网关也可以作为一个提供服务接口文档的平台。</p>
<p>使用网关有一个问题就是要决定在多大粒度上使用：最粗粒度的方案是整个微服务一个网关，微服务外部通过网关访问微服务，微服务内部则直接调用；最细粒度则是所有调用，不管是微服务内部调用或者来自外部的调用，都必须通过网关。折中的方案是按照业务领域将微服务分成几个区，区内直接调用，区间通过网关调用。</p>
<p>由于整个网上超市的服务数量还不算特别多，小明采用的最粗粒度的方案：</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210429014448.png"></p>
<h2 id="服务注册与发现-动态扩容"><a href="#服务注册与发现-动态扩容" class="headerlink" title="服务注册与发现 - 动态扩容"></a>服务注册与发现 - 动态扩容</h2><p>前面的组件，都是旨在降低故障发生的可能性。然而故障总是会发生的，所以另一个需要研究的是如何降低故障产生的影响。</p>
<p>最粗暴的（也是最常用的）故障处理策略就是冗余。一般来说，一个服务都会部署多个实例，这样一来能够分担压力提高性能，二来即使一个实例挂了其他实例还能响应。</p>
<p>冗余的一个问题是使用几个冗余？这个问题在时间轴上并没有一个切确的答案。根据服务功能、时间段的不同，需要不同数量的实例。比如在平日里，可能4个实例已经够用；而在促销活动时，流量大增，可能需要40个实例。因此冗余数量并不是一个固定的值，而是根据需要实时调整的。</p>
<p>一般来说新增实例的操作为：</p>
<ol>
<li>部署新实例</li>
<li>将新实例注册到负载均衡或DNS上</li>
</ol>
<p>操作只有两步，但如果注册到负载均衡或DNS的操作为人工操作的话，那事情就不简单了。想想新增40个实例后，要手工输入40个IP的感觉……</p>
<p>解决这个问题的方案是服务自动注册与发现。首先，需要部署一个服务发现服务，它提供所有已注册服务的地址信息的服务。DNS也算是一种服务发现服务。然后各个应用服务在启动时自动将自己注册到服务发现服务上。并且应用服务启动后会实时（定期）从服务发现服务同步各个应用服务的地址列表到本地。服务发现服务也会定期检查应用服务的健康状态，去掉不健康的实例地址。这样新增实例时只需要部署新实例，实例下线时直接关停服务即可，服务发现会自动检查服务实例的增减。</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210429014539.png"></p>
<p>服务发现还会跟客户端负载均衡配合使用。由于应用服务已经同步服务地址列表在本地了，所以访问微服务时，可以自己决定负载策略。甚至可以在服务注册时加入一些元数据（服务版本等信息），客户端负载则根据这些元数据进行流量控制，实现A&#x2F;B测试、蓝绿发布等功能。</p>
<p>服务发现有很多组件可以选择，比如说Zookeeper 、Eureka、Consul、Etcd等。不过小明觉得自己水平不错，想炫技，于是基于Redis自己写了一个……</p>
<h2 id="熔断、服务降级、限流"><a href="#熔断、服务降级、限流" class="headerlink" title="熔断、服务降级、限流"></a>熔断、服务降级、限流</h2><p><strong>熔断</strong></p>
<p>当一个服务因为各种原因停止响应时，调用方通常会等待一段时间，然后超时或者收到错误返回。如果调用链路比较长，可能会导致请求堆积，整条链路占用大量资源一直在等待下游响应。所以当多次访问一个服务失败时，应熔断，标记该服务已停止工作，直接返回错误。直至该服务恢复正常后再重新建立连接。</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210429014623.png"></p>
<blockquote>
<p>图片来自《微服务设计》</p>
</blockquote>
<h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><p>当下游服务停止工作后，如果该服务并非核心业务，则上游服务应该降级，以保证核心业务不中断。比如网上超市下单界面有一个推荐商品凑单的功能，当推荐模块挂了后，下单功能不能一起挂掉，只需要暂时关闭推荐功能即可。</p>
<h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>一个服务挂掉后，上游服务或者用户一般会习惯性地重试访问。这导致一旦服务恢复正常，很可能因为瞬间网络流量过大又立刻挂掉，在棺材里重复着仰卧起坐。因此服务需要能够自我保护——限流。限流策略有很多，最简单的比如当单位时间内请求数过多时，丢弃多余的请求。另外，也可以考虑分区限流。仅拒绝来自产生大量请求的服务的请求。例如商品服务和订单服务都需要访问促销服务，商品服务由于代码问题发起了大量请求，促销服务则只限制来自商品服务的请求，来自订单服务的请求则正常响应。</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210429014705.png"></p>
<p>测试</p>
<p>微服务架构下，测试分为三个层次：</p>
<ul>
<li>端到端测试：覆盖整个系统，一般在用户界面机型测试。</li>
<li>服务测试：针对服务接口进行测试。</li>
<li>单元测试：针对代码单元进行测试。</li>
</ul>
<p>三种测试从上到下实施的容易程度递增，但是测试效果递减。端到端测试最费时费力，但是通过测试后我们对系统最有信心。单元测试最容易实施，效率也最高，但是测试后不能保证整个系统没有问题。</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210429014755.png"></p>
<p>由于端到端测试实施难度较大，一般只对核心功能做端到端测试。一旦端到端测试失败，则需要将其分解到单元测试：则分析失败原因，然后编写单元测试来重现这个问题，这样未来我们便可以更快地捕获同样的错误。</p>
<p>服务测试的难度在于服务会经常依赖一些其他服务。这个问题可以通过Mock Server解决：</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210429014812.png"></p>
<p>单元测试大家都很熟悉了。我们一般会编写大量的单元测试（包括回归测试）尽量覆盖所有代码。</p>
<h2 id="微服务框架"><a href="#微服务框架" class="headerlink" title="微服务框架"></a>微服务框架</h2><p>指标接口、链路跟踪注入、日志引流、服务注册发现、路由规则等组件以及熔断、限流等功能都需要在应用服务上添加一些对接代码。如果让每个应用服务自己实现是非常耗时耗力的。基于DRY的原则，小明开发了一套微服务框架，将与各个组件对接的代码和另外一些公共代码抽离到框架中，所有的应用服务都统一使用这套框架进行开发。</p>
<p>使用微服务框架可以实现很多自定义的功能。甚至可以将程序调用堆栈信息注入到链路跟踪，实现代码级别的链路跟踪。或者输出线程池、连接池的状态信息，实时监控服务底层状态。</p>
<p>使用统一的微服务框架有一个比较严重的问题：框架更新成本很高。每次框架升级，都需要所有应用服务配合升级。当然，一般会使用兼容方案，留出一段并行时间等待所有应用服务升级。但是如果应用服务非常多时，升级时间可能会非常漫长。并且有一些很稳定几乎不更新的应用服务，其负责人可能会拒绝升级……因此，使用统一微服务框架需要完善的版本管理方法和开发管理规范。</p>
<h2 id="另一条路-Service-Mesh"><a href="#另一条路-Service-Mesh" class="headerlink" title="另一条路 - Service Mesh"></a>另一条路 - Service Mesh</h2><p>另一种抽象公共代码的方法是直接将这些代码抽象到一个反向代理组件。每个服务都额外部署这个代理组件，所有出站入站的流量都通过该组件进行处理和转发。这个组件被称为Sidecar。</p>
<blockquote>
<p>Sidecar不会产生额外网络成本。Sidecar会和微服务节点部署在同一台主机上并且共用相同的虚拟网卡。所以sidecar和微服务节点的通信实际上都只是通过内存拷贝实现的。</p>
</blockquote>
<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210429014859.png"></p>
<blockquote>
<p>图片来自：Pattern: Service Mesh</p>
</blockquote>
<p>Sidecar只负责网络通信。还需要有个组件来统一管理所有sidecar的配置。在Service Mesh中，负责网络通信的部分叫数据平面（data plane），负责配置管理的部分叫控制平面（control plane）。数据平面和控制平面构成了Service Mesh的基本架构。</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210429014920.png"></p>
<blockquote>
<p>图片来自：Pattern: Service Mesh</p>
</blockquote>
<p>Sevice Mesh相比于微服务框架的优点在于它不侵入代码，升级和维护更方便。它经常被诟病的则是性能问题。即使回环网络不会产生实际的网络请求，但仍然有内存拷贝的额外成本。另外有一些集中式的流量处理也会影响性能。</p>
<h2 id="结束、也是开始"><a href="#结束、也是开始" class="headerlink" title="结束、也是开始"></a>结束、也是开始</h2><p>微服务不是架构演变的终点。往细走还有Serverless、FaaS等方向。另一方面也有人在唱合久必分分久必合，重新发现单体架构……</p>
<p>不管怎样，微服务架构的改造暂时告一段落了。小明满足地摸了摸日益光滑的脑袋，打算这个周末休息一下约小红喝杯咖啡。</p>
<hr>
<blockquote>
<p>文章每周六持续更新，可以微信搜一搜「 haxianha 」抢先阅读。</p>
</blockquote>
<p>最近在知识星球开通了「haxianhe的技术圈」，会在这里和朋友们聊聊技术，一起成长，感兴趣的朋友可以扫码进入。</p>
<p>此外，我会邀请一线大厂的朋友们进来当嘉宾，如果你有想换工作内推的需求或者想了解一下各个大厂业务发展情况等都可以加入进来。（星球暂时已经被我调整为最低价格，后续人数多了之后可能会调整上去）</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/20210429084612.png"></p>
]]></content>
      <categories>
        <category>专业知识</category>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis之数据类型</title>
    <url>/2020/05/06/cs-basic/cs-basic-middleware/Redis-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>Redis 的数据类型有5种，分别是：字符串、列表、哈希表、集合、有序集合。</p>
<p>Redis 的编码（底层实现）有8种，分别是：long 类型的整数、embstr 编码的简单动态字符串、简单动态字符串、字典、双端链表、压缩列表、整数集合、跳跃表和字典。</p>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201021080508.png"></p>
<p><strong>字符串对象的编码可以是 int、raw 或者 embstr。</strong></p>
<p>如果一个字符串对象保存的是整数值，并且这个整数值可以用 long 类型来表示，那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面（将 void* 转换成 long），并将字符串对象的编码设置为 int。</p>
<p>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于39字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。</p>
<p>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于39字节，那么字符串对象将使用 embstr 编码的方式来保存这个字符串值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; set hello world</span><br><span class="line">OK</span><br><span class="line">&gt; get hello</span><br><span class="line">&quot;world&quot;</span><br><span class="line">&gt; del hello</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; get hello</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122193803.png"></p>
<p><strong>列表对象的编码可以是 ziplist 或者 linkedlist。</strong></p>
<p>ziplist 编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点保存了一个列表元素。</p>
<p>linkedlist 编码的列表对象使用双端链表作为底层实现，每个双端链表节点都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; rpush list-key item2</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item2&quot;</span><br><span class="line">3) &quot;item&quot;</span><br><span class="line"></span><br><span class="line">&gt; lindex list-key 1</span><br><span class="line">&quot;item2&quot;</span><br><span class="line"></span><br><span class="line">&gt; lpop list-key</span><br><span class="line">&quot;item&quot;</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) &quot;item2&quot;</span><br><span class="line">2) &quot;item&quot;</span><br></pre></td></tr></table></figure>

<h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122193823.png"></p>
<p><strong>集合对象的编码可以是 intset 或者 hashtable。</strong></p>
<p>intset 编码的集合对象使用整数集合作为底层实现。</p>
<p>hashtable 编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为 NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item3</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item2&quot;</span><br><span class="line">3) &quot;item3&quot;</span><br><span class="line"></span><br><span class="line">&gt; sismember set-key item4</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; sismember set-key item</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item3&quot;</span><br></pre></td></tr></table></figure>

<h5 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h5><p><img src="https://gitee.com/haxianhe/image/raw/master/img/20201020122624.png"></p>
<p><strong>哈希对象的编码可以是 ziplist 或者 hashtable。</strong></p>
<p>ziplist 编码的哈希对象使用压缩列表作为底层实现，每当有新的健值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾。</p>
<p>hashtable 编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都适用一个字典键值对来保存。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset hash-key sub-key2 value2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line">1) &quot;sub-key1&quot;</span><br><span class="line">2) &quot;value1&quot;</span><br><span class="line">3) &quot;sub-key2&quot;</span><br><span class="line">4) &quot;value2&quot;</span><br><span class="line"></span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; hget hash-key sub-key1</span><br><span class="line">&quot;value1&quot;</span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line">1) &quot;sub-key1&quot;</span><br><span class="line">2) &quot;value1&quot;</span><br></pre></td></tr></table></figure>

<h5 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h5><p><img src="https://gitee.com/haxianhe/image/raw/master/img/20201020122737.png"></p>
<p><strong>有序集合对象的编码可以是 ziplist 或者 skiplist。</strong></p>
<p>ziplist 编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个节点保存元素的分值。</p>
<p>skiplist 编码的有序集合对象使用 zset 结构作为底层实现，一个 zset 结构同事包含一个字典和一个跳跃表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; zadd zset-key 728 member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;728&quot;</span><br><span class="line">3) &quot;member0&quot;</span><br><span class="line">4) &quot;982&quot;</span><br><span class="line"></span><br><span class="line">&gt; zrangebyscore zset-key 0 800 withscores</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;728&quot;</span><br><span class="line"></span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) &quot;member0&quot;</span><br><span class="line">2) &quot;982&quot;</span><br></pre></td></tr></table></figure>

<h5 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h5><p><strong>简单动态字符串</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录 buf 数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于 SDS 所保存字符串的长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录 buf 数组中未使用字节的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>图 2-1 展示了一个 SDS 示例：</p>
<ul>
<li>free 属性的值为 0 ， 表示这个 SDS 没有分配任何未使用空间。</li>
<li>len 属性的值为 5 ， 表示这个 SDS 保存了一个五字节长的字符串。</li>
<li>buf 属性是一个 char 类型的数组， 数组的前五个字节分别保存了 ‘R’ 、 ‘e’ 、 ‘d’ 、 ‘i’ 、 ‘s’ 五个字符， 而最后一个字节则保存了空字符 ‘\0’ 。</li>
</ul>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122193847.png"></p>
<p><strong>链表</strong></p>
<p>每个链表节点使用一个 adlist.h&#x2F;listNode 结构来表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line"></span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<p>多个 listNode 可以通过 prev 和 next 指针组成双端链表， 如图 3-1 所示。</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/img/20201020122802.png"></p>
<p>Redis 的链表实现的特性可以总结如下：</p>
<ul>
<li>双端： 链表节点带有 prev 和 next 指针， 获取某个节点的前置节点和后置节点的复杂度都是 O(1) 。</li>
<li>无环： 表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL ， 对链表的访问以 NULL 为终点。</li>
<li>带表头指针和表尾指针： 通过 list 结构的 head 指针和 tail 指针， 程序获取链表的表头节点和表尾节点的复杂度为 O(1) 。</li>
<li>带链表长度计数器： 程序使用 list 结构的 len 属性来对 list 持有的链表节点进行计数， 程序获取链表中节点数量的复杂度为 O(1) 。</li>
<li>多态： 链表节点使用 void* 指针来保存节点值， 并且可以通过 list 结构的 dup 、 free 、 match 三个属性为节点值设置类型特定函数， 所以链表可以用于保存各种不同类型的值。</li>
</ul>
<p><strong>字典</strong></p>
<p>dictht 是一个散列表结构，使用拉链法解决哈希冲突。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p>Redis 的字典 dict 中包含两个哈希表 dictht，这是为了方便进行 rehash 操作。在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p>rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。</p>
<p>渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1] 上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。</p>
<p>在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。</p>
<p>采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Performs N steps of incremental rehashing. Returns 1 if there are still</span></span><br><span class="line"><span class="comment"> * keys to move from the old to the new hash table, otherwise 0 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that a rehashing step consists in moving a bucket (that may have more</span></span><br><span class="line"><span class="comment"> * than one key as we use chaining) from the old to the new hash table, however</span></span><br><span class="line"><span class="comment"> * since part of the hash table may be composed of empty spaces, it is not</span></span><br><span class="line"><span class="comment"> * guaranteed that this function will rehash even a single bucket, since it</span></span><br><span class="line"><span class="comment"> * will visit at max N*10 empty buckets in total, otherwise the amount of</span></span><br><span class="line"><span class="comment"> * work it does would be unbound and the function may block for a long time. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictRehash</span><span class="params">(dict *d, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> empty_visits = n * <span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can&#x27;t overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="type">unsigned</span> <span class="type">long</span>) d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span> (d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            <span class="type">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>跳跃表</strong></p>
<p>是有序集合的底层实现之一。</p>
<p>跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122193914.png"></p>
<p>在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。下图演示了查找 22 的过程。</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122193931.png"></p>
<p>与红黑树等平衡树相比，跳跃表具有以下优点：</p>
<ul>
<li>插入速度非常快速，因为不需要进行旋转等操作来维护平衡性；</li>
<li>更容易实现；</li>
<li>支持无锁操作。</li>
</ul>
<p><strong>整数集合</strong></p>
<p>整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 int16_t 、 int32_t 或者 int64_t 的整数值， 并且保证集合中不会出现重复元素。</p>
<p>每个 intset.h&#x2F;intset 结构表示一个整数集合：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line"></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p>图 6-1 展示了一个整数集合示例：</p>
<ul>
<li>encoding 属性的值为 INTSET_ENC_INT16 ， 表示整数集合的底层实现为 int16_t 类型的数组， 而集合保存的都是 int16_t 类型的整数值。</li>
<li>length 属性的值为 5 ， 表示整数集合包含五个元素。</li>
<li>contents 数组按从小到大的顺序保存着集合中的五个元素。<br>因为每个集合元素都是 int16_t 类型的整数值， 所以 contents 数组的大小等于 sizeof(int16_t) * 5 &#x3D; 16 * 5 &#x3D; 80 位。</li>
</ul>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122193951.png"></p>
<p><strong>压缩列表</strong></p>
<p>压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。</p>
<p>一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值。</p>
<p>图 7-1 展示了压缩列表的各个组成部分， 表 7-1 则记录了各个组成部分的类型、长度、以及用途。</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122194012.png"></p>
<p>图 7-2 展示了一个压缩列表示例：</p>
<ul>
<li>列表 zlbytes 属性的值为 0x50 （十进制 80）， 表示压缩列表的总长为 80 字节。</li>
<li>列表 zltail 属性的值为 0x3c （十进制 60）， 这表示如果我们有一个指向压缩列表起始地址的指针 p ， 那么只要用指针 p 加上偏移量 60 ， 就可以计算出表尾节点 entry3 的地址。</li>
<li>列表 zllen 属性的值为 0x3 （十进制 3）， 表示压缩列表包含三个节点。</li>
</ul>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122194029.png"></p>
]]></content>
      <categories>
        <category>专业知识</category>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>专业主义——读《代码整洁之道》</title>
    <url>/2018/12/29/book-notes/book-notes-computer/%E4%B8%93%E4%B8%9A%E4%B8%BB%E4%B9%89%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B/</url>
    <content><![CDATA[<p>这是一本写给专业人士看的书。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwly1fynmbo4prhj30u00vz7g7.jpg"></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>具体情况具体分析-读《大败局 I》</title>
    <url>/2022/10/15/book-notes/book-notes-economic/%E5%85%B7%E4%BD%93%E6%83%85%E5%86%B5%E5%85%B7%E4%BD%93%E5%88%86%E6%9E%90-%E8%AF%BB%E3%80%8A%E5%A4%A7%E8%B4%A5%E5%B1%80%E3%80%8B/</url>
    <content><![CDATA[<h2 id="一、作者"><a href="#一、作者" class="headerlink" title="一、作者"></a>一、作者</h2><p>吴晓波，<a href="https://baike.baidu.com/item/%E8%B4%A2%E7%BB%8F%E4%BD%9C%E5%AE%B6/59988690?fromModule=lemma_inlink">财经作家</a>，广东<a href="https://baike.baidu.com/item/%E6%A2%85%E5%8E%BF/3188901?fromModule=lemma_inlink">梅县</a>人，1968年9月9日出生于浙江<a href="https://baike.baidu.com/item/%E5%AE%81%E6%B3%A2/209476?fromModule=lemma_inlink">宁波</a>，<a href="https://baike.baidu.com/item/%E5%93%88%E4%BD%9B%E5%A4%A7%E5%AD%A6/261536?fromModule=lemma_inlink">哈佛大学</a>访问学者，“蓝狮子”财经图书出版人。曾任<a href="https://baike.baidu.com/item/%E4%B8%8A%E6%B5%B7%E4%BA%A4%E9%80%9A%E5%A4%A7%E5%AD%A6/131671?fromModule=lemma_inlink">上海交通大学</a>、<a href="https://baike.baidu.com/item/%E6%9A%A8%E5%8D%97%E5%A4%A7%E5%AD%A6/154250?fromModule=lemma_inlink">暨南大学</a>EMBA课程<a href="https://baike.baidu.com/item/%E6%95%99%E6%8E%88/18291?fromModule=lemma_inlink">教授</a>，常年从事公司研究。</p>
<p>毕业于<a href="https://baike.baidu.com/item/%E5%A4%8D%E6%97%A6%E5%A4%A7%E5%AD%A6/111790?fromModule=lemma_inlink">复旦大学</a>新闻系，毕业后开始了他长达13年的商业记者生涯。2001年吴晓波出版的《<a href="https://baike.baidu.com/item/%E5%A4%A7%E8%B4%A5%E5%B1%80/1720289?fromModule=lemma_inlink">大败局</a>》证明了严肃的商业写作也能够跻身畅销书行列。而他辛苦经营两年的蓝狮子财经丛书则成为中国本土财经书籍出版的最著名的品牌之一。他的时间被划分为几块，主要的精力用在<a href="https://baike.baidu.com/item/%E5%87%BA%E7%89%88/285005?fromModule=lemma_inlink">出版</a>事业上，同时还坚持以每年写作一本书的速度向外界传达自己的观念。</p>
<p>2009年被《<a href="https://baike.baidu.com/item/%E5%8D%97%E6%96%B9%E4%BA%BA%E7%89%A9%E5%91%A8%E5%88%8A/6810693?fromModule=lemma_inlink">南方人物周刊</a>》评为年度“中国青年领袖”，2014<a href="https://baike.baidu.com/item/%E7%99%BE%E5%BA%A6moments%E8%90%A5%E9%94%80%E7%9B%9B%E5%85%B8/16040542?fromModule=lemma_inlink">百度moments营销盛典</a>最具品牌价值<a href="https://baike.baidu.com/item/%E8%B4%A2%E7%BB%8F%E4%BD%9C%E5%AE%B6/59988690?fromModule=lemma_inlink">财经作家</a>榜首。</p>
<p>2015年7月27日，成为<a href="https://baike.baidu.com/item/%E7%BB%BF%E5%9C%B0%E6%8E%A7%E8%82%A1%E8%82%A1%E4%BB%BD%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8/18482979?fromModule=lemma_inlink">绿地控股股份有限公司</a>独董候选人。 [2]  2021年10月，首档社交分享综艺，《<a href="https://baike.baidu.com/item/%E5%9B%BD%E8%B4%A7%E6%BD%AE%E8%B5%B7%E6%9D%A5/58975315?fromModule=lemma_inlink">国货潮起来</a>》诚意搭建了一个社交平台——国潮快闪店，邀请吴晓波担任店长。 [7] </p>
<p>著有多本具有影响力的图书：</p>
<ul>
<li>《大败局 I》《大败局 II》</li>
<li>《激荡三十年》（上）（下）</li>
<li>《腾讯传》</li>
<li>《历代经济变革得失》</li>
</ul>
<h2 id="二、共同的失败基因"><a href="#二、共同的失败基因" class="headerlink" title="二、共同的失败基因"></a>二、共同的失败基因</h2><ol>
<li>普遍缺乏道德感和人文关怀意识</li>
<li>普遍缺乏对规律和秩序的尊重</li>
<li>普遍缺乏系统的职业精神</li>
</ol>
<h2 id="三、具体情况具体分析"><a href="#三、具体情况具体分析" class="headerlink" title="三、具体情况具体分析"></a>三、具体情况具体分析</h2><p>书中总结了这些企业共同的失败原因，但是成也萧何，败也萧何，这些企业本就是靠着这些失败原因发展起来的，又怎么能简单的说是因为这些原因失败的呢？</p>
<p>引用人民日报的一句话：</p>
<blockquote>
<p>“没有所谓的马云的时代，只有时代中的马云。”</p>
</blockquote>
<p>就连我党在不同的历史阶段也会重新审视我国社会的当时的主要矛盾。那么一个企业就更应该在不同的发展阶段去重新审视大环境是否变化，企业经营策略是否需要调整等。</p>
<p>这本书通篇读下来，最大的一个感触就是这些失败的案例最典型的一个特征就是成功之后没有及时跟进调整自己企业的经营策略，过分依赖早先经营成功的秘籍，十分可惜。</p>
<p>马克·吐温（查理·芒格）说：”<strong>手里拿着锤子，看什么都像钉子</strong>。”</p>
<p>当我们大脑里面只有一种思维或者工具或者方法时，我们做任何事都会用这种思维或者工具或者方法来解决和分析。其实就是一种固化单一的思维方式。</p>
<p>用矛盾论的话来说就是：“在事物发展的不同阶段，有着不同的矛盾，这些矛盾，不但各各有其特殊性，不能一律看待，而且每一矛盾的两方面，又各各有其特点，也是不能一律看待的。”</p>
<p>列宁说：马克思主义的最本质的东西，马克思主义的活的灵魂，就在于具体地分析具体的情况。</p>
<h2 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h2><ul>
<li><a href="https://baike.baidu.com/item/%E5%90%B4%E6%99%93%E6%B3%A2/29563">吴晓波-百度百科</a></li>
<li><a href="https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-193708.htm">《矛盾论》</a></li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>明确目标 - 读《吃掉那只青蛙》</title>
    <url>/2019/01/03/book-notes/book-notes-economic/%E5%90%83%E6%8E%89%E9%82%A3%E5%8F%AA%E9%9D%92%E8%9B%99/</url>
    <content><![CDATA[<p>最近在‘微信读书’上读了佳昌给我推荐的《吃掉那只青蛙》这本书。</p>
<p>这是一本提高个人效率方面的入门书籍，整体内容简洁明了（虽然我觉得书中的后半部分我早就掌握了），推荐！</p>
<p><a href="https://book.douban.com/subject/27130739/">吃掉那只青蛙</a></p>
<h1 id="明确目标"><a href="#明确目标" class="headerlink" title="明确目标"></a>明确目标</h1><ul>
<li>第一步：明确你究竟想要什么。</li>
<li>第二步：把你的目标写下来。</li>
<li>第三步：为你的目标设定一个完成的最后期限；在必要的情况下，设定出子目标的期限。</li>
<li>第四步：为了实现目标，把你所能想到的、所有要完成的事项都列在一个清单上。</li>
<li>第五步：进一步梳理整个清单，使之成为一份计划。根据优先级顺序来整理计划。</li>
<li>第六步：根据计划马上采取行动。</li>
<li>第七步：每天解决一部分问题，向前推进主要目标的实现。</li>
</ul>
<p>目标是“成就”这座大熔炉中的燃料。你的目标越长远、越明确，在你越来越接近目标的时候你会愈发充满激情。你对自己的目标思考的越严密，实现目标的内在动力和欲望就越强烈。</p>
<p>每一天，你都需要反复思考并检查你制定的这些目标。每天早晨，从当下最有助于实现你最重要目标的最重要的任务开始工作。</p>
<blockquote>
<p>人之所以会迷茫，就是因为目标不明确，不知道自己该何去何从。</p>
</blockquote>
<h1 id="制定计划"><a href="#制定计划" class="headerlink" title="制定计划"></a>制定计划</h1><blockquote>
<p>通过计划把未来变成现在，这样你就可以未雨绸缪。</p>
</blockquote>
<p>在采取行动之前制定计划的能力，是你衡量自身综合能力的一个基本标准。计划制定的越周密，你就越容易客服同验证、迅速行动、吃掉青蛙，并能不间断地保持行动的状态。</p>
<p>在开始工作之前先坐下来，把你要做的每一件事情都逐条写出来。</p>
<p>无论你准备做什么，都应该先列出一份清单。每次想到什么新的事项，在开始做之前都把它加在清单上。</p>
<p>根据不同的目标制定不同的计划。比如，你可以有总计划（人生目标）、月计划、周计划、日计划等。</p>
<h1 id="成为一个乐观主义者"><a href="#成为一个乐观主义者" class="headerlink" title="成为一个乐观主义者"></a>成为一个乐观主义者</h1><p>为了不断地激励自己，你必须成为一位乐观主义者，必须以积极的态度面对周围的环境，应对别人的言行。生活中的挫折和困难是不可避免的，但是你决不能让这些影响到你的情绪。</p>
<p>如果别人问你此刻感觉如何，你一定要告诉他们：“我感觉棒极了！”</p>
<p>无论你的真是感受如何，也无论生活中发生了什么事情，都一定要保持心情愉快，永不低头。</p>
<p>“人类的终极自由是在现有的任何一种环境中选择做自己的态度”</p>
<p>不要想别人抱怨你有多大的问题，而是要把这一切都埋在心里。幽默大师艾德·福尔曼曾经说过：<strong>“永远不要把你的困难告诉别人，因为80%的人对你的困难不感兴趣，而另外20%的人也许会对你的遭遇感到幸灾乐祸。”</strong></p>
<p><strong>乐观主义者的四个显著特征：</strong></p>
<ol>
<li>乐观主义者在任何情况下都回去事情好的一面。</li>
<li>乐观主义者总是能从挫折和困难中总结经验，吸取教训。</li>
<li>乐观主义者总是极力找出问题的解决方法。</li>
<li>积极性格，乐观的人会不断的思考和谈论他们的目标。</li>
</ol>
<blockquote>
<p>吃掉那只青蛙<br>1.控制自己的思想，让自己总是保持积极的态度。记住，你会成为你想成为的那个人，所以，只说你想说的，只做你想做的。<br>2.勇于面对现实、承担责任，是自己保持积极的心态。无论遇到什么事情，都不要去批评、埋怨、指责别人。去改善，而不是责怪。集中思想和精力向前看，不要理会其他。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在书中作者一共提到了21点，以上是我觉得对我有帮助的几点。</p>
<p>总的来说，作为一本个人效率方面的入门书籍，这本书还是很棒的。我在豆瓣上给这本书打了4分，推荐给大家。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>存钱大作战 - 读《工作前5年，决定你一生的财富》</title>
    <url>/2019/01/07/book-notes/book-notes-economic/%E5%B7%A5%E4%BD%9C%E5%89%8D5%E5%B9%B4%EF%BC%8C%E5%86%B3%E5%AE%9A%E4%BD%A0%E4%B8%80%E7%94%9F%E7%9A%84%E8%B4%A2%E5%AF%8C/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>这本书的作者是很平凡，也很不平凡的一个女生。</p>
<p>说她平凡是她拿着平凡的工资，甚至毕业前做着和大多数人一样的事情（用家里给的钱来享受大学的生活）。</p>
<p>说她不平凡，一方面是因为刚工作的她，竟能因为不想让家里人对自己的事指手画脚而萌生理财的想法，这很不简单。另一方面是因为她有一个好的家庭背景，让她的理财之路具有不可复制性（不可复制不代表不可借鉴）。</p>
<p>文章稍微有一点啰嗦，总的来说：</p>
<p>第一阶段：<strong>存钱、记账</strong><br>第二阶段：基金<br>第三阶段：股票</p>
<p>此外，作者的一句话我觉得要和大家分享一下：<strong>“找到一本好的书籍后，在阅读完书，做好笔记后，会得到两个附赠礼物，一是通过网络去寻找作者的其他作品，二是查询并且阅读全书中提及或者推荐的其他好书。”</strong></p>
<p><strong>“所谓辐射阅读，就是利用一个核心点去找寻跟它相关的其他好书”</strong></p>
<p>不可否认的是，这本书的作者给我提供了一份非常明确的理财入门路线，在此，表示感谢！</p>
<h1 id="存钱、记账"><a href="#存钱、记账" class="headerlink" title="存钱、记账"></a>存钱、记账</h1><p>在书中，作者是从理财动机开始介绍的，这里我就不具体展开了，感兴趣的朋友可以自己去看看。</p>
<p>几句觉得很棒的话：</p>
<blockquote>
<p>1、尊严的生活，需要独立的经济来护佑；自由的选择，需要独立的经济来保障。<br>2、有钱在手，如一技傍身。<br>3、经济不独立又何来生活的独立，财务不自由又怎么会有生活的自由！<br>4、当我们在校园的时候，金钱并不会扮演太过重要的角色，它会点缀校园生活，却不会决定校园生活。但当我们走进社会，金钱在每一个人生活中的影响力会以难以置信的速度变得重要起来。<br>5、没钱的世界，有时候真的寸步难行。用一句时髦的话来说就是：有钱才能任性；没钱，想任性也任性不起来。<br>6、生活中很多的高质量需要金钱为之买单，生活中很多梦想需要金钱为之付账。<br>7、**每个人对于旅游的定义不一样，在他人哪里可能是“穷游，体验人生”，而在我这里就是“旅游，享受生活”。       **</p>
</blockquote>
<p>“如何理财”不是最关键的，“如何让人有财可以理”才是重要的。</p>
<p><strong>关于“钱是挣出来的，不是攒出来的”的问题。</strong></p>
<p>不可否认，想拥有巨额财产，甚至说，想拥有千万级别的资产，这确实不是靠“攒钱”就能够实现。就好比，仅靠一份10万元一年死工资的工作，不吃不喝，在退休的时候也无法实现积攒到1000万元。但认识一个道理不能用僵化的思维，也不能用固执的视角来认识。</p>
<p>在有些人看来，“攒钱”毫无用处，能够让他发财的方式只有一种，那就是“挣钱”。可是他忘了“挣大钱”需要有两个重要条件。第一是“原始资金”，第二是“守财之道”。</p>
<h2 id="作者的存钱方式：先从工资的50-开始"><a href="#作者的存钱方式：先从工资的50-开始" class="headerlink" title="作者的存钱方式：先从工资的50%开始"></a>作者的存钱方式：先从工资的50%开始</h2><p>首先准备好三张银行卡，一张用来日常消费，一张用来存放应急资金，一张用来存放定期存款。</p>
<table>
<thead>
<tr>
<th>银行卡</th>
<th>用途</th>
<th>工资占比</th>
</tr>
</thead>
<tbody><tr>
<td>工商银行卡</td>
<td>日常消费</td>
<td>30%</td>
</tr>
<tr>
<td>广发银行</td>
<td>应急资金</td>
<td>20%</td>
</tr>
<tr>
<td>招商银行</td>
<td>定期存款</td>
<td>50%</td>
</tr>
</tbody></table>
<h2 id="将消费支出控制起来"><a href="#将消费支出控制起来" class="headerlink" title="将消费支出控制起来"></a>将消费支出控制起来</h2><p><strong>整理消费清单</strong><br>对于每个月的工资，必须先弄清楚每月必须用于消费的钱有多少？</p>
<p>固定支出：房租</p>
<p>变动支出：<br>一日三餐、水果零食、通信费用、交通费用、娱乐聚餐费用、购书费用、宠物费用</p>
<p><strong>记账</strong></p>
<p><strong>预算</strong></p>
<h1 id="投资正式入门：基金"><a href="#投资正式入门：基金" class="headerlink" title="投资正式入门：基金"></a>投资正式入门：基金</h1><p>个人比较看到的几个基金：    </p>
<ul>
<li>中概互联</li>
<li>上证50</li>
<li>中概500</li>
</ul>
<h1 id="投资进阶：股票"><a href="#投资进阶：股票" class="headerlink" title="投资进阶：股票"></a>投资进阶：股票</h1><p>此部分书中介绍了一份书单，还有一些对作者影响比较大的文章、网络达人、博主等</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>普世智慧 - 读《穷查理宝典》</title>
    <url>/2019/03/19/book-notes/book-notes-economic/%E7%A9%B7%E6%9F%A5%E7%90%86%E5%AE%9D%E5%85%B8/</url>
    <content><![CDATA[<h1 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h1><p>最近读了《穷查理宝典》，这本书以过去20年间查理·芒格 (Charles Thomas Munger) 主要做过的公开演讲为主要内容。</p>
<blockquote>
<p>Charles Thomas Munger (born January 1, 1924) is an American investor, businessman and philanthropist. He is vice chairman of Berkshire Hathaway, the conglomerate controlled by Warren Buffett; Buffett has described Munger as his partner. Munger served as chairman of Wesco Financial Corporation From 1984 through 2011. He is also chairman of the Daily Journal Corporation, based in Los Angeles, California, and a director of Costco Wholesale Corporation.</p>
</blockquote>
<p>这本书不仅介绍了Munger的投资方法，更介绍了Munger的人生智慧，而这正是这本书的珍贵之处，毕竟投资只是人生中的一部分，如果能学会Munger的人生智慧，无疑对过好这一生才更有帮助。</p>
<h1 id="二、逆向思维"><a href="#二、逆向思维" class="headerlink" title="二、逆向思维"></a>二、逆向思维</h1><blockquote>
<p>如果要明白人生如何才能得到幸福，首先研究人生如何才能变得痛苦；研究企业如何做强做大，首先研究企业如何倒掉。生活上的大多数成功来自于你应该知道避免哪些事情（死亡、糟糕的婚姻、艾滋病、吸毒）。</p>
</blockquote>
<p>如何过上痛苦的生活（你没看错）：</p>
<p><strong>第一，要反复无常，不要虔诚的做你正在做的事。</strong></p>
<p>只要养成这个习惯，你们就能绰绰有余的抵消你们所有的优点共同产生的效应，不管那种效应多么巨大。如果你们喜欢不受信任并被排除在对人类贡献最杰出的人群之外。</p>
<p><strong>第二，尽可能从你们自身的经验获得知识，尽量别从其他人成功或失败的经验中广泛的吸取教训，不管他们是古人还是今人。</strong></p>
<p><strong>第三，当你们在人生的战场上遭遇第一、第二或者第三次严重的失败时，就请意志消沉，从此一蹶不振吧。</strong></p>
<p>因为即使是最幸运、最聪明的人，也会遇到许许多多的失败，这味药必定能保证你们永远地陷身在痛苦的泥泽里。</p>
<p><strong>第四，如果想要过上痛苦不堪的日子，请忽略“要是知道我会死在哪里就好了，那我将永远不去那个地方”</strong></p>
<blockquote>
<p>关于这点，《黑天鹅》的作者，纳西姆·尼古拉斯·塔勒布有个类比可以借用：</p>
<ul>
<li>一杯水，放在冰箱里，会冻成冰，那个杯子的形状（水冻成冰之前的形状）可以推测出水冻成冰之后的形状；</li>
<li>可反过来，如果一块儿冰放在桌子上，一会儿化成了水，我们看着那水的形状，无论如何都倒推不出化成水之前的冰究竟是怎样的形状……</li>
</ul>
</blockquote>
<p>我一向认为研究别人的成功很难，因为太多因素其实是隐蔽的；研究别人的失败相对容易，因为有更多更公开的因素可用来研究…… 更为关键的是，<font color=#FF0000><strong>研究他人的失败，比研究他人的成功更有指导意义。</strong></font></p>
<h1 id="三、普世智慧（多元思维模型）"><a href="#三、普世智慧（多元思维模型）" class="headerlink" title="三、普世智慧（多元思维模型）"></a>三、普世智慧（多元思维模型）</h1><blockquote>
<p>其实读到这里，我不得不感慨，知识真的是共同的。但凡有所成就的人，都有一个共同的特点，那就——学习，终身学习。</p>
</blockquote>
<p>“在手里拿着铁锤的人看来，每个问题都像钉子”，这绝对是一种灾难性的思考方式。</p>
<p>现实生活中的问题往往需要多个学科的知识共同作用来解决。而问题是，学校中教你知识的教授，他们中的大多数人也许在自己的领域有足够深的积累，但是往往不具备跨学科的知识、能力。所以，你需要通过自学，自己搭建一个由来自不同学科的思维模型组成的、属于你自己的多思维框架。</p>
<p>当你的思维模型积累的足够多之后，他们能给你带来特别大的力量。当几个模型联合起来，你就能带到lollapalooza效应——这是好几种力量共同作用于同一个方向。</p>
<p>那么都有哪些模型需要掌握呢？</p>
<p>书中Munger给出了如下几个学科：</p>
<ol>
<li>数学以及统计学中的概率论</li>
<li>心理学</li>
<li>经济学</li>
</ol>
<p>在我看来如下的几个学科的思维模型也是必须要掌握的：</p>
<ol start="4">
<li>个人管理</li>
<li>计算机</li>
<li>历史学</li>
<li>哲学</li>
<li>文学</li>
<li>英语</li>
</ol>
<p><font color=#FF0000><strong>投资说到底是一种知识（信息）的较量，所以，你的眼界，你的思维将直接决定着你的投资的成功与否。</strong></font></p>
<h1 id="四、人类误判心理学"><a href="#四、人类误判心理学" class="headerlink" title="四、人类误判心理学"></a>四、人类误判心理学</h1><p>不得不说，Munger在书中介绍的心理学知识真的非常实用，引用Munger的一句话：<strong>“广义的进化（包括基因和文化的进化）早已将这些心理倾向深深地根植于我们无法的大脑里，这些倾向是我们无法摆脱的倾向。”</strong></p>
<p>以下是这些倾向：</p>
<ol>
<li>奖励和惩罚——超级反应倾向</li>
<li>喜欢&#x2F;热爱倾向</li>
<li>讨厌&#x2F;憎恨倾向</li>
<li>避免怀疑倾向</li>
<li>避免不一致倾向</li>
<li>好奇心倾向</li>
<li>康德式公平倾向</li>
<li>艳羡&#x2F;妒忌倾向</li>
<li>回馈倾向</li>
<li>受简单联想影响的倾向</li>
<li>简单的、避免痛苦的心理否认</li>
<li>自视过高倾向</li>
<li>过度乐观倾向</li>
<li>被剥夺超级反应倾向</li>
<li>社会认同倾向</li>
<li>对比错误反应倾向</li>
<li>压力影响倾向</li>
<li>错误衡量易得性倾向</li>
<li>不同就忘倾向</li>
<li>化学物质错误影响倾向</li>
<li>衰老——错误影响倾向</li>
<li>权威——错误影响倾向</li>
<li>废话倾向</li>
<li>重视理由倾向</li>
<li>lollapalooza倾向——数种心理倾向共同作用造成极端后果的倾向</li>
</ol>
<p>就里不对这些倾向进行具体展开，感兴趣的朋友可以自行去看一下。就我个人而言，<strong>这是我看过的最好的心理学入门知识。</strong></p>
<h1 id="五、投资方法"><a href="#五、投资方法" class="headerlink" title="五、投资方法"></a>五、投资方法</h1><p>说到底这还是一本讲投资的书（虽然我觉得它已经远远超出了这个范畴），那我们就来总结以下Munger想要传授给我们的投资心得。</p>
<p> “当沃伦在商学院上裸时，他说：我用一张考勤卡就能改善你最终财富状况；这张卡片上有20格，所以你只能有20次打卡机会————这代表你一生中所能拥有的投资次数。当你把卡打完之后，你就再也不能进行投资了。在这样的规则之下，你将会真正慎重考虑你做的事情，你将不得不花大笔资金在你真正想投资的项目上。这样你的表现将会好得多。”</p>
<p> <font color=#FF0000><strong>我总结一下就是：性格、耐心。而这也是我想要练习理财的初衷——修心。</strong></font></p>
<h1 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h1><p> 通过这本书可以领略到查理·芒格先生那令人敬佩的渊博知识。</p>
<p> 逆向思维让我想到了身边的互联网行业的测试岗位。从结论往回推，倒过来思考，有些时候会使问题简单化，有助于完善你的决策。</p>
<p> 至于查理提出的多元思维模型就更是令人拍案叫绝了。其实，一直以来，我个人更倾向于通识教育的学习。在我看来，知识来源于生活，也将应用于生活。而想要生活的很成功显然不是某一门学科学的很深可以做到的。所以查理的多元思维模型的思想，让我更加坚定了我的想法！</p>
<p> 查理对于心理学也有着十分独到的理解。我认为这与查理长期从事股票投资密不可分，毕竟说到底，股票投资还是对人性的考验。</p>
<p> 毫无疑问，查理先生和巴菲特先生都是价值投资者，虽然A股和美股情况不太一样，但是在我看来，还是有很多可以借鉴之处的，比如选股还是要选成长股，还是要选自己边际能力之内的股票，忍不住想要进行操作的时候可以想一下巴菲特先生的“考勤卡”的例子。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>历史的功用 - 看《中国古代历史人物：秦始皇》</title>
    <url>/2019/01/28/book-notes/book-notes-history/%E4%B8%AD%E5%9B%BD%E5%8F%A4%E4%BB%A3%E5%8E%86%E5%8F%B2%E4%BA%BA%E7%89%A9-%E7%A7%A6%E5%A7%8B%E7%9A%87/</url>
    <content><![CDATA[<ol>
<li><p>学习历史的三个功用</p>
<ul>
<li>启发智慧</li>
<li>审时度势</li>
<li>感动人心</li>
</ul>
<p> 舜何？人也！    </p>
<p> 予何？人也！    </p>
<p> 有为者亦若是。</p>
</li>
<li><p>秦始皇为什么能统一天下？<br> 理智战胜了感性 </p>
</li>
<li><p>秦始皇为什么落得了一个“死无葬身之地”的下场？<br> 骄傲-&gt;疯狂-&gt;自欺欺人</p>
</li>
<li><p>秦国为什么宗室断送，文武惨死，土地被瓜分，秦始皇死后不过三年秦国土崩瓦解？<br> 做什么事都是需要付出代价的，这个代价或早或晚，你迟早要付出的。问题在于这个代价你能不能付出得起罢了。</p>
</li>
<li><p>出身贫富各有利弊。富家子弟处顺境易，处逆境难。穷家子弟，处逆境易，处顺境难。</p>
</li>
<li><p>成功的第一要素<br> 百折不挠</p>
</li>
<li><p>人生只由两部分组成，一半是运气（甚至是最重要的一部分），另一半是你想要成为一个什么样的人</p>
</li>
<li><p>人为什么要学习？</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNc79gy1fzhdbdzf1jj31h00badif.jpg"></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>历史学</tag>
      </tags>
  </entry>
  <entry>
    <title>故事的力量 - 读《人类简史》</title>
    <url>/2018/11/06/book-notes/book-notes-history/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>《人类简史》这本书，我刚上大学就开始读，陆陆续续读了好久，不得不说这本书开阔了我的眼界。全书主要分为四个部分，分别是：</p>
<ul>
<li>认知革命</li>
<li>农业革命</li>
<li>融合统一</li>
<li>科学的革命</li>
</ul>
<p>以下是我的读书新得。		</p>
<h1 id="认知革命"><a href="#认知革命" class="headerlink" title="认知革命"></a>认知革命</h1><h2 id="智人为什么胜出"><a href="#智人为什么胜出" class="headerlink" title="智人为什么胜出"></a>智人为什么胜出</h2><p>现代人类这个人种在学术上叫做「智人」。在几十万年前，除了「智人」这个人种外，其实还有别的人种，比如书中提到的「尼安德物人」和「弗洛里斯人」。而最终，「智人」将别的人种都淘汰掉了。所谓的淘汰，其实就是通过物种间的竞争把别人杀绝种了。</p>
<p>作者首先想讨论的就是，「智人」这种人种相较于别的人种，个体上其实毫无优势。比如尼安德物人就比智人拥有更加强壮的体格，一对一单挑的话，轻轻松松把智人打趴下。别的人种也同样有语言，有组织，会使用工具。</p>
<p>所以，这不是人类和狮子这种猛兽之间的竞争那么简单。人类会使用工具之后，动物基本上就无力还击了。但是人类不同人种之间的竞争，最终为何「智人」能够胜出呢？</p>
<p>作者提出了一个非常独特新颖的观点：智人会讲故事，而且这个故事是虚幻故事（fiction stories)。不但智人讲虚幻故事，智人还相信虚幻故事。</p>
<h2 id="故事的力量"><a href="#故事的力量" class="headerlink" title="故事的力量"></a>故事的力量</h2><p>们来看看什么虚幻故事。对于我们现代社会，最常见的虚幻故事就是：公司。</p>
<p>以什么样的标准，我们才可以说公司存在？你可能认为是公司的产品、公司的员工、公司的工厂和办公室。但是，如果一场地震，公司员工连同公司的工厂全部没了，公司还是存在。你可能认为是公司的股东或者经营团队，但是即使他们全部消失，公司也还是可以存在。</p>
<p>只有一种情况，公司可以消失，那就是法官下令强制公司解散。一家公司被注销，虽然公司的工厂仍然存在，产品、员工、会计师、经理和股东也继续活着，但是这家公司就消失了。</p>
<p>所以，公司只是我们的一个集体想象，这种想象在法律上称为「法律拟制」（legal fiction）。</p>
<p>这种集体想象的威力巨大。因为当大家都相信一个故事的时候，这个故事就真的存在了。</p>
<p>比如，如果大家都相信「国家」存在的时候，大家就会为国家贡献自己的力量甚至生命。</p>
<p>比如，大家相信契约和法律的时候，社会形态就会进一步升级，出现货币，法律，家庭。</p>
<p>又比如，当大家都相信等级存在的时候，社会就会形成阶层。</p>
<h2 id="组织的限制"><a href="#组织的限制" class="headerlink" title="组织的限制"></a>组织的限制</h2><p>即使到了今天，人类的团体还是继续受到这个神奇的数字影响。只要在 150 人以下，不论是社群、公司、社会网络还是军事单位，只要靠着大家都认识、彼此互通消息，就能够运作顺畅，而不需要规定出正式的阶层、职称、规范。</p>
<p>但是一旦团体规模超过 150 人，如果没有阶层、规范的话，那么这个组织就无法形成有效的力量。</p>
<p>智人相信虚幻故事，使得他们能够形成远远超过 150 人的社会团体，从而在与尼安德物人的竞争中，能够产生巨大的组织分工协作的力量。而竞争的另一面，尼安德物人的语言和认知仅仅让他们能够简单沟通，比如说：「前面有狮子」这种非虚幻的故事。</p>
<p>于是，组织的 150 人的限制，在智人的故事面前，被轻松解决了。现代的企业、国家、社会借助于各种集体想象，使得上亿人能够协作在一起。某种意义上说，全世界的人们都可以协作一件事情。</p>
<h2 id="自然选择的限制"><a href="#自然选择的限制" class="headerlink" title="自然选择的限制"></a>自然选择的限制</h2><p>在出现虚幻故事之前，人类的进步主要是受制于基因的突变以及自然选择，这其实是很缓慢很缓慢的。比如人类经过几百万年的发展，才进化到相信虚幻故事。</p>
<p>但是一旦人类相信虚幻故事，人类就可以通过教育，将故事传承下去，于是人类的行为和社会结构被迅速改变。这种认知上的变革使得人类可以绕过自然选择的缓慢升级，直接将认知传递给后代。</p>
<p>于是，自然选择的限制被打破了，人类不需要各种残酷的淘汰就可以进化。现在甚至出现了基因工程，在这方面，人类越来越开始扮演上帝的角色。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>智人通过发展，进化出相信虚幻故事的能力，从而进一步超越了组织的限制和自然选择的限制。</p>
<h1 id="农业革命"><a href="#农业革命" class="headerlink" title="农业革命"></a>农业革命</h1><p>农业革命出现在认知革命之后的 6 万年。作者对于农业革命的评价非常有意思：他认为不是人类选择了小麦，而是小麦使得人们被迫定居。所以，农业革命是史上最大的一桩骗局。</p>
<p>作者的这种观点是站在人类个体上考虑的。因为在农业革命之前，智人的生活相当幸福。作者这样说道：</p>
<blockquote>
<p>智人的身体演化目的并不是为了从事这些活动，我们适应的活动是爬爬果树、追追瞪羚，而不是弯腰清石块、努力挑水桶。于是，人类的脊椎、膝盖、脖子和脚底就得付出代价。研究古代骨骼发现，人类进到农业时代后出现了大量疾病，例如椎间盘突出、关节炎和疝气。<br>此外，新的农业活动得花上大把时间，人类就只能被迫永久定居在麦田旁边。这彻底改变了人类的生活方式。其实不是我们驯化了小麦，而是小麦驯化了我们。“驯化”（domesticate）一词来自拉丁文 “domus”，意思就是 “房子”。但现在关在房子里的可不是小麦，而是智人。</p>
</blockquote>
<p>农业使得人们被迫定居，也需要保卫农田和粮仓。所以，人们很快就发展出国家。也分化出各种职业分工，比如农民、军人、医生等。</p>
<p>从 DNA 拷贝的数量来看，农业革命对于人类是成功的，因为人口数量因此大增。但是从个体幸福感来说，并不是这样。</p>
<p>我们从农业革命能学到的最重要一课，很可能就是物种演化上的成功并不代表个体的幸福。</p>
<h1 id="融合统一"><a href="#融合统一" class="headerlink" title="融合统一"></a>融合统一</h1><p>作者在这部分主要讨论的是金钱，帝国，宗教的产生。</p>
<p>作者在这部分的观点同样犀利，他将宗教比作病毒。</p>
<blockquote>
<p>有学者认为，文化就像是精神感染或寄生虫，而人类就是毫不知情的宿主。寄生虫或病毒就是这样住在宿主体内，繁殖、传播，从一个宿主到另一个宿主，夺取养分，让宿主衰弱，有时甚至丧命。只要宿主能够活着让寄生虫继续繁衍，寄生虫就很少关心宿主的情形。至于文化，其实也是以这种方式寄生在人类的心中。它们从一个宿主传播到另一个宿主，有时候让宿主变得衰弱，有时候甚至让宿主丧命。任何一个文化概念（像是基督教在天上的天堂），都可能让某个人毕生致力于传播这种想法，甚至为此牺牲生命。于是，人类死亡了，但想法持续传播。</p>
</blockquote>
<p>如果把宗教比作病毒，就能够看出宗教的演化历史。病毒是非常强调传播能力的，所以经过长远的发展，最终流传下来的宗教都非常有传播能力。所以从诞生到现在仅仅经过 1000 多年，现在世界上就有大约 20 亿基督徒，12.5 亿穆斯林。</p>
<p>不过我不认为一个人的生命意义就是「尽可能活得久，活得轻松」。宗教可能让人为了传播它丧命，或者活得很辛苦。但是这只是肉体上的。从精神上，宗教让人在「幸福感」上，或许带来的帮助更多。人类有太多想不明白的事情了，宗教让人内心平静，从而可以活得不那么心累。</p>
<p>从这种角度上讲，有了宗教之后，个体很可能是更幸福的。</p>
<h1 id="科学革命"><a href="#科学革命" class="headerlink" title="科学革命"></a>科学革命</h1><p>有些人可能认为科学也是一种宗教，但是其实科学和宗教差别很大。</p>
<p>科学和宗教最大的区别，就是宗教认为这个世界的规则已经都搞明白了。而科学认为这个世界大部分的规则不但没有搞明白，而且现在的规则到底对不对也不知道。</p>
<p>比如基督教认为所有重要的事情都写在圣经上了。圣经上没写的，要么不重要，要么已经超过了人类的理解人类不需要知道。而科学以一种承认自己无知，然后尊重客观实验的方式来不断发展。</p>
<p>科学相对于宗教有三大不同之处：</p>
<ul>
<li>愿意承认自己的无知。</li>
<li>以观察和数学为中心。强调实验，强调客观。</li>
<li>取得新能力。</li>
</ul>
<p>	</p>
<p>看看科学进步的速度就知道了，这几年人们在基因工程和人工智能领域又取得重大突破。</p>
<h1 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h1><p>《人类简史》将人类发展的重要过程分成认知革命、农业革命、融合统一、科学革命。每一部分都进行了独特新颖的解读，其观点已经不仅仅是讲历史了，而是涉及了人类学、政治学、文化学和心理学等学科的特别视角来解读人类的发展。</p>
<p>非常有意思的一本书，推荐给大家。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>历史学</tag>
      </tags>
  </entry>
  <entry>
    <title>刺猬外套 - 读《围城》</title>
    <url>/2018/12/19/book-notes/book-notes-literature/%E5%9B%B4%E5%9F%8E/</url>
    <content><![CDATA[<blockquote>
<p>我们每一个人都是穿着刺猬外套的刺猬，区别仅在于能否在正确的时间、正确的地点、正确的人面前脱掉它而已。</p>
</blockquote>
<p>越往后代入感越强，放佛看到了千千万万个家庭的缩影。</p>
<p>“父母亲戚不好拿来撒气，朋友你拿他撒气他会和你绝交，只有另一伴可以被用来肆无忌惮的撒气。”</p>
<p>“在外人面前永远是一副和和气气的笑脸，回到家之后就鼻子不是鼻子，脸不是脸”。</p>
<p>在我看来，夫妻之间的这种关系别无他法，除了用<br>一颗赤子之心对待彼此，夫妻一起脱下自己的刺猬外套。</p>
<h1 id="每个人都像一只带着刺的刺猬。"><a href="#每个人都像一只带着刺的刺猬。" class="headerlink" title="每个人都像一只带着刺的刺猬。"></a>每个人都像一只带着刺的刺猬。</h1><p><strong>在外面为什么可以和和气气的，在家里就得鼻子不是鼻子脸不是脸呢？</strong></p>
<p>原因很简单，外面空间大，我觉得你扎到我了，我就离你远一点。彼此可以保持一个不会扎到彼此的距离。但是在家里不行，家就那么大，彼此只好“相爱相扎”。</p>
<p>所以最好的办法就是回家以后脱掉自己的刺猬外套，彼此坦诚相对。这样就可以只相爱不相扎。</p>
<p>但是，如果你脱掉了刺猬外套而对方没有，那么这个时候只能是你单方面被“扎”，你要么选择把刺猬外套传回来，要么选择忍耐，但是恕我直言，忍耐终究有穷尽时，那个时候就是你们的关系破裂的时候。</p>
<h1 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h1><p>于我个人而言，如果我做了选择，那么我就会脱掉我的刺猬外套，同时，我会劝对方也这样做。</p>
<p>但是，如果她没有脱掉她额刺猬外套并且扎到我了，那么我会继续开导她一段时间（毕竟不是每个人都有这种意识）。</p>
<p>如果有一天我觉得她已经明白了我的意识，但是为了自己的舒服而拒绝脱掉自己的刺猬外套，那么我会选择转身离开。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>文学</tag>
      </tags>
  </entry>
  <entry>
    <title>以史为鉴 - 读《原则》</title>
    <url>/2021/09/08/book-notes/book-notes-self/%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210908170405.png"></p>
<blockquote>
<p>当你阅读我的故事时，请努力透过故事和我这个人，看到潜在的因果关系，看到我做的选择和这些选择的后果，看到我从中学到了什么，以及我在总结经验后是如何改变决策方式的。你要问自己要什么，将那些得到了你想要的东西的人作为范例，努力分析出潜藏在他们成就背后的因果关系模式，这样你就能应用这些模式，帮助实现自己的目标。</p>
</blockquote>
<h1 id="思考、总结、使用原则"><a href="#思考、总结、使用原则" class="headerlink" title="思考、总结、使用原则"></a>思考、总结、使用原则</h1><p>在回顾我的个⼈经历时，想想我的看法是如何改变的，是件很有意思的事。</p>
<p>最初的时候，我遇到的每⼀个波折，⽆论是在市场上还是在⽣活中，都显得⾮常重⼤⽽且⼗万⽕急，就像某种独特的⽣死攸关的经历，不断地朝我涌来。</p>
<p>积累了更多经验以后，我开始把每次遭遇视为“类似情境的重现”，我能以更平静、更严谨的⽅式应对，就像⼀位⽣物学家在丛林⾥遇到⼀只可怕的动物时⼀样：⾸先确定它的种属，利⽤已有的知识预测它的⾏为，然后合理地做出反应。当我⾯对遇到过的某类情况时，我就利⽤在此前类似经历中总结的原则。但当我遇到从未见过的事情时，我会⼤吃⼀惊。在研究所有这些痛苦的⾸次体验时，我意识到，尽管我没经历过这些事，但其中的⼤多数都有其他⼈在其他时间、其他地⽅经历过。这⼀认识让我对历史抱有⼀种健康的尊重感，渴望对现实的机理形成普遍性的理解，并希望总结出永恒、普适的应对问题的原则。</p>
<p>看到同样的事情反复发⽣，我开始把现实视为⼀部华丽的永动机，⼀些原因引起⼀些结果，这些结果又成为原因，循环往复。我意识到尽管现实不完美，但⾄少我们要直⾯它，因此我在现实中遇到任何问题或挫折时，都不会抱怨，⽽是通过更具建设性的⽅式找到有效的应对⽅法。我逐渐明⽩，我的遭遇是对我的个性和创造⼒的考验。我逐渐领悟到，在⼀个如此伟⼤的系统⾥，我不过是渺⼩的匆匆过客，因此知道如何与这个系统良好互动，对我和系统都是有益的。在形成这个视⾓的过程中，我开始以⼀种截然不同的⽅式体会痛苦的时刻。我不会感觉沮丧或透不过⽓，⽽是把痛苦视为⼤⾃然的提醒，告诉我有⼀些重要的东西需要我去学习。体验痛苦，然后探索⼤⾃然希望通过痛苦给我什么教益，开始成为我的⼀项游戏。这项游戏我做得越多就越擅长，也就越不会对这些情况感到痛苦，同时思考、总结出原则、利⽤原则获得回报的过程也变得越来越有收获。我学会了喜爱⾃⼰的痛苦，我想这是⼀种健康的视⾓，就像学会喜爱锻炼⾝体⼀样（这⼀点我⽬前还做不到）。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>《原则》这本书是在桥水基金创始人 瑞·达利欧 的个人原则基础上组合形成的，这本书里介绍了很多瑞·达利欧个人在生活和工作上总结提炼的原则，这些内容对大多数人价值有限，这里的原则的本质只是一个人过去一段时间内的经验总结，有其时空局限性。</p>
<p><strong>相比于书中介绍的原则，我对瑞·达利欧这种提炼总结个人原则的习惯更感兴趣，其实也就是当下互联网公司中的case study或者叫故障复盘，只不过瑞·达利欧将自己过去case study中具有的共性内容提炼总结了出来，形成了原则。</strong></p>
<p><strong>基于以上思考，我不禁想到历史，有这样一句话“历史总是一遍有一遍的重演”。中国有几千年的历史沉淀，我们完全可以从这些历史宝藏里提炼总结出更加具有时空效力的原则，以史为鉴！！</strong></p>
</br>
</br>]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>自我管理</tag>
      </tags>
  </entry>
  <entry>
    <title>读书的方法 - 读《如何阅读一本书》</title>
    <url>/2018/11/06/book-notes/book-notes-self/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/</url>
    <content><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>不知道第多少次重写这篇文章了，有些东西就是这样，as time goes by，你对一些东西总是有新的理解，人的一生不就是自我完善的一生吗。</p>
<p>距上次重写这篇文章已经有半年了，现在我已经处于分析阅读层次了，接下来就是要将这种能力固化为习惯。</p>
<hr>
<p>《如何阅读一本书》从大一就买了这本书，中间陆陆续续读过几次，可是说实话，委实没有读懂多少，着实可惜。</p>
<p>今天偶然期间在豆瓣上看到一篇书评，忽有所感。</p>
<p>其一，我之前应该一直处于基础阅读层次，书是读了，但是读懂多少，理解多少，那就要看运气了。</p>
<p>其二，我有能力快速的达到检视阅读层次。</p>
<p>其三，我里分析阅读的层次还有一定的距离。</p>
<p>下面就结合书评简单聊聊我对这本书的理解。</p>
<blockquote>
<p>阅读的四个层次：基础阅读，检视阅读，分析阅读，主题阅读。</p>
</blockquote>
<h2 id="基础阅读"><a href="#基础阅读" class="headerlink" title="基础阅读"></a>基础阅读</h2><p>也就是初级阅读，只要不是文盲，能看懂字面意思，就可以完成。</p>
<h2 id="检视阅读"><a href="#检视阅读" class="headerlink" title="检视阅读"></a>检视阅读</h2><p>简单来说就是阅读理解，快速浏览。它也分两个阶段。</p>
<h3 id="第一阶段：有系统的略读"><a href="#第一阶段：有系统的略读" class="headerlink" title="第一阶段：有系统的略读"></a>第一阶段：有系统的略读</h3><p>具体的建议顺序是：先看<strong>书名</strong>、<strong>序言</strong>和<strong>副标题</strong>，接着研究<strong>目录</strong>和<strong>索引</strong>，然后看看<strong>作者简介</strong>，再翻开看一下和<strong>书名主题相关的篇章</strong>。</p>
<p>这个技巧的难点是要求你有背景知识。不过你书读得越多，就越容易。</p>
<h2 id="第二阶段：粗浅的阅读"><a href="#第二阶段：粗浅的阅读" class="headerlink" title="第二阶段：粗浅的阅读"></a>第二阶段：粗浅的阅读</h2><p>规则：头一次面对一本难读的书的时候，从头到尾先读完一遍，碰到不懂的地方不要停下来查询或思索。</p>
<p>从头到尾读了一遍之后的了解——就算只有50%或更少——能帮助你在后来重读第一次略过的部分时，增进理解。就算你不重读，对一本难度很高的书了解了一半，也比什么都不了解来得好些——如果你让自己在一碰上困难的地方就停住，最后可能对这本书真的一无所知了。</p>
<h2 id="分析阅读"><a href="#分析阅读" class="headerlink" title="分析阅读"></a>分析阅读</h2><h3 id="打开一本书之前，必须牢记的四个问题"><a href="#打开一本书之前，必须牢记的四个问题" class="headerlink" title="打开一本书之前，必须牢记的四个问题"></a>打开一本书之前，必须牢记的四个问题</h3><ol>
<li>总的来说，这本书到底在谈些什么？</li>
<li>书的细节部分，作者是怎么谈的？</li>
<li>这本书的观点有道理吗？是全部有道理还是部分有道理？</li>
<li>这本书跟你自己有什么关系?</li>
</ol>
<p>我觉得这四个问题的关键就是在理解作者的基础上，把自己和书籍之间搭建起一个<strong>桥梁，联系。</strong></p>
<h3 id="了解范围：这本书在谈什么？"><a href="#了解范围：这本书在谈什么？" class="headerlink" title="了解范围：这本书在谈什么？"></a>了解范围：这本书在谈什么？</h3><p>（1）你需要确定主题和书的分类，比如是文学，还是历史，或者是经济学？</p>
<p>（2）然后要用一小段内容叙述整本书的内容。</p>
<p>（3）把重点的章节列出来。</p>
<p>（4）找出作者要在书里讨论的问题。</p>
<p>其实，这个阶段也不复杂，你只需要做到一点，不要拿起一本书就闷头读，先搞清楚这本书的结构再下手。</p>
<h3 id="理解内容：本书作者是怎么写出来的？"><a href="#理解内容：本书作者是怎么写出来的？" class="headerlink" title="理解内容：本书作者是怎么写出来的？"></a>理解内容：本书作者是怎么写出来的？</h3><p>（1）你需要找出书里反复出现的关键词。</p>
<p>（2）需要在那些你认为重要的句子下划出标记，从这些话里找出作者的中心思想。</p>
<p>（3）用做笔记的方式重新搭建书里的前因后果。有时候，画一张表就能解决这个问题。看着这张你自己画的笔记图，你可以在脑子里迅速过一遍全书。</p>
<p>（4）确定了作者已经解决了哪些问题，还有哪些是未解决的。在未解决的问题中，确定哪些是作者认为自己无法解决的。</p>
<h3 id="评价。"><a href="#评价。" class="headerlink" title="评价。"></a>评价。</h3><p>看任何书，都一定要有评论，要有自己的态度。但是记住，不要在读完之前就随便下结论。</p>
<h2 id="主题阅读"><a href="#主题阅读" class="headerlink" title="主题阅读"></a>主题阅读</h2><p>简单来说就是按图索骥。照着你自己感兴趣的主题找书去读。这个层次的阅读需要更强的主动性，还需要读者有一定的判断力。主题阅读，不是说你读完了一本书接着读第二本，而是说带着你想解决的问题，去读不同的书里的不同章节。主题阅读不是为了看书而看书，而是为了解决实用性问题而看书。</p>
<h3 id="第一阶段，主题阅读的准备阶段"><a href="#第一阶段，主题阅读的准备阶段" class="headerlink" title="第一阶段，主题阅读的准备阶段"></a>第一阶段，主题阅读的准备阶段</h3><p>（1）针对你要研究的主题，设计一份试验性书目。你可以参考图书馆目录、专家的建议与书中的书目索引。</p>
<p>（2）浏览这份书目上所有的书，确定哪些与你的主题相关，并就你的主题建立起清晰的概念。</p>
<h3 id="第二阶段，阅读所有第一阶段收集到的书籍"><a href="#第二阶段，阅读所有第一阶段收集到的书籍" class="headerlink" title="第二阶段，阅读所有第一阶段收集到的书籍"></a>第二阶段，阅读所有第一阶段收集到的书籍</h3><p>（1）浏览所有在第一阶段被认定与你主题相关的书，找出最相关的章节。</p>
<p>（2）根据主题创造出一套中立的词汇，带引作者与你达成共识——无论作者是否实际用到这些词汇，所有的作者，或至少大部分的作者都可以用这套词汇来诠释。</p>
<p>（3）建立一个中立的主旨，列出一连串的问题——无论作者时候明白谈过这些问题，所有的作者，或至少大多数的作者都要能解读为针对这些问题提供了他们的回答。</p>
<p>（4）界定主要及次要的议题。然后将作者针对各个问题的不同意见整理陈列在各个议题之旁。你要记住，各个作者之间或之中，不见得一定存在某个议题。有时候，你需要针对一些不是作者主要关心范围的事情，把他的观点解读，才能构建出这种议题。</p>
<p>（5）分析这些讨论。这得把问题和议题按顺序排列，以求凸显主题。比较有共通性的议题，要放在比较没有共通性的议题之前。各个议题之间的关系也要清晰的界定出来。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>培养阅读的习惯</strong></p>
<p>所谓艺术或技巧，只属于那个能养成习惯，而且能依照习惯来运作的人。这也是艺术家或任何领域的工匠与众不同之处。而要养成习惯，除了不断地运作练习之外，别无他法。</p>
<h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><p>藏书仅仅是代表在纸张上的拥有，而不是智力上的拥有。</p>
<p>如果你有读书时提出问题的习惯，那就要比没有这种习惯更能成为一个好的阅读者。但是，就像我们所强调的，仅仅提出问题还不够。你还要试着去回答问题。而这个回答问题的过程可能在大脑中就完成了，但是如果能够用笔完成、用键盘完成就更好了。</p>
<p>中国古语中有“微言大义”的说法。据说半本论语可以治理天下。那么如何把字面后的东西读出来、写出来，才是真正读懂一本书的关键所在。</p>
<p><strong>在书上做笔记不可或缺的原因：</strong></p>
<p>(1)那会让你保持清醒。</p>
<p>(2)阅读是一个主动的过程、是一种思考，而思考倾向于用语言表达出来——无论是用讲的还是用写的。一个人如果说他知道他在想些什么，却说不出来，通常是他其实并不知道自己在想些什么。</p>
<p>(3)将你的感想写下来，能帮助你记住作者的思想。</p>
<p><strong>以下是几个可以采用的方法：</strong></p>
<p>(1) 画底线：在主要的、重点的句子下画线。</p>
<p>(2) 在画底线处的栏外再加画一道线：把你已经画线的部分再强调一遍，或是某一段很重要，但要画底线太长了，便在这一整段外加上一个记号。</p>
<p>(3) 在空白处做星号或其他符号—要慎用，只用来强调书中十来个最重要的声明或段落即可。你也可以将做过这样记号的地方折一个角，或是夹一张书签，这样当你从书架上拿起这本书的时候，就可以打开你做过记号的地方，唤醒你的记忆。</p>
<p>(4) 在空白处编号：作者的某个论点发展出一连串的重要陈述时，可以做顺序编号。</p>
<p>(5) 在空白处记下其他的页码：强调作者在书中其他部分也有过同样的论点，或相关的要点，或是与此处观点不同的地方。这样做能让散布全书的想法统一集中起来。许多读者会用Cf这样的记号，表示比较或参照的意思。</p>
<p>(6) 将关键字或句子圈出来：这跟画底线是同样的功能。</p>
<p><strong>(7)在书页的空白处做笔记：在阅读某一章节时，你可能会有些问题或答案，在空白处记下来，这样可以帮你回想起你的问题或答案。你也可以将复杂的论点简化说明在书页的空白处。或是记下全书所有主要论点的发展顺序。书中最后一页可以用来作为个人的索引页，将作者的主要观点依序记下来。</strong></p>
<h3 id="产出"><a href="#产出" class="headerlink" title="产出"></a>产出</h3><p>读完一本书应该有以下产出：</p>
<ol>
<li>思维导图</li>
<li>一篇对这本书在讨论什么作出解答的读书笔记</li>
<li>达到主题阅读层次后，还需要有一篇类似paper的、主题相关的、专业的文章</li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>自我管理</tag>
      </tags>
  </entry>
  <entry>
    <title>积累 - 读《把时间当朋友》</title>
    <url>/2018/11/23/book-notes/book-notes-self/%E6%8A%8A%E6%97%B6%E9%97%B4%E5%BD%93%E6%9C%8B%E5%8F%8B/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>最近两周读了李笑来老师的《把时间当作朋友》这本书，我最开始听说李笑来老师是源自于他在得到app上的《财富自由之路》专栏，惭愧的是一直受困于资金，还没有买。</p>
<p>这本书中，就我个人而言对我最有启发的有四点：</p>
<ul>
<li>一是作者开篇点明的本书的主旨“成长只有一条路——积累”。</li>
<li>二是作者介绍了一些帮助自己更好的去利用时间的一些自我管理方法</li>
<li>三是作者在书中对学习的鼓励以及对学习这件事本身的看法，最重要的是对自学进行了透彻的分析。</li>
<li>四是作者对一些经典的观念的重新解读，让人不禁眼前一亮。</li>
</ul>
<h1 id="积累"><a href="#积累" class="headerlink" title="积累"></a>积累</h1><p>作者在本书的开篇即阐明了本书的主旨：</p>
<blockquote>
<p><strong>时间是不可能被管理的</strong>。必须开启心智，看清楚，想明白：<strong>问题出在我们自己身上</strong>。而我们所面临的问题，与时间、管理或时间管理都没有多大的关系。解决问题的核心思想只有一个——<strong>一切都靠积累</strong>。深信积累的力量，时间就是你的朋友，否则，它就是你的敌人。</p>
</blockquote>
<p>作者在书中是这样描述时间不可能被管理的：</p>
<blockquote>
<p>时间不会服从任何人的管理，它只会自顾自的流逝。你不可能冲它大喊：“时间，你给我慢一点！”它只是自顾自的流逝。你也不可能向它大叫：“时间，你给我快一点！”它还是自顾自的流逝。时间不理任何人，它用自己特有的速度流逝，不受任何外界因素影响。</p>
</blockquote>
<p>毫无疑问——我们无法管理时间。</p>
<p>当选择来临时，我们要运用心智获得解放（做正确的选择）。不在让自己“跟着感觉走”，成为大脑的奴隶，而是翻身做大脑的主人。</p>
<p>何谓心智？一人的心智就是其过往获得的一切知识及经验的总和（包括基于这些知识和讲演造就的思考方法、思考模式）。</p>
<p>摆脱自己的局限，运用心智的力量，一点一点的去积累，等待机会的来临。</p>
<h1 id="自我管理——更好的使用时间"><a href="#自我管理——更好的使用时间" class="headerlink" title="自我管理——更好的使用时间"></a>自我管理——更好的使用时间</h1><p><strong>估算时间</strong></p>
<p>要想提高估算时间的能力，就要养成习惯：</p>
<blockquote>
<p>做任何事情之前先判断其熟悉程度（或陌生程度），再据此判断估算完成任务所需要的时间。通常情况下，“反正比一般想得长多了”。</p>
</blockquote>
<p>为什么人们总是错误估计完成任务所需要的时间呢？</p>
<p>因为有些任务是你所熟悉的，即以前曾经做过的。而大多数任务则是你所陌生的，那么在执行过程中就必然会遭遇各种意外。其实它们根本不是意外，只不过是因为你对任务不熟悉。实际上，这些“意外”是任何完成这个任务的人都必须经历的事情，只有完整地执行一次一次任务，任务的属性由“陌生”变为“熟悉”之后，才有可能顺利解决这些意外。</p>
<p><strong>及时行动</strong></p>
<p>比“越早开始越好”更切实的答案是“现在就开始”。</p>
<p>作者这这一段介绍了一个“时间越过越快”的概念，解释如下：</p>
<blockquote>
<p>对于一个5岁的孩子来讲，未来的1年相当于他人生的1&#x2F;5，即20%；而对一个50岁的成年人来讲，未来的1年只相当于他已经度过的人生的1&#x2F;50，即2%。所以，随着年龄的增长，人们会觉得时间越过越快。</p>
</blockquote>
<p>所以，在起步晚了的情况下，问题不是“到时候能不能做好”，而是“到时候能做多好就做多好，总好过什么都不做”。</p>
<p><strong>直面困难</strong></p>
<p>作者这一部分讨论了一个现象：“<strong>为什么有些人好像一直在忙，却总拿不出成绩、做不出成效？</strong>”</p>
<p>其实，仔细观察你就会发现，他们实际上并不努力，只是作出努力的样子而已，或者显得比较努力而已。</p>
<p>那么问题来了，他们为什么要做出一副比较努力的样子呢？</p>
<p>这是因为任何一个任务都可以划分为两个部分，即相对简单的部分和相对困难的部分。而很多人会下意识的回避苦困难，于是乎，他们的时间安排是这样的：用几乎全部时间处理简单的部分，至于困难的部分，干脆“掩耳盗铃”，视而不见，暗地里希望困难自动消失……</p>
<p>那么合理的时间安排应该是什么样子的呢？应该是：迅速做完简单的部分，把节省出来的时间放在困难部分的处理上。</p>
<p><strong>关注步骤</strong></p>
<p>所谓“三思而行”，做任何事情之前都要考虑3个方面：内容（What）、原因（Why）、方法（How）。</p>
<p>当我们面对某项任务的时候，内容与原因都已经基本确定（至少表面上看是如此），需要思考的就剩下方法了。当然，思考方法需要从领悟内容入手，不停的细分，拆解任务，而且越具体越好，直至每个小任务都可以由一个人独立完成。</p>
<p>在做任何事情之前，通过关注“方法”去反复拆分任务，最终确认每个字任务都是可完成的，这是一个人不可或缺的功课。这样的习惯，会使人变得现实、踏实。</p>
<p><strong>记录开销</strong></p>
<p>正如理财第一步是弄清楚自己的钱都花在了什么地方一样，感知时间的第一步就是要搞清楚自己的时间都用来做了些什么。</p>
<p><strong>制定长度适宜的计划</strong></p>
<blockquote>
<p>“初始状态下，我们往往并没有能力去制定合理有效的计划”。做任何事情，都可能经历相同的过程：逐步熟悉，小心摸索，失败，失败，再失败，认真反思，卷土重来，直至成功。而最初，在我们对任务连最基本的认知都没有的时候，制定出来的计划十有八九只不过是空谈。</p>
</blockquote>
<p><strong>流程</strong></p>
<blockquote>
<p>无论是学习、工作还是生活，我们面临的任务大都是重复性的。要想加快执行重复性任务的速度，只需在遇到重复性任务时先将其做完一次，然后马上总结、整理，高清流程，再靠近一步的实践把它变成“闭着眼睛也能做好的事。这是提高效率、减少失误的根本手段”。</p>
</blockquote>
<h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><p>学习——投资回报率最高的行为</p>
<p>获取更多知识几乎是我们开拓自身心智的唯一手段。</p>
<p>获取知识的基本途径有：“体验”、“试错”、“观察”、“阅读”、“正确的思考”</p>
<p>思考的过程即由因及果或由果溯因的过程。“万事必有因果”本身没有错误，问题出在人们不一定看到“因”就能想到正确的“果”，也做不到为所有的“果”找到正确的“因”。有时我们必须接受这样的事实：某件事（果）发生了，可是我们很难确定它的原因究竟是什么；或者反过来：某件事（因）发生了，可是我们并不确定它的结果究竟是什么。</p>
<p><strong>自学能力</strong></p>
<blockquote>
<p>本科教育之“本”在于培养学生自学能力。从理论上讲，一个人本科毕业之后，应该有能力自学他所需要的任何知识。</p>
</blockquote>
<h1 id="作者对经典观念的重新解读"><a href="#作者对经典观念的重新解读" class="headerlink" title="作者对经典观念的重新解读"></a>作者对经典观念的重新解读</h1><p><strong>兴趣</strong></p>
<blockquote>
<p>往往不是有兴趣才能做好，而是做好了才有兴趣。</p>
</blockquote>
<p>典型case：</p>
<p>“我现在的xxx专业不适合我，我感兴趣的是xxx专业”</p>
<p>其实，如果他现在对他的专业知识了如指掌，他不可能说他不喜欢。这些人其实不是对自己现在的专业不感兴趣，而是没有能力把自己现在的专业学好。换言之，没有人会对自己能做好的事情不感兴趣。</p>
<p><strong>方法</strong></p>
<blockquote>
<p>方法固然重要，但是比起“用功”来说，方法几乎可以忽略不计。</p>
</blockquote>
<p>所有学习上的成功都只依赖两件事——策略和坚持，而坚持本身就是最重要的策略。</p>
<p>与其不停的寻找“更好的方法”，还不如马上开始行动。</p>
<p><strong>比较</strong></p>
<p>比较是相对的，相对是永远没有尽头的。所以，很多时候，比较就是一个坑，大坑。再干脆点说，比较就是陷阱。</p>
<p>生活无法彻底回避比较，但是，无需比较就可以获得的快乐和幸福也同样很多，只不过它们常常被人们忽略。于是，无数人花费大量的时间去追求必须通过比较才能获得的快乐和幸福，而他们最终获得的，只有更多的痛苦。</p>
<p>其实，比成功更重要的是成长。如果“成功”是与他人比较的话，那么“成长”则是与自己的比较——今天的我和昨天的我、明天的我和今天的我的比较。后一种比较显然比前一种对个体来说意义更大，也更能带来踏实的幸福感。</p>
<p><strong>运气</strong></p>
<p>相信运气其实是缺乏自制力的表现</p>
<p>“卒然临之而不惊，无故加之而不怒”    ——苏轼</p>
<p><strong>人脉</strong></p>
<p>所有人都喜欢并重视甚至偏爱一种交换——公平交换。</p>
<p>基于此，给出两条实践起来并不容易的建议：</p>
<ul>
<li>专心做可以提升自己的事情，学习并拥有更多、更好的技能，成为一个值得他人交往的人。</li>
<li>学会独善其身，以不给他人制造麻烦为美德，用自己的独立赢得尊重。</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>总的来说，这是一本教人踏踏实实做事的书。</p>
<p>正如作者所述，时间是不以人的意志为转移的。无论你是好是坏，它就在那里静静地流逝。</p>
<p>其实通过作者对典型的观念的重新解读可以看出来，为什么会有那么多论七八糟的概念“兴趣、方法、运气、人脉…”等等等，其实就是我们不想踏踏实实的去积累，我们太浮躁，我们在为自己找借口。</p>
<p>醒醒吧，少年，莫要等到“暮然回首，沧海桑田”的时候，再去追悔莫及。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>自我管理</tag>
      </tags>
  </entry>
  <entry>
    <title>R90 - 读《睡眠革命》</title>
    <url>/2019/07/13/book-notes/book-notes-self/%E7%9D%A1%E7%9C%A0%E9%9D%A9%E5%91%BD/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20190713212825.png"></p>
<p>刚才看了一眼博客，从5月份开始，就没怎么更新过了，过去的这两个月很痛苦，但是痛苦的同时也让我成长了很多，回首过去唯有“感恩”二字可以概括过去的这一年半里的点点滴滴。有纯真的爱情，也有不爱之后的丑陋，感恩的是所有的一切让我知道了自己想要的到底是什么，感恩的是让我对自己有了一个更好的定位，让我知道了我是谁。</p>
<p>上周看了《睡眠革命》这本书，总的来说，书中的内容和我事先看书评了解到的内容相差不远，但是看过之后或多或少让我对具体的实践有了更多的心得，所以要是想要调整自己睡眠的朋友，倒是可以看看。</p>
<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p><strong>昼夜节律：我们体内的昼夜节律是经历了成千上万年进化后的产物。</strong></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20190713214317.png"></p>
<p>tips：</p>
<blockquote>
<p>根据昼夜节律，睡眠质量最高的时间出现在凌晨2-3点。如果在日出之后才去睡觉，你就违背了你的生物钟。（我一般早上8点之后就睡不着了…）</p>
</blockquote>
<p><strong>睡眠类型：</strong></p>
<ul>
<li>早起星人</li>
<li>晚睡星人</li>
</ul>
<h1 id="R90"><a href="#R90" class="headerlink" title="R90"></a>R90</h1><h2 id="睡眠周期：智慧睡眠的七个要点"><a href="#睡眠周期：智慧睡眠的七个要点" class="headerlink" title="睡眠周期：智慧睡眠的七个要点"></a>睡眠周期：智慧睡眠的七个要点</h2><ul>
<li><strong>固定睡眠就像一根铁锚支撑着整个R90方案。设定一个固定的起床时间，并持之以恒的坚持下去。</strong></li>
<li>用90分钟时长的睡眠周期衡量睡眠，而不是睡了多少个小时。</li>
<li>你可以自行选择入睡时间，但入睡时间取决于你的起床时间。从起床时间出发，根据R90分钟时长的睡眠周期，向后推算。</li>
<li>把睡眠放在一个更长一段时间中考虑，减少不必要的压力。一个“没睡好的糟糕晚上”不会要了你的名，不妨试着去考虑，你每周一共获得了多少睡眠周期。</li>
<li>尽量避免连续三个晚上睡眠不足（少于理想的睡眠周期）的情况发生。</li>
<li>睡眠是不是一个简单的数量或质量问题，试着了解你究竟需要多少睡眠时间。对大多数人来说，每周获得35个睡眠周期是最理想的。</li>
<li>争取每周至少有4个晚上能获得最理想的睡眠时间。</li>
</ul>
<h2 id="午后和傍晚的修复期"><a href="#午后和傍晚的修复期" class="headerlink" title="午后和傍晚的修复期"></a>午后和傍晚的修复期</h2><p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20190713222350.png"></p>
<p>如果自己觉得晚上的睡眠周期不足的话，可以利用午后（13-15点）或者傍晚（17-19点）小憩上半个小时，这个也可以计入一周的睡眠周期中。</p>
<blockquote>
<p>能够睡着固然很棒，但徘徊在似睡非睡、似醒非醒的朦胧、迷糊的状态中，同样也很迷人。这就像一个美好的白日梦，你并没有认真在想什么，你的大脑处于一片混沌中。</p>
</blockquote>
<h2 id="睡眠前后的例行程序"><a href="#睡眠前后的例行程序" class="headerlink" title="睡眠前后的例行程序"></a>睡眠前后的例行程序</h2><p>睡眠前后各需要一个周期（90分钟）的时间来为晚间的睡眠服务。</p>
<p>睡眠前：</p>
<ul>
<li>关闭电子产品（让自己空下来）</li>
<li>从温暖到凉爽</li>
<li>从明亮到昏暗（关闭日光灯，打开暖色的台灯）</li>
<li>整理一下明天起床后要用到的物品</li>
</ul>
<p>睡眠后：</p>
<ul>
<li>打开窗帘，沐浴阳光</li>
<li>去卫生间</li>
<li>洗漱</li>
<li>早餐</li>
<li>处理一下手机里的消息（如果有的话）</li>
</ul>
<p>如果是周末，建议上午可以去锻炼一下。</p>
<blockquote>
<p>我们无法掌控睡觉时的举动，但却能掌控睡眠前后的一切举动。睡眠前后的例行程序能让我们准备好进入一个个睡眠周期，从而能通过睡眠获得最佳的修复。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我觉得书中的一段话说的很好，可以用作本篇博客的总结。</p>
<blockquote>
<p>夜间的睡眠周期、睡眠前和睡眠后的例行程序、日间小睡，还有这些零散的休息片段——有了这些，你的一天就不再是连续的拼命、拼命、再拼命，然后倒在床上睡上8个小时或更少的时间，无奈的让一切周而复始。</p>
</blockquote>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>自我管理</tag>
      </tags>
  </entry>
  <entry>
    <title>升级心智 - 读《财富自由之路》</title>
    <url>/2019/04/26/book-notes/book-notes-self/%E8%B4%A2%E5%AF%8C%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h1><p>一直以来读李笑来写的书，都有一种“认同感”，但同时读完也有一种没起到什么作用的感觉，有点类似“鸡汤”，但是我心中又知道，我对他说的内容是认同的，直到读完这本《财富自由之路》我大概明白为什么了。</p>
<p>因为，李笑来有他自己的一套心智框架，他每次阐述的都是一个概念。这个概念会让我们产生认同感，但是之前我并没有这套心智框架，所有这个概念我无处安放，也就导致产生那种“读的时候很有用，放下书本什么用也没有的感觉”。</p>
<p>所以这篇读书笔记中，有如下几个要点：</p>
<ul>
<li>总结这套心智框架（操作系统）;</li>
<li>总结这本书中介绍的各个概念、价值观;</li>
</ul>
<h1 id="二、思维导图"><a href="#二、思维导图" class="headerlink" title="二、思维导图"></a>二、思维导图</h1><p><img src="/images/%E5%8D%87%E7%BA%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E8%B4%A2%E5%AF%8C%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF%E3%80%8B.png"></p>
<h1 id="三、心智框架（操作系统）"><a href="#三、心智框架（操作系统）" class="headerlink" title="三、心智框架（操作系统）"></a>三、心智框架（操作系统）</h1><p><strong>定义：</strong></p>
<blockquote>
<p>所谓心智，形象点将，就是我们每个人脑子里的那个可以不断升级的操作系统</p>
</blockquote>
<p><strong>操作系统的构成：</strong></p>
<ul>
<li>概念与关联</li>
<li>价值观与方法论</li>
<li>实验与践行</li>
</ul>
<p>概念和关联构成了操作系统的底层核心，其他部分都依赖于他们究竟有多清晰、多准确、多必要。进而，一些价值观会自然形成或自然进化。你得先知道“什么”究竟是什么，才能知道“这个”和“那个”孰优孰劣。而所谓“价值观”，无非是一个“小”问题的真实答案。这个“小”问题是：</p>
<blockquote>
<p><strong>什么更重要</strong></p>
</blockquote>
<p><strong>价值观决定选择，选择促成行动，行动构成命运。</strong></p>
<p>价值观，即你要知道 <strong>什么对你更重要</strong>。</p>
<blockquote>
<p>注：感谢这么书让我对什么是价值观有了清晰的认识！</p>
</blockquote>
<h1 id="四、本书所讲述的概念、价值观、方法论"><a href="#四、本书所讲述的概念、价值观、方法论" class="headerlink" title="四、本书所讲述的概念、价值观、方法论"></a>四、本书所讲述的概念、价值观、方法论</h1><p>参照：思维导图</p>
<p><a href="https://pan.baidu.com/s/1Sa4gK_8208mP9T4zFjVCcA">升级操作系统——读《财富自由之路》.png</a></p>
<p><a href="https://pan.baidu.com/s/1A-eh3lgBjaUQItwGCyUY0A">财富自由之路.xmind</a></p>
<h1 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h1><p>当我懂得了上边说的那些内容之后再来看这本书之后，不得不说这本书该是以介绍概念为主。这些概念本可以用很短的篇幅可以说明白，但是可能因为作者深蕴写作之道，了解“用户的刚需”，所以“适当”的将篇幅进行了扩充。所以再读起来多多少少有一种注水的感觉。只能说，取其精华，去其糟粕了。</p>
<p>总的来说还是十分感谢李笑来老师的这本书，对我影响深远！</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>自我管理</tag>
      </tags>
  </entry>
  <entry>
    <title>产出-产能平衡原则 - 读《高效能人士的七个习惯》</title>
    <url>/2019/04/05/book-notes/book-notes-self/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/</url>
    <content><![CDATA[<h1 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h1><p>这本《高效能人士的七个习惯》也是一本被我“收藏”了好久的书，一直以为总感觉这是一本“速成书”，所以缺乏阅读它的兴趣，直到这次我读过它之后，我知道我透过我的思维定式去看待它了。</p>
<p>我读的上一本书是《穷查理宝典》，里面讲到的很重要的一个概念是“多元思维模型”，而这本书在我看来有异曲同工之妙，它教我们从身体、精神、智力和情感多个纬度去提升自己。</p>
<p>其实，在看这本书之前，近期我也是这么安排自己时间的。但是可能总体思维上没有书中介绍的这么全面。所以，我对书中的内容十分之认可。</p>
<p>我给这本书打：5颗星</p>
<h1 id="二、架构图"><a href="#二、架构图" class="headerlink" title="二、架构图"></a>二、架构图</h1><center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20190509220617.png" height="400px" width="400px">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">2-1</div>
</center>

<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20190509220644.png" height="300px" width="600px">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">2-2</div>
</center>

<h1 id="三、思维定式"><a href="#三、思维定式" class="headerlink" title="三、思维定式"></a>三、思维定式</h1><p>在讲具体的七个习惯之前，应该讲一下为什么需要养成七个习惯。</p>
<p>答案就是——思维定式。</p>
<p>“思维定式”从广义上讲，是指我们“看”待世界的方法，主要指我们的感知、理解和诠释。它是每个人看待世界的方式，未必与现实相符。它是一张地图，而非地域本身，是由每个人的成长背景、经验及选择打造而成，我们会透过它来窥探万事万物。</p>
<p>本书的开篇，作者给大家做了一个小测试。</p>
<ol>
<li>给两组人分别看图3－1和图3－3，10秒钟</li>
<li>仔细观察后同时给他们看综合了二者特点的画像图3－2</li>
<li>要求他们描述。</li>
</ol>
<p>结果，事先看到少妇像的，几乎一致认定这就是少妇；而先前看到老妇像的人，则都认为这是为老妇人。大家经过一番争执和对照后，渐渐的看到了另一方眼中的画像。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20190509220012.png" height="220px" width="200px">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">3-1</div>
</center>

<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20190509220045.png" height="220px" width="200px">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">3-2</div>
</center>

<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20190509220152.png" height="220px" width="200px">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">3-3</div>
</center>

<p>首先，这个实验充分的说明了条件作用对人类认知和思维定式的强大影响力。家庭、学校、教堂、单位、朋友、同事以及流行思潮，都在不知不觉中影响着我们，左右着我们的思维。</p>
<p>其次，这个实验还说明了思维定式是行为与态度的源头，脱离了这个源头的言行就是表里不一，言不由衷。</p>
<p>所以，我们也应该理解，别人的观点虽然和我们不一样，但也是清楚而客观的，毕竟——立场决定观点。</p>
<p>我们越是认识到思维定式以及经验在我们身上的影响力，就越是能够对自己的思维定式负责，懂得审视它，在现实中检验它，并乐于聆听和接受别人的看法，从而获得更广阔的视野和更客观的看法。</p>
<h1 id="四、产出-产能平衡原则"><a href="#四、产出-产能平衡原则" class="headerlink" title="四、产出-产能平衡原则"></a>四、产出-产能平衡原则</h1><blockquote>
<p>一个农夫无意间发现一只会生金蛋的鹅，不久便成了富翁。可是财富却使他变得更贪婪更急躁，每天一个金蛋已经无法满足他，于是他异想天开地把鹅宰杀，想将鹅肚子里的金蛋全部取出。谁知打开一看，鹅肚子里并没有金蛋。鹅死了,再也生不出金蛋。</p>
</blockquote>
<p>产出&#x2F;产能平衡(P&#x2F;PC Balance)原则，P代表希望获得的产出，即金蛋；PC代表生产金蛋的资产或能力。效能在于产出&#x2F;产能的平衡。</p>
<p>它是短期利益与长期目标之间的平衡。</p>
<h1 id="五、个人领域"><a href="#五、个人领域" class="headerlink" title="五、个人领域"></a>五、个人领域</h1><p>在刺激与回应之间，人有选择的自由。选择的自由包括人类特有的四种天赋。除自我意思之外，我们还拥有“想象力”，即超越当前现实而在头脑中进行创造的能力；“良知”，即明辨是非，坚持行为原则，判断思想、言行正确与否的能力；“独立意志”，即基于自我意识、不受外力影响而自行其是的能力。</p>
<p>其他动物即使智慧再高也不具备这些天赋。生而为人，如果也像动物一样，只听命于本能及后天环境的影响，发展极其有限。但若能加以锻炼和开发，则会在不同程度上实现我们独具的人类潜能，<strong>在刺激于回应之间自由选择就是我们最大的能力。</strong></p>
<h2 id="5-1-积极主动"><a href="#5-1-积极主动" class="headerlink" title="5.1 积极主动"></a>5.1 积极主动</h2><blockquote>
<p>人性的本质是积极主动而非被动的，人类不仅能针对特定环境选择回应方式，更能主动创造有利的环境。<br>采取主动不能与胆大妄为、惹是生非或姿滋事挑衅，而是要让人们充分认识到自己有责任创造条件。</p>
</blockquote>
<p>“积极主动”即采取主动，为自己过去、现在及未来的行为负责，并依据原则及价值观，而非情绪或外在环境来做决定。</p>
<p>积极主动是一种人生态度，是一种对自己要过什么样的人生的一种选择。</p>
<p>从进入大学到现在4年半时间，这其中我陆陆续续懂得了很多道理，其间，我曾多次想将我的感受分享给别人。但是，现在我懂了，一方面，那只是我的感受，带着我的“思维定式”的感受，并不通用。另一方面，人如果不是自发的、由内而外的想要改变，别人说的再多也没有用。</p>
<blockquote>
<p>谁也无法说服他人改变，因为我们每个人都守着一扇只能从内开启的改变之门，不论动之以情或说之以理，我们都不能替别人开门。 </p>
</blockquote>
<h2 id="5-2-以终为始"><a href="#5-2-以终为始" class="headerlink" title="5.2 以终为始"></a>5.2 以终为始</h2><blockquote>
<p>太多人成功之后，反而感到空虚；得到了名利之后，却发现牺牲了更可贵的东西。因此，我们务必盯紧真正重要的远景，然后勇往直坚持到底，是生活充满意义。</p>
</blockquote>
<p>以终为始说明在做任何事情之前，都要认清方向。这样补单可以对目前处境了如指掌，而且不至于在追求目标过程中误入歧途，白费功夫。</p>
<p><strong>你希望在盖棺定论时获得的评价，才是你心目中真正渴望的成功。</strong></p>
<blockquote>
<p>每天清晨起床后问自己一句：“如果今天就是我人生中的最后一天，我会怎么做？”</p>
</blockquote>
<p>所有的事物都要经过两次的创造——先是在脑海里酝酿，其次才是实质的创造。个人、家庭团队和组织在做任何计划时，均先拟出愿景和目标，并据此塑造未来，全心投注于自己很重视的原则、价值观、关系及目标上。</p>
<ol>
<li>习惯一谈的是“你是创造者”</li>
<li>习惯二谈的是“第一次创造”</li>
<li>习惯三谈的是“第二次创造”</li>
</ol>
<p>明确自己的人生愿景是什么，才能过好自己的这一生，不妨，将它写下来。</p>
<h2 id="5-3-要事第一"><a href="#5-3-要事第一" class="headerlink" title="5.3 要事第一"></a>5.3 要事第一</h2><blockquote>
<p>有效管理是掌握重点式的管理，它把最重要的事放在第一位。由领导决定什么是重点后，再靠自制力掌握重点，时刻把它们放在第一位，以免被感觉、情绪或冲动所左右。</p>
</blockquote>
<p>一旦确定了人生方向，你就应该对自己进行有效的管理，让生活与设想一致。有效的自我管理所涉及的大都是左脑所擅长的能力：分解、分析、排序，具体运用以及在规定时间内完成任务等。</p>
<p>自我管理的实质就是自律和条理，是对计划的事实。</p>
<p>老实说，我的很多习惯都和这本书的观点不谋而合，比如“要事第一”这点，我最近在朋友的推荐下开始使用“奇妙清单”。在我的清单中有人生愿景，有年度计划，有月计划，有周计划，有日计划以及每种计划的执行情况。</p>
<p><strong>只有有条不絮的整理好自己要做的事情，自己的人生才能有条不絮的。否则，终有一天，你会觉得自己的人生一团乱麻。</strong></p>
<p>书中在这个位置推荐我们重点关注<strong>重要但不紧急的事情。</strong> 这可以让你重要性而不是紧迫性来观察一切事务。这其实和人的眼界很类似，有的人只关注自己明天吃什么，而有的人会想如何做才能实现自己的人生理想。有很多重要但不紧急的事，比如：读书、健身、旅行等等。</p>
<p>仔细观察这些都是对自己将来的一种投资。也即是产出&#x2F;产能平衡原则。</p>
<h1 id="六、公众领域"><a href="#六、公众领域" class="headerlink" title="六、公众领域"></a>六、公众领域</h1><p>人际关系的本质：</p>
<blockquote>
<p>所谓情感账户，存储的是增进人际关系不可或缺的“信赖”，也就是他人与你相处时的一份“安全感”。能够增加感情账户存款的，是礼貌、城市、仁慈与信用。越是持久的关系，越需要不断储蓄。</p>
</blockquote>
<p>个人的独立不代表真正的成功，圆满人生还需追求公众领域的成功。不过，群体的互赖关系必须以个人真正的独立作为先决条件，想要抄近路是办不到的。</p>
<p>这是一个很重的概念——良好的人际关系的基础是自制与自知之明。有人说，<strong>爱人之前，必须先爱自己。</strong> 此言果然不虚，但是我更强调人贵知己。了解自我才懂得分寸，也才能真正爱自己。</p>
<h2 id="6-1-双赢思维"><a href="#6-1-双赢思维" class="headerlink" title="6.1 双赢思维"></a>6.1 双赢思维</h2><blockquote>
<p>双赢者把生活看作一个合作的舞台，而不是一个角斗场。一般人看事情多非此即彼，非强即弱，非胜即败。其实世界之大，人人都有足够的立足空间，他人之得不必视为自己之失。</p>
</blockquote>
<p> 人际交往的六种模式：</p>
<ul>
<li><strong>利人利己（双赢）</strong></li>
<li>损人利己（赢&#x2F;输）</li>
<li>舍己为人（输&#x2F;赢）</li>
<li>两败俱伤（输&#x2F;输）</li>
<li>独善其身（赢）</li>
<li><strong>好聚好散（无交易）</strong></li>
</ul>
<p><strong>利人利己</strong></p>
<p>双赢就是双方有福同享，皆大欢喜，这种结果会让所有人都愿意接受决定，完成计划。</p>
<p><strong>损人利己</strong></p>
<p>大多数人从小就被这种模式浸染。在家里，大人总是喜欢把孩子进行比较，好孩子会得到更多的爱、理解和耐心。同龄人之间也是如此，有时完全更具自己的期望和标准来选择接受还是拒绝一个人，这就让赢&#x2F;输模式更加根深蒂固。学校是赢&#x2F;输模式的另一个温床，一个人的价值是通过与他人比较才得以实现的，学校的等级制度只强调竞争和比较，完全忽视学生的潜能和天赋。然而，<strong>人生没有赢输</strong>。现实生活需要相互依赖，而不是单枪匹马，你的很多梦想都需要通过与他人合作才能实现，而赢&#x2F;输模式是这种合作的最大障碍。</p>
<p>仔细想一想确实是这样的，最起码在我的人生里是这样的。从小到大，从来都是比来比去的。诚然，竞争会让人进步。但是，这种竞争，也让我们失去了对他人的信任，而没有信任又谈何友谊？</p>
<p>所以，想要重新拾起信任，收获友谊，需要从双赢思维开始。</p>
<p><strong>舍己为人</strong></p>
<p>输&#x2F;赢模式意味着做老好人，然而“好人不长命”。</p>
<p><strong>两败俱伤</strong></p>
<p>为了报复，不惜牺牲自身利益，却不问是否值得；只有不够成熟、掌握不了人生方向的人，才会这样。</p>
<p><strong>独善其身</strong></p>
<p>当竞争和对抗意义不大的时候，独善其身就是多数人的处事方法，他们只在意自己的利益 无损，别人的就留给他们自己去保护吧。</p>
<p><strong>好聚好散</strong></p>
<p>如果是在无法达成共识，实现双赢，就不如好聚好散。</p>
<p>双赢思维的五个要点：</p>
<ul>
<li>“双赢品德”</li>
<li>“双赢关系”</li>
<li>“双赢协议”</li>
<li>“双赢体系”</li>
<li>“双赢过程”</li>
</ul>
<p>培养这方面的修养，少不了过人的见底、积极主动的精神，并且以安全感、人生方向、智慧与力量作为基础。</p>
<p>以前，一直都很困惑，明明道理懂得很多，可为什么收获的友谊低于预期。现在大概明白了，少的是双赢思维，一直以来，那么处于赢&#x2F;输模式，要么进阶为独善其身模式。如果一来，对别人少了一份关心，缺了一份信任，友谊谈何而起。</p>
<h2 id="6-2-知彼解己"><a href="#6-2-知彼解己" class="headerlink" title="6.2 知彼解己"></a>6.2 知彼解己</h2><blockquote>
<p>如果用一句话归纳我在人际关系方面学到的一个最重要的原则，那就是；知彼解己——首先寻求去了解对方，然后再争取让对方了解自己。这一原则是进行有效沟通的关键。</p>
</blockquote>
<p>事实上，大部分人都是这么自以为是。怡情聆听的本质不是要你赞同对方，而是要在情感和理智上充分而深入地理解对方。</p>
<p>除了物质，人类最大的生存需求源自心理，即被人理解、肯定、认可和欣赏。</p>
<p>试着去了解别人，走进别人的内心。</p>
<h2 id="6-3-统合综效"><a href="#6-3-统合综效" class="headerlink" title="6.3 统合综效"></a>6.3 统合综效</h2><blockquote>
<p>统合综效的基本心态是：如果一位具有相当聪明才智的人跟我意见不同，那么对方的主张必定有我尚未体会的奥妙，值得加以了解。        </p>
<p>与人合作最重要的是，重视不同个体的不同心情、情绪与智能，以及个人眼中所见到的不同世界。与所见略同的人沟通，益处不大，要有分歧才有收获。</p>
</blockquote>
<p>所谓统合综效的沟通，是指敞开胸怀，接纳一切奇怪的想法，同时也贡献自己的见地。</p>
<p>尊重人与人之间的差异，当有人不同意你的观点的时候，你应该试着寻找统合综效的第三条道路，一般情况下它总是存在的。如果你坚持双赢模式，确实愿意努力理解对方，你就能找到让每一个人都受益更多的解决方案。</p>
<p>总的来说，就是要有一种开明的态度，要能接受差异。</p>
<h1 id="七、不断更新"><a href="#七、不断更新" class="headerlink" title="七、不断更新"></a>七、不断更新</h1><blockquote>
<p>人生最值得的投资就是磨练自己，因为生活与服务人群都得靠自己，这是最珍贵的工具。</p>
<p>工作本身并不能带来经济上的安全感，具备良好的思考、学习、创造与适应能力，才能立于不败之地。拥有财富，并不代表经济独立，拥有创造财富的能力才真正可靠。</p>
</blockquote>
<p>不断更新的是你的个人产能。它保护并优化你拥有的最重要的资产——你自己。它从四个层面更新你的天性，那就是：身体、精神、智力、社会&#x2F;情感。</p>
<p><strong>身体层面</strong></p>
<p>锻炼属于第二类事务，但是由于不具紧迫性，因此很少有人能坚持不懈，结果终有一天我们会发现自己陷入了第一类事务，不得不面对健康问题和危机，而原因正是之前对锻炼的忽视。</p>
<p>也许锻炼的最大的好处是养成了习惯一“积极主动”的肌肉。</p>
<p><strong>精神层面</strong></p>
<p>精神层面的更新为你指引人生的方向，与习惯二密切相关。</p>
<p>当你远离城市的喧嚣与混乱，尽情享受过大自然的和谐与韵律，再回到城市时会感到耳目一新。</p>
<p>如果我们能够用心把握生活的方向和生命的真谛，就如同得到了一把可以聚拢一切的大伞，源源不断地赐予我们新的力量，如果能够持之以恒，效果会更加明显。</p>
<p><strong>智力层面</strong></p>
<p>智力层面的更新主要靠教育，借此不断学习知识，磨砺心志，开阔视野。</p>
<p>养成定期阅读优秀文学作品的习惯是扩展思维的最佳方式，这是第二类事务，人们可以借此接触到当前或历史上最伟大的思想。</p>
<p>磨砺心志的另一种有效方式是写作。通过不断记录自己的想法、经历、深刻见解和学习心得，我们的思路就会更加明晰、准确和连贯。</p>
<p>我现在基本保持着每周读一本书的速度，且如果书中的内容让我收益颇丰的话，我会在周末写一篇读书笔记，即巩固了书中的知识，又锻炼了自己的文笔。</p>
<p><strong>社会&#x2F;情感层面</strong></p>
<p>身体、精神和智力层面与习惯一、二、三密切相关，围绕着个人愿景、自我领导和自我管理的原则。而社会&#x2F;情感层面的重点则是习惯四、五、六，围绕着人际领导、怡情交流和创造性合作的原则。</p>
<p><strong>For example:</strong></p>
<p>假设你是我生活中必不可少的人，我们需要交流、共事、完成一项任务或解决一个问题，但却存在意见分歧和不同视角，比如你看到的年轻女子，我看到的却是老妇人。</p>
<p>这时候我就要时间习惯四。我对你说：“我知道，咱们对这个问题的看法不同，不如先交流一下意见，直至找到大家都满意的解决方法。你觉得如何？”多数人都会点头同意。</p>
<p>然后，我开始实践习惯五——先理解别人，我要做到怡情聆听，当我能够像你一样解释你的观点之后，就集中精力阐明我自己的观点，让你也能够理解我的观点。</p>
<p>既然我们都致力于寻求双方满意的解决方案并能够深入理解彼此的观点，就可以转向习惯六。我们共同努力，拟定消除分歧的第三种解决方案，该方案需要被双方认可且优于你我最初提交的方案。</p>
<p>习惯四、五、六的成功关键不是智力问题，而是情感问题，与我们个人的安全感密切相关。</p>
<p>至于增进内在安全感的方式，包括坚守原则，肯定自我；与人为善，相信人生不止输赢两种选择，还有双方都是赢家的第三种可能性；乐于奉献，服务人群；燃烧自己，照亮别人。如果把工作当作一种奉献，再平凡的职业也会显得不同凡响。</p>
<p>人生的四个层面休戚相关；身体健全有助于心智发展，精神提升有益于人际关系的圆满。因此，平衡才能产生最佳的整体效果。</p>
<p>淫秽、粗俗或色情的东西会使我们的灵魂陷入黑暗之中，削弱我们的判断能力，不再关心是非对错，只在乎自己是否会被“社会良知”揭发。</p>
<p>哈马舍尔德说过：“把玩内心兽性的人，早晚会变成真正的野兽；整天弄虚作假的人，终将失去获得真理的权利；暴虐成性的人，头脑的判断力会日益减退。如果真的要保持花园整洁，就不能让杂草有立足之地。”</p>
<h1 id="八、小结"><a href="#八、小结" class="headerlink" title="八、小结"></a>八、小结</h1><p>说实话，读书读到现在最大的感受就是知识都是想通的。</p>
<p>借用今天在知乎上看到的一句话来总结一下就是：“除了四六级的词汇书之外，其他书中的知识都是不确定在哪一刻会用到的知识。”</p>
<p><strong>但行好事，莫问前程。</strong></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>自我管理</tag>
      </tags>
  </entry>
  <entry>
    <title>心智成熟之旅 - 读《少有人走的路》</title>
    <url>/2019/09/16/book-notes/book-notes-psycholog/%E5%B0%91%E6%9C%89%E4%BA%BA%E8%B5%B0%E7%9A%84%E8%B7%AF/</url>
    <content><![CDATA[<p>思维导图：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/%E5%B0%91%E6%9C%89%E4%BA%BA%E8%B5%B0%E7%9A%84%E8%B7%AF%E5%BF%83%E6%99%BA%E6%88%90%E7%86%9F%E4%B9%8B%E8%B7%AF_meitu_1.jpg"></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title>永恒的当下 - 读《当下的力量》</title>
    <url>/2022/08/21/book-notes/book-notes-psycholog/%E5%BD%93%E4%B8%8B%E7%9A%84%E5%8A%9B%E9%87%8F/</url>
    <content><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>最近在一次和蛋蛋的沟通中，我表达了自己各种顾虑之后，蛋蛋给我推荐了这本书，并表示自己曾反复阅读过多次。</p>
<blockquote>
<p>没有任何事情可以发生在过去，所有的事情都发生在当下。</p>
<p>也没有任何事情会发生在未来，所有的事情都只发生在当下。</p>
<p>过去发生的事情是一个记忆的痕迹，它储存在大脑中，是过去的当下。当你记起过去发生的事情时，你就重新激活了那个记忆——而你是在当下做这件事情的。未来是一个幻象的当下，是思维对未来的投射。当未来来临时，它是以当下的方式到来。当你思考未来时，你也是在当下做这件事情。很明显，过去和未来本身没有现实性。就像月亮本身不会发光一样，它只能反射太阳光，所以过去和未来仅是永恒的当下的光线、力量和现实性的反映。过去和未来的现实性都是从当下借过来的。</p>
</blockquote>
<p>读完发现这本书确实是我的良药，过去我确实深陷于过去和未来之中，被思维所奴役。</p>
<h2 id="被思维所奴役"><a href="#被思维所奴役" class="headerlink" title="被思维所奴役"></a>被思维所奴役</h2><blockquote>
<p>“是认同于你的思维，它使人们进行强迫性的思考。不能停止思考是一个可怕的烦恼，由于几乎每一个人都遭受着此种痛苦，而我们又无法意识到这一点，所以这就成了一件很正常的事情。这种不停的思维活动使你无法达到内心的宁静状态。同时，它创造了一个虚假的自我，不断投射出恐惧和苦难的阴影。”</p>
</blockquote>
<p>思维本身是一个帮助我们更好的去采取行动的工具，起主导作用的本应该是行动本身，但是现在由于大量且过度的思考，使我们被思维所绑架，被迫卷入思维的长河之中，遨游于“过去”和“未来”，深陷于痛苦之中。</p>
<p>那么我们是如何一步步走到被思维所奴役的地步的呢？</p>
<p>首先，大脑本身是一个十分好用的工具，但是在你个人城中过程中，在你个人和文化环境的影响下，你养成了从思维活动中获取自己存在感的习惯，随着这种习惯的不断加强，最终形成了一种强迫性思维的上瘾症。</p>
<p>对于这种从思维中获取自我存在感的感觉来说，当下时刻几乎不存在，只有过去和未来才是最重要的。</p>
<p>“当下时刻就是解脱的关键。但是，只要你认同你的思维，你就难以找到当下。”</p>
<p>所以拜托被思维所奴役的第一步就是观察它。这是一种自我存在的感觉，而不是思维，它超越了思维。</p>
<h2 id="情绪，身体对思维的反应"><a href="#情绪，身体对思维的反应" class="headerlink" title="情绪，身体对思维的反应"></a>情绪，身体对思维的反应</h2><p>思维-&gt;情绪-&gt;生理</p>
<p>你的思维活动会影响到你的情绪，你的情绪积累到一定程度会进而使你产生生理变化。</p>
<p>如果你被思维所奴役，在思维过程中多是无意识状态，那么你也同样会丧失对情绪状态的控制。原因很简单，因为你的思维过程是无意识的，那么在这些无意识思维所产生的情绪中也缺少了你意识的成分，当这些无意识情绪爆发的时候，你也就丧失了自我的掌控，被无意识情绪所控制，这也是为什么有些人情绪不稳定的原因所在。</p>
<p>解决方法和解决不被思维所奴役的方法是一样的：观察它，观察思维活动产生情绪的过程。</p>
<h2 id="意识，摆脱痛苦的途径"><a href="#意识，摆脱痛苦的途径" class="headerlink" title="意识，摆脱痛苦的途径"></a>意识，摆脱痛苦的途径</h2><p>我们痛苦的根源是被思维所奴役、被情绪所控制，是陷入了一种无意识状态。</p>
<p>解决办法就是想办法让意识重新降临。</p>
<p>无论是思维还是情绪，观察的过程本身就是将意识降临本体的过程。而当意识完完全全降临了之后，也就不存在被思维所奴役和被情绪控制了的情况，我们也就摆脱了痛苦。</p>
<h2 id="当下是你所拥有的一切"><a href="#当下是你所拥有的一切" class="headerlink" title="当下是你所拥有的一切"></a>当下是你所拥有的一切</h2><blockquote>
<p>“请你务必认识到，当下时刻是你所拥有的一切，把你的生活重心完全放到当下这一刻，把你先前在时间内流连并短暂地访问当下时刻的做法改为关注当下时刻，只在必要时简单地回顾过去和展望未来。永远对当下说“是”。有什么比对已然存在的东西进行内在的抗拒更徒劳、更疯狂的吗？有什么比反对生命本身，也就是当下，而且永远是当下，更疯狂的吗？向“是”臣服，对生活说“是的”，看看生活是如何为你服务而不是与你为敌的。”</p>
<p>“接纳，然后采取行动。不管当下时刻的情况怎样，心甘情愿地接受它，就像它是你选择的一样。总是与它共事，而不是抗拒它，使它成为你的朋友和盟友而不是敌人。这将会不可思议地改变你的整个生活。”</p>
<p>没有任何事情可以发生在过去，所有的事情都发生在当下。</p>
<p>也没有任何事情会发生在未来，所有的事情都只发生在当下。</p>
<p>过去发生的事情是一个记忆的痕迹，它储存在大脑中，是过去的当下。当你记起过去发生的事情时，你就重新激活了那个记忆——而你是在当下做这件事情的。未来是一个幻象的当下，是思维对未来的投射。当未来来临时，它是以当下的方式到来。当你思考未来时，你也是在当下做这件事情。很明显，过去和未来本身没有现实性。就像月亮本身不会发光一样，它只能反射太阳光，所以过去和未来仅是永恒的当下的光线、力量和现实性的反映。过去和未来的现实性都是从当下借过来的。</p>
</blockquote>
<p>过去和未来都是虚假的谎言，只有当下才是你所拥有的一切。</p>
<p>我们的人生要靠当下去改变，我们梦想要靠当下去实现。</p>
<p>尊重每一件事情，却又不在乎这一切。在有形的世界，去追寻无形的自由 —— 不以物喜，不以己悲。</p>
<h2 id="思维逃避当下的策略"><a href="#思维逃避当下的策略" class="headerlink" title="思维逃避当下的策略"></a>思维逃避当下的策略</h2><p>一些典型的无意识的例子：</p>
<blockquote>
<ol>
<li>你是否有应该做但现在又没有做的事情呢？如果有，请现在就开始做吧。或者，你就完全接受你此刻的消极、懒惰或被动，如果这是你的选择的话。请充分地享受它，请尽可能地懒惰吧。</li>
<li><strong>你的压力很大吗？你是否太忙于进入未来，而把当下变成你达到未来目标的手段？压力的产生是由于你在“这里”却想到“那里”去，或你在当下却想去未来。</strong><br>3.过去是否占据了你大部分的注意力？你是否经常正面地或负面地谈论或思考着过去呢？这些过去是你曾经取得的伟大成就、你的冒险经历、你的受害经历，还是别人对你做的可怕的事情或你对别人做的可怕的事情？你的思维过程创造了愧疚、骄傲、怨恨、愤怒、遗憾还是自怜呢？</li>
<li>你感到忧虑吗？你是否经常想到“万一”？如果是的话，你就是在认同你的思维，思维把自己投射到未来的情境中，并创造了恐惧。你是无法应对这个未来的情境的，因为它压根儿就不存在。这是一种精神上的幻觉。仅仅通过承认当下时刻的存在，你就可以停止这种有害健康和生活的疯狂行为。</li>
<li>某天，我会成功的。”你的目标是否占据了你大部分的注意力而让你把当下当成达到未来目的的一种手段？它是否夺走了你所做的事情本应带给你的欢乐？你是否在等待开始新的生活？如果你有这种思维模式，不管你取得了什么成就，你的当下时刻永远不够好，你的未来似乎永远会更好。这样就会让你永远得不到满足，你同意吗？</li>
<li>你的目标是否占据了你大部分的注意力而让你把当下当成达到未来目的的一种手段？它是否夺走了你所做的事情本应带给你的欢乐？</li>
<li>你是一个习惯等待的人吗？在你的生活当中，你花了多少时间在等待呢？我所说的小规模的等待指的是在邮局里排队、遇到交通堵塞、在机场里候机，或等待某人的到来或完成工作等。更大规模的等待指的是等待下一个假期、下一个更好的工作，等待孩子长大，等待一份好姻缘，等待成功，等待挣钱，等待成为重要的人物，等待开悟。人们总是用一生来等待开始新的生活，这是很常见的现象。<br>等待是一种思维状态，意味着你需要未来，而不要现在；你不要你所拥有的，而要你所没有的。任何一种形式的等待，都让你无意识地在你的此时此刻创造了一种内心的冲突：你不要此时此刻，你把希望寄托于未来。丧失对当下时刻的意识，会大大降低你的生命质量。</li>
</ol>
</blockquote>
<p>过去的就让它过去吧，未来的就留给未来吧，我们拥有的是现在。</p>
<p>设定目标并努力去实现目标本身并没有错，错误的是你将它看成是你对生命和对本体的感受的替代品。</p>
<h2 id="生命旅程的内在目的"><a href="#生命旅程的内在目的" class="headerlink" title="生命旅程的内在目的"></a>生命旅程的内在目的</h2><p>生命旅程的内在目的：达到临在状态，不以物喜，不以己悲。</p>
<blockquote>
<p>“你的生命旅程有一个外在目的和一个内在目的。外在目的是达到你的目标，完成这个或成就那个，这当然和未来有关。但是如果你的目标和你在未来将采取的行动占据了你太多的注意力，并且对你来说，它们比你现在所采取的步骤更为重要时，那你就失去了你旅程的内在目的。内在目的与你去的地方或你正在做的事没有任何关系，但是它与你如何做事有着密切的关系。它与你的未来没有关系，但是与你此刻意识的质量有密切的关系。外在目的属于时间和空间的水平维度；内在目的则关乎无时间的当下时刻的垂直维度。你外在的旅程可能包含着上百万个步伐；你内在的旅程却只有一步——你现在正在行动的那一步。随着你更多地意识到这一步，你会认识到它已经包含了其他所有的步骤以及你的目标，然后这一步就转变成一个完美的表述，一个绝美和有极佳质量的行动。它将会带着你进入本体，本体之光将会穿越它。这就是你内在旅程的目标和成就，一个驶向你自己的旅程。”</p>
<p>“我们达到外在目的很重要吗？世俗的成功或失败重要吗？</p>
<p>它的重要性在于你能不能了解自己的内在目的。外在目的就像一个游戏，你可能会不断地去玩，因为你喜欢它。但在你外在目的完全失败的同时，你的内在目的有可能取得成功。反之，更常见的是外在很富裕，内心“却很贫乏。或者如耶稣所说：“<strong>赢了全世界，却丢了灵魂</strong>。”</p>
</blockquote>
<p>人生本来就是一场修行，我们透过完成一个又一个人生目标来让自己悟得人生的内在意义 —— 即永恒的当下。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>空间和时间都有其对应物，揭露它们自己的和你的真正本质。空间的内在对应是寂静，无限深入无念的领域。时间的内在对应物是临在，永恒的当下的意识。世界的最终目的不在于世界中，而是在于超越世界。</li>
<li>在死亡之前死亡，然后深深的走近它。你会发现有一种东西是超越生与死的，那就是<strong>永恒的当下</strong>。</li>
</ul>
<br>
<br>]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title>学会爱自己 - 读《盔甲骑士》</title>
    <url>/2022/08/10/book-notes/book-notes-psycholog/%E7%9B%94%E7%94%B2%E9%AA%91%E5%A3%AB/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220810083329.png"></p>
<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>最近刚失恋，分手的过程很不对劲。而这已经是第二次出现类似的场景了，所以为什么？？</p>
<p>带着这样的疑惑，我咨询了几位心里老师，也得到了一些答案，这里不在多表。</p>
<p>这本书就是在这样大的背景下去读的，书很薄，全篇采用一种寓言的手法，通过描述一位骑士在梅林法师和小松鼠、鸽子的帮助下重新找回自我，脱下盔甲的故事。</p>
<p>文中首先交代了骑士把自己困在了盔甲里，自己的妻子儿子要离自己而去，然后骑士就此踏上了脱盔甲的真理之路。</p>
<h2 id="寂静之堡"><a href="#寂静之堡" class="headerlink" title="寂静之堡"></a>寂静之堡</h2><p>想要脱下自己身上盔甲的第一步是要勇敢的一个人面对自己内心，千万不要因为害怕面对自己，害怕孤独而选择与他人结伴，因为在外人面前，你永远会装作最好的样子。</p>
<p>还要知道一个道理，就是不要把生命都浪费在回顾过去和畅谈未来之中，而是应该抓住现在，快乐的活在当下。</p>
<h2 id="知识之堡"><a href="#知识之堡" class="headerlink" title="知识之堡"></a>知识之堡</h2><p>在可以做到不惧怕孤独，可以一个人面对自己的内心之后，还要知道一些关于打破枷锁的知识：</p>
<ol>
<li>爱不是需要</li>
<li>需要别人，对别人索取爱，是因为不爱自己</li>
<li>只能先爱自己，才能爱别人，不爱自己，也无法爱别人</li>
<li>学会为自己而活，做自己内心深处真正想做的事</li>
<li>从思想来产生的雄心壮志能够带来舒适的城堡和骏马良驹，而从内心产生的雄心壮志能够带来幸福和快乐</li>
<li>做自己发自内心想做的事，</li>
</ol>
<p>这里的第5点和我在《当下的力量》这本书看到的观点有异曲同工之妙，我们的思维（大脑）只是我们自我（意识）的一个工具，我们不能被思维所绑架，而是要根据需要去使用它。</p>
<h2 id="志勇之堡"><a href="#志勇之堡" class="headerlink" title="志勇之堡"></a>志勇之堡</h2><p>这里主要是想告诉我们，在打破枷锁的过程中不可避免会出现疑惑、恐惧甚至是反复，但是无论如何我们都要坚定上面我们在寂静之堡和知识之堡学到的知识，每次恐惧和疑惑之时可以提醒自己“恐惧和疑惑都是幻觉”。</p>
<h2 id="真理之巅"><a href="#真理之巅" class="headerlink" title="真理之巅"></a>真理之巅</h2><p>最后的最后，要想真正的打破枷锁，需要我们放下执着，交出信任，这里信任可以理解为任何一种力量，比如一种人体周围的能量场？比如人体的潜意识？？要相信只要做过的事情，冥冥之中自有记载，也一定会有相应的反作用力作用在相应的人身上（因果？？）。</p>
<p>这里我第一次用相对科学一点的角度理解了“举头三尺有神明”这句话。</p>
<p>一个人做一件事，哪怕没有人看见、知道，但是他自己是知道的，他自己的潜意识是知道的，无形之中就会影响到他的心态、行为举止，进而就会影响到他的生活，这不就是因果吗。</p>
<p>但行好事，莫问前程。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>世间之事，本来本来很简单，使其变复杂的是我们自己，放下对过去的回忆和对未来的想象，把握住当下，开心、快乐、幸福的去做自己发自内心想做的事，每天如此，一生亦如此。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title>如何自控 - 读《自控力》</title>
    <url>/2020/01/14/book-notes/book-notes-psycholog/%E8%87%AA%E6%8E%A7%E5%8A%9B/</url>
    <content><![CDATA[<p>《自控力》这是一本5星好书！</p>
<p>其实早在大一我就买过一次这本书，不过当时比较浮躁，读了两章感觉像是快餐书就没有继续往下读。</p>
<p>毕业后渐渐养成了用豆瓣管理读书的习惯，看到豆瓣上大家对这本书的评价还挺高的，就又买了一本，但是直到去年12月份才开始读这本书。在分析阅读的过程中（系统略读&amp;粗浅阅读）已经惊为好书，但是没有一个总体的概念。在分析阅读的过程（思维导图）成功的明白了“自控”这件事情，如果有机会建议大家都耐心的读一读。</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20211123143716.png"></p>
<h2 id="1-自控是什么？"><a href="#1-自控是什么？" class="headerlink" title="1. 自控是什么？"></a>1. 自控是什么？</h2><p>定义：自控就是<strong>自我意识</strong>在<strong>原始本能</strong>的基础上去使用<strong>自控系统</strong>达到自我目的的过程。</p>
<p><strong>自我意识</strong>：知道自己在做什么，为什么要这么做，以及怎么做。</p>
<blockquote>
<p>自我意识是人对自己身心状态及对自己同客观世界的关系的意识。自我意识包括三个层次：对自己及其状态的认识；对自己肢体活动状态的认识；对自己思维、情感、意志等心理活动的认识。自我意识不仅是人脑对主体自身的意识与反映，而且人的发展离不开周围环境，特别是人与人之间关系的制约和影响，所以自我意识也反映人与周围现实之间的关系。自我意识是具有意识性、社会性、能动性、同一性等特点 [2]  。																																		</p>
<p>​																																			——来自百度百科</p>
</blockquote>
<p><strong>原始本能</strong>：恐惧、欲望、贪婪…</p>
<p><strong>自控系统（意志力）</strong>：我要做、我不要、我想要。</p>
<blockquote>
<p>什么是意志力。意志力并非主观的态度，而是以大脑前额叶以及身体为基础的生理活动，可以概括为三分天下，两虎相争和一个指标。“三分天下”是指大脑前额叶三个区域的能力构成，也就是“我要做，我不做和我想要”，这三种能力构成了人类大脑的自控系统。而“两虎相争”指的是自控系统与冲动系统的比拼。最后一个生理测量指标叫做“心率变异度”，这个指标可以反映我们自控力的强弱。</p>
<p>​																																			——来自得到听书</p>
</blockquote>
<h2 id="2-为什么会失控？"><a href="#2-为什么会失控？" class="headerlink" title="2. 为什么会失控？"></a>2. 为什么会失控？</h2><h3 id="2-1-生理基础"><a href="#2-1-生理基础" class="headerlink" title="2.1 生理基础"></a>2.1 生理基础</h3><p>定义：意志力如同肌肉一样是有限的，每次使用都有消耗，即使是微不足道的决定，所以应该把最重要的事情放在意志力最强的时候做（早上）。</p>
<p>为什么意志力会疲惫？当大脑发现可用能量减少时，它便会削减前额皮质（意志力）的能量预算。</p>
<p>增强意志力的方法</p>
<ul>
<li>在意志力耗尽时增加一点身体的糖分（健康饮食）</li>
<li>控制自己以前不会去控制的小事，以此来提高意志力肌肉（比如用左手开门）</li>
</ul>
<p>注：意志力疲劳是因为大脑的监控机制，是一种感觉，而非事实上的极限，意志力比我们想象的要多，如果我们可以挺过这种感觉，我们还会有意志力可以使用的。</p>
<h3 id="2-2-自我感觉良好"><a href="#2-2-自我感觉良好" class="headerlink" title="2.2 自我感觉良好"></a>2.2 自我感觉良好</h3><p>道德许可效应：做善事时感觉良好，之后更容易遵从冲动，纵容自己被认为是做善事的奖励，从而忘记了更长远的目标。</p>
<p><strong>目标释放</strong></p>
<p>在完成目标的过程中取得的进步，会刺激人们作出妨碍完成目标的行为</p>
<p>解决：当我们取得进步之后面对诱惑的时候，记住在取得进步的过程中我们为什么拒绝诱惑，这样所谓的奖励看起来更像是对目标的威胁。</p>
<p><strong>明日复明日</strong></p>
<p>大脑会对能完成目标的可能性感到兴奋，它错把可能性当成真正完成了目标。我们错误的认为明天的自己会比今天的自己有更多的时间。</p>
<p>解决：明确明天和今天毫无区别。没有下一次。</p>
<p><strong>解决方式：忘掉美德（进步），关注目标和价值</strong></p>
<p><strong>为什么我们误把渴望当幸福？</strong></p>
<p>原因：当大脑发现获得奖励的机会时，它的奖励系统就会释放一种叫做多巴胺的神经递质，这种神经递质会促使人们去寻求刺激。  </p>
<p>在奖励系统活跃的时候，我们感受到的是渴望，而不是快乐。这是使得目标对象格外具有吸引力。 </p>
<p>当奖励系统释放多巴胺的时候，我们更容易受到各种形式的诱惑。大量的多巴胺会放大“及时行乐”的快感，而让我们忘记我们长远的目标。生活中的许多广告及营销学很擅长利用奖励机制来赚钱。</p>
<p>神经营销学：常见的获得奖励的目标对象</p>
<ul>
<li>美食 </li>
<li>香味</li>
<li>色情图片（性）</li>
<li>各种具有诱惑力的广告</li>
</ul>
<p><strong>牢记：渴望的感觉不是真的快乐，更多注意真实的状况。</strong></p>
<h3 id="2-3-自我感觉糟"><a href="#2-3-自我感觉糟" class="headerlink" title="2.3 自我感觉糟"></a>2.3 自我感觉糟</h3><p>原因：当面临压力时，大脑中的奖励系统会被激活，会释放大量的多巴胺使我们进入寻求奖励的状态。应激反应中释放的压力荷尔蒙，同样会提高多巴胺神经元的兴奋程度。这些都会使我们更容易受到诱惑。  </p>
<p><strong>解决方式</strong></p>
<ul>
<li>面对压力的时候，通过做自己爱好去调节自己的心情：读书、健身、旅行，花时间和家人朋友在一起等等  </li>
<li>面对失败的时候，学会自我谅解，这反而会增强人们的责任感，让人们不会太放纵自己</li>
</ul>
<h3 id="2-4-群体影响"><a href="#2-4-群体影响" class="headerlink" title="2.4 群体影响"></a>2.4 群体影响</h3><p>目标传染：我们呢很容易感染别人的目标，从而改变自己的行为。目标传染在两个方向上都会起作用，你既可以感染自控，也可能感染自我放纵。</p>
<p>解决方式：在每天刚开始的时候花几分钟想想自己目标，想想你会怎么收到诱惑，这就像疫苗一样。</p>
<p><strong>“我不要”力量的局限性</strong></p>
<p>讽刺性反弹：当人们试图不去想某件事，比有意去想的时候想的更多。</p>
<p>解决方式：放弃自控，去想自己所想，追随自己的感觉（你不必相信它是真的，不要觉得必须采取行动），放弃控制内心的感受，反而能让我们更好的控制外在行为。</p>
<p>不要尝试去控制自己想什么，那是不可能的。选择自己相信什么，选择自己要做什么。</p>
<h2 id="3-如何防止失控？"><a href="#3-如何防止失控？" class="headerlink" title="3. 如何防止失控？"></a>3. 如何防止失控？</h2><h3 id="3-1-原始本能和自控系统"><a href="#3-1-原始本能和自控系统" class="headerlink" title="3.1 原始本能和自控系统"></a>3.1 原始本能和自控系统</h3><ul>
<li>原始本能让身体获得能量，产生更多的多巴胺，让你关注即时的、短期的目标和结果</li>
<li>自控系统让前额皮质获得能量，减少多巴胺，让你的大脑有更广阔的视野</li>
</ul>
<h3 id="3-2-强身健体（睡眠、冥想、运动、呼吸）"><a href="#3-2-强身健体（睡眠、冥想、运动、呼吸）" class="headerlink" title="3.2 强身健体（睡眠、冥想、运动、呼吸）"></a>3.2 强身健体（睡眠、冥想、运动、呼吸）</h3><p>第一种提高意志力的方法就是强身健体。原因很简单，因为意志力与大脑前额叶和心率有关，所以一切有利于恢复和增强它们健康的活动都能提高意志力。作者介绍了四种方法，分别是睡眠、冥想、运动和呼吸训练。</p>
<p>睡眠和冥想主要针对的是前额叶，睡眠让前额叶得到休息，从而恢复意志力，而冥想能够锻炼前额叶，就像举重能让更多血液流进肌肉从而锻炼肌肉一样，冥想能让更多血液流进前额叶从而锻炼前额叶，增强意志力。实际上，研究发现，仅仅3个小时的冥想练习，人们的意志力就会有大幅提高。</p>
<p>运动和呼吸训练则是通过提高“心率变异度”，来增强意志力。运动就不说了，作者介绍了一种非常简单的呼吸训练，具体做法是，将呼吸频率降低到每分钟4到6次，也就是每次呼吸用10到15秒时间。这样有没有效果呢？一项研究发现，滥用药物的成年人，每天进行20分钟的呼吸训练，就能提高心率变异度，减少冲动。</p>
<h3 id="3-3-“去道德化”，激活自控自我"><a href="#3-3-“去道德化”，激活自控自我" class="headerlink" title="3.3 “去道德化”，激活自控自我"></a>3.3 “去道德化”，激活自控自我</h3><p>我们前面提到“感觉良好”的“道德许可”是削弱意志力的一大杀手，这个要怎么破呢？对策是“去道德化”，激活自控自我。什么意思呢？就是说不要给事情贴上“好与坏”的道德标签，我不是做了好事，而是做了自己分内的事。你可能觉得这听起来很空，但实际上背后大有文章。还记得意志力的“两虎相争”吗，冲动自我和自控自我，如果我们为控制了冲动而干杯的话，是不是实际上我们认为冲动自我才是真实的自己呢？比如我刚刚发动全身力气去跑了步，回来觉得自己真了不起啊，于是给自己加了一个鸡腿。这说明我内心深处认为，真正的自己是不想跑步的，现在居然跑了，当然应该犒劳一下。</p>
<p>看到了吧，当我们把真实的自己看作是冲动自我的时候，就容易掉进道德许可的坑里。但是，实际上，我们并不只是冲动自我，而且也是自控自我，出去跑步的就是自控自我，是我本人。换句话说，跑步是我分内的事。当我们从这个角度看问题的时候，就能激活自控自我，我不是在做好事，而是在做我自己，从而避开道德许可的陷阱。这就是提高意志力的第二种方法，“去道德化”，激活自控自我。</p>
<h3 id="3-4-自我原谅"><a href="#3-4-自我原谅" class="headerlink" title="3.4 自我原谅"></a>3.4 自我原谅</h3><p>但是，如果最后还是冲动自我占了上风，做出了令自己后悔的事情，从而破罐子破摔，越来越刹不住车造成失控要怎么办呢？作者说，最有效的方法是原谅自己。这是否可靠呢？我们来看一个心理学实验。</p>
<p>研究人员请来关注自己体重的年轻女性参与实验，以科研的名义鼓励她们在4分钟之内吃完糖果，并且喝掉一大杯水，这样做的目的是让她们产生罪恶感，“天哪，吃了这么多，腰又变粗了”。接着，研究者给其中一半的人发信息说，有人会因为吃了糖果而自责，但是人非圣贤孰能无过，不要太苛求自己。另外一半人没有收到任何信息。之后，研究者端来了各种糖果，请所有参与者试吃每一种糖果，并填写糖果的味道，然后按好吃的程度排序，想吃多少都可以。结果显示，那些收到自我原谅信息的人只吃了28克糖果，没收到信息的人则吃掉了差不多70克糖果。看到自我原谅的威力了吧，这就是提高意志力的第三种方法。</p>
<h3 id="3-5-驾驭冲动"><a href="#3-5-驾驭冲动" class="headerlink" title="3.5 驾驭冲动"></a>3.5 驾驭冲动</h3><p>通过“去道德化”唤醒自控自我，然后通过“自我原谅”接纳冲动自我，这个完整的自我就一定能抵御诱惑吗？不一定的。比如“道理我都懂，但就是忍不住”，怎么办呢？不要担心，这里还有防止失控的第四个武器，叫做“驾驭冲动”。</p>
<p>来看一个堪称残酷的实验。华盛顿大学上瘾行为研究中心的学者鲍文，请来了已经忍耐12个小时没抽烟的12名老烟枪。这些人走进实验室，发现桌子上摆着12盒他们各自喜欢的香烟。鲍文要求这些人严格按照他的指令做事，这些指令是这样的：“拿起烟盒，停，看着它2分钟”“拿出香烟，停，看着它2分钟”“把烟放到嘴里，停，2分钟”，诸如此类，这样折腾了一个半小时，真是令人发指的实验。实验完毕，鲍文要求他们在接下来的一周，记录自己每天抽了多少烟，心情如何。一周结束后，有6个人抽烟情况和以前没什么两样，但是有6个人的抽烟冲动减少了37%。那么，这6个人到底经历了什么呢？</p>
<p>原来这6个人在做实验之前，鲍文对他们进行了驾驭冲动的训练。正是这个训练提高了他们的意志力。这个训练是这样的，当冲动来了的时候，在思维上，不要去控制它，花至少一分钟的时间去感觉它，观察它，看自己的身体和情绪有哪些变化。然后，在行为上，不要按冲动去做事，而是按照自己的目标做事。</p>
<h3 id="3-6-榜样的力量"><a href="#3-6-榜样的力量" class="headerlink" title="3.6 榜样的力量"></a>3.6 榜样的力量</h3><p>前面这些强身健体，去道德化，自我原谅和驾驭冲动的方法，都是从自身的角度在提高意志力，但是人毕竟是社会性动物，而且大脑的镜像神经元可不是吃干饭的，别人打个哈欠我们都会忍不住跟着打，又何况意志力呢？所以，第五种提高意志力的方法就是交朋结友。</p>
<p>那么，有助于促进我们意志力的小伙伴都长什么样呢？他们往往都是有健康生活习惯的，不让我们得意忘形的，不让我们觉得羞愧内疚的。遇见这样的人，赶紧去交个朋友吧。如果种种原因，交不上这样的朋友怎么办呢，那就把他们当作榜样来靠近。我们中国有句古话叫做“近朱者赤，近墨者黑”，虽不能至，心向往之，大白话就是，榜样的力量是无穷的。</p>
<h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>我简单的来总结一下，在我看来最重要的是你要理解<strong>什么是自控</strong>，你心里要有一个自控的结构图，比如下面这样：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E6%8E%A7%E5%8A%9B.png"></p>
<p>当你理解了自控的结构之后，再去看那些为什么失控的例子，你会发现都是自控的某个环节出现了问题导致的。</p>
<p>再来说说如何防止失控这个问题，其实很简单就是好好休息，好好吃饭，多锻炼（比如我就喜欢跑步、游泳、健身等等），因为这几件事情都能降低你体内的多巴胺，让你的自控系统获得能量。</p>
<p><strong>削弱意志力的四个因素：</strong></p>
<ol>
<li>生理基础</li>
<li>自我感觉良好</li>
<li>自我感觉糟糕</li>
<li>群体影响</li>
</ol>
<p><strong>提升意志力的5个方法：</strong></p>
<ol>
<li>强身健体</li>
<li>去道德化</li>
<li>自我原谅</li>
<li>驾驭冲动</li>
<li>交朋结友（这里说的朋友，主要是指那些意志力比较强的，可以作为榜样的人。）</li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title>人是可以改变的-读《被讨厌的勇气》</title>
    <url>/2021/10/26/book-notes/book-notes-psycholog/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94/</url>
    <content><![CDATA[<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20211026154512.png"></p>
<p>《被讨厌的勇气》<br>作者：【日】安见一郎 古贺史健<br>译者：渠海峡<br>出版社：北京，机械工业出版社，2015</p>
<hr>
<h1 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h1><p>首先我们来介绍一下阿德勒的个体心理学是什么。</p>
<h2 id="与弗洛伊德心理创伤学说的区别"><a href="#与弗洛伊德心理创伤学说的区别" class="headerlink" title="与弗洛伊德心理创伤学说的区别"></a>与弗洛伊德心理创伤学说的区别</h2><table>
<thead>
<tr>
<th>个体心理学</th>
<th>解释</th>
<th>心理创伤学说</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>目的论</td>
<td>为了达成目的，赋予经历以意义</td>
<td>原因论</td>
<td>因为过去的某段经历所以痛苦</td>
</tr>
<tr>
<td>整体论</td>
<td>-</td>
<td>二元论</td>
<td>-</td>
</tr>
<tr>
<td>此时此刻</td>
<td>-</td>
<td>纠结过去</td>
<td>-</td>
</tr>
</tbody></table>
<p><strong>目的论 VS 原因论</strong></p>
<p>弗洛伊德主张“<strong>原因论</strong>”，即你之所以痛苦是因为过去的某段经历。而阿德勒主张的是“<strong>目的论</strong>”，即你为了达成你的“目的”，赋予了你过去经历以某种意义。</p>
<p>在“人是可以改变的”这个前提下，每个人的生活方式（世界观、人生观）是自己选择的。而正因为生活方式是自己选择的，那就可以重新进行选择。</p>
<p><strong>整体论 VS 二元论</strong></p>
<p>把人看作不可分割的存在和作为“整体的我”来考虑的方式叫作“整体论”。</p>
<p><strong>此时此刻 VS 纠结过去</strong></p>
<p>因为过去和未来根本不存在，所以才要谈现在。起决定作用的既不是昨天也不是明天，而是“此时此刻”。</p>
<h2 id="勇气的心理学"><a href="#勇气的心理学" class="headerlink" title="勇气的心理学"></a>勇气的心理学</h2><ul>
<li>被讨厌的勇气</li>
<li>甘于平凡的勇气</li>
<li>获得幸福的勇气<ul>
<li>幸福即贡献感</li>
<li>前提：自由，不再寻求认可</li>
</ul>
</li>
</ul>
<h2 id="提出目标"><a href="#提出目标" class="headerlink" title="提出目标"></a>提出目标</h2><ul>
<li>行为方面的目标<ul>
<li>自立</li>
<li>与社会和谐共处</li>
</ul>
</li>
<li>支撑这种行为的心理方面目标<ul>
<li>“我有能力”的意识</li>
<li>“人人都是我的伙伴”的意识</li>
</ul>
</li>
</ul>
<h1 id="“病因”人际关系"><a href="#“病因”人际关系" class="headerlink" title="“病因”人际关系"></a>“病因”人际关系</h1><p>人际关系是一切的烦恼之源。</p>
<h2 id="烦恼来源"><a href="#烦恼来源" class="headerlink" title="烦恼来源"></a>烦恼来源</h2><p><strong>追求优越性</strong>：人无力的存活在这个世界上，并且希望摆脱这种状态，继而就有了普遍欲求。可以理解为“希望进步”、“追求理想状态”。</p>
<p><strong>自卑感</strong>：人追求优越性这一“希望进步的状态”之中，树立某写理想或目标并努力为之奋斗。同时对于无法达成理想的自己就会产生一种自卑感。</p>
<p><strong>自卑情结</strong>：指把自己的自卑感当作某种借口使用的状态。具体就像“我因为学历低所以无法成功”之类的。</p>
<p><strong>夸耀不幸</strong>：以自己的不幸来支配对方。</p>
<h2 id="矛盾起源"><a href="#矛盾起源" class="headerlink" title="矛盾起源"></a>矛盾起源</h2><p><strong>基本上，一切人际关系矛盾都起因于对别人的课题妄加干涉或者自己的课题被别人妄加干涉。</strong></p>
<h2 id="人生课题"><a href="#人生课题" class="headerlink" title="人生课题"></a>人生课题</h2><ul>
<li>工作课题</li>
<li>交友课题</li>
<li>爱的课题</li>
</ul>
<p>人生最大的谎言就是逃避人生课题。</p>
<h1 id="“处方”解决方式"><a href="#“处方”解决方式" class="headerlink" title="“处方”解决方式"></a>“处方”解决方式</h1><h2 id="入口-出发点：课题分离"><a href="#入口-出发点：课题分离" class="headerlink" title="入口&#x2F;出发点：课题分离"></a>入口&#x2F;出发点：课题分离</h2><p>我们必须从“这是谁的课题”这一观点出发，把自己的课题与别人的课题分离开来。</p>
<p><strong>辨别方法：只需要考虑“某种选择带来的结果最终要由谁来承担”</strong></p>
<p>可以把马带到水边，但不能强迫其喝水。</p>
<p>能改变自己的只有自己。</p>
<h2 id="支撑点-基本原理：横向关系"><a href="#支撑点-基本原理：横向关系" class="headerlink" title="支撑点&#x2F;基本原理：横向关系"></a>支撑点&#x2F;基本原理：横向关系</h2><p>阿德勒心理学反对一切纵向关系，提倡把所有的人际关系都看作横向关系。</p>
<h2 id="终极目标：共同体感觉"><a href="#终极目标：共同体感觉" class="headerlink" title="终极目标：共同体感觉"></a>终极目标：共同体感觉</h2><ul>
<li>自我接纳</li>
<li>他者信赖</li>
<li>他者贡献</li>
</ul>
<p><strong>通过他者贡献让自己有“我对共同体有用”的主观体会-&gt;感觉到自己的价值-&gt;获得勇气</strong></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title>人性本善-读《非暴力沟通》</title>
    <url>/2021/09/08/book-notes/book-notes-psycholog/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A/</url>
    <content><![CDATA[<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210908142542.png"></p>
<p>《非暴力沟通》<br>作者：【美】Marshall B.Rosenberg<br>译者：阮胤华<br>出版社：北京，华夏出版社，2013年</p>
<hr>
<h2 id="核心内容"><a href="#核心内容" class="headerlink" title="核心内容"></a>核心内容</h2><p>本书详细阐述了非暴力沟通的核心思想，而且还对非暴力沟通的四个要素做了细致的说明。这些沟通要素揭示了暴力行为的形成原理，也为避免暴力沟通提供了切实可行的方法。比如要想让语言变得平和，你需要表达客观事实，而不是对他人进行“道德评判”；面对自己的内心诉求，你需要去请求他人，而不是“强人所难”。暴力看似无处不在，但只要你懂得如何改变自己的价值取向，就能让人生变得更加美好。</p>
<p>这本书分享了三个重点内容：</p>
<ul>
<li>第一个重点内容是，从表面上来看，平等的交流是如何演变成暴力行为的；</li>
<li>第二个重点内容是，在暴力行为的背后，隐藏着什么样的深层次原因；</li>
<li>第三个重点内容是，如何运用非暴力沟通的四要素，来改变自己的人生走向？</li>
</ul>
<h2 id="从表面上来看，交流是如何演变成暴力行为的？"><a href="#从表面上来看，交流是如何演变成暴力行为的？" class="headerlink" title="从表面上来看，交流是如何演变成暴力行为的？"></a>从表面上来看，交流是如何演变成暴力行为的？</h2><p>卢森堡博士看来，有四个原因让我们的日常交流，演变成了暴力行为。这四个原因分别是：<strong>道德评判、进行比较、回避责任和强人所难</strong>。</p>
<p><strong>道德评判</strong>：有点像是用自己的价值观给别人贴标签。比如说，你上班的时候，每天都要擦办公桌，才会觉得桌子是干净的。可是你的同事小王呢，对自己的要求不高，一个星期就擦一次，也觉得挺干净了。结果呢，你马上就给小王贴上了“邋遢”和“懒惰”的标签。贴标签就是道德评判。这一刻，你的偏见也就产生了，这种偏见会阻碍你和同事进行平和的交流。</p>
<p><strong>进行比较</strong>：一个人总是和别人攀比，始终不能平心静气地看待别人，当然也就不能和别人处于一个平等的关系。关系不平等，还谈什么交流呢？</p>
<p><strong>回避责任</strong>：是指我们的表达方式，经常会忽略掉内心的情感根源。</p>
<p><strong>强人所难</strong>：很多中国家长喜欢把自己的意愿强加给孩子，强迫孩子们去做一些事情。父母强迫孩子做他不愿意，或者没有能力做到的事情，这显然也是一种暴力。</p>
<h2 id="在暴力行为的背后，隐藏着什么样的深层次原因？"><a href="#在暴力行为的背后，隐藏着什么样的深层次原因？" class="headerlink" title="在暴力行为的背后，隐藏着什么样的深层次原因？"></a>在暴力行为的背后，隐藏着什么样的深层次原因？</h2><p>一个对世界充满恶意的人，看什么都不顺眼，甚至他有时候还会想去报复社会。一个怀着这种仇恨心态的人，在生活中肯定是经常陷入暴力沟通了。</p>
<p>当一个人老是陷入暴力冲突当中，问题的关键有可能不在于他说话的方式，而在于他对自己和这个世界的看法。</p>
<p>其实，不论是对自己的看法，还是对世界的看法，都可以被看成是你的价值取向。自古以来我们就流传着两种价值取向，性本善和性本恶。在卢森堡博士看来，一切暴力行为的背后，其实都隐藏着性本恶的价值取向。<strong>当你认为人的本性是丑陋的、冷酷的，那么你自然会用相对应的暴力方式去应对。这时候你就会陷入暴力当中。而当你认为人的本性是善良的、积极的，那么你就会用相对应的温柔的方式去应对。你就自然会离暴力因素越来越远。</strong></p>
<h2 id="如何运用非暴力沟通的四要素，来改变自己的人生走向？"><a href="#如何运用非暴力沟通的四要素，来改变自己的人生走向？" class="headerlink" title="如何运用非暴力沟通的四要素，来改变自己的人生走向？"></a>如何运用非暴力沟通的四要素，来改变自己的人生走向？</h2><p>你对这个世界的看法，必然是你人生经历的结果。比如说，一个从小就被父亲家暴的小孩，长大后，他的价值取向很有可能会受到父亲的影响。他可能会因为憎恨自己的父亲，进而把报复自己的父亲、甚至是报复整个社会当成是人生目标。一个人活着是为了报复别人，这就是为仇恨而选择了生活，他的人生就会充满暴力。</p>
<p>但是有时候，一个人就算明明知道了自己的价值取向有问题，也很难纠正过来。因为这种人生经历的影响，太过于根深蒂固，不是一朝一夕可以彻底改变的。在本书作者看来，价值取向的转变，很像是佛教里所说的修行。通过修行，来让你相信这个世界是有爱的，你是为爱选择生活，而不是为了仇恨选择生活。只有让自己放下过去的心理包袱，才能够摆脱掉仇恨，让生活向着光明的方向发展。</p>
<p>那既然说改变自己是一种修行，具体又该怎么做呢？</p>
<p>针对这一点，卢森堡博士在书里提出了非暴力沟通的四个要素。<strong>这四个要素分别是：观察、感受、需要和请求</strong>。在日常生活当中，你可以通过这四个要素，来不断提醒自己，让自己的思维方式向着有爱的方向发展。</p>
<p>我们可以先从语言结构的角度，来理解一下非暴力沟通的这四个要素。</p>
<p>你平时所有的语言表达，都可以被切分成几个模块。是这些类似原因、结果的模块组合成了你的语言。<strong>而通过非暴力沟通四要素的逻辑来重新组织语言，就是让你的语言结构不再是随意任性的，而是组合成一种平等的、互相尊重的语言</strong>。</p>
<p>举个简单的例子来说，我交给你一份非常重要的商业机密文件，千叮咛万嘱咐地告诉你一定要保管好，结果呢？你刚答应完，扭头就把文件放在公共会议室，出去吃饭去了。等你回来，我可能会非常生气地说：“<strong>哎，我给你的这么重要的文件，你怎么就随便放在公共会议室啊</strong>？”注意了，这句话是责备别人的，是一种明显的暴力行为。那接下来，让我用非暴力沟通的思维逻辑再来表达一次。</p>
<p>非暴力沟通的第一个要素是观察，所以我首先观察到的是，你把机密文件放在了公共会议室里；第二个要素是感受，我的感受是什么呢？肯定是觉得首先这么放文件很不安全，其次我会感到很失望，因为我已经嘱咐过你要好好地保管文件，你也答应过我了，可你却没有放心上；第三个要素“需要”和第四个要素“请求”，指的是我先分辨出我需要什么，然后再向你提出请求。</p>
<p>这样一套思考程序下来，用非暴力沟通语言完整表达的话，就是“<strong>我看见刚才给你的重要文件没收起来，放在公共会议室了，这个我就担心不太安全，会议室里人来人往的，让客户看见就不好了。这么重要的文件既然交给你了，以后还是请你注意妥善保存</strong>。”</p>
<p>这就是非暴力沟通的语言表达方式。如果你熟悉了这样的语言结构，你和别人的关系会变得互相尊重、更加平等。不管是和人说话也好，反思自己也好，你都可以用这四个要素来检查自己的思维，看看你的思维是出于积极的价值取向，还是消极的价值取向。<strong>不断进行非暴力沟通的修行以后，你会发现，你对这个世界会有了一种性本善的信仰，这种信仰会让你避免暴力，生活在更加有爱的环境中</strong>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>第一个重点内容是，从表面上来看，平等的交流是如何演变成暴力行为的？让交流变成暴力行为的原因有四点，这四点分别是道德评判、进行比较、回避责任和强人所难。从表面上来看，是这四点原因让平等的交流难以实现，也是这四点原因，直接导致了暴力行为；</p>
<p>第二个重点内容是，在暴力行为的背后，隐藏着什么样的深层次原因？暴力的根本原因，其实是性本恶的价值取向。只有改变这种对世界的消极看法，才能真正帮助你摆脱暴力；</p>
<p>第三个重点内容是，如何运用非暴力沟通的四要素，来改变自己的人生走向？非暴力沟通的四要素是观察、感受、需要和请求。利用这四个要素，可以检查你平时的思维方式，以及这种思维方式的动机。当你的一切行为，都是出于对善的信仰，暴力也就在你的生活中消失了。</p>
<p>《非暴力沟通》这本书，讲的既是一种非常实用的沟通方法，同时，也是一种对生活的信仰。许多尝试过非暴力沟通的人，都体会到了非暴力沟通的价值。他们把非暴力沟通的四个要素写成卡片，每当有可能遇到暴力行为的时候，就看一看卡片，提醒自己不要陷入暴力当中，而是要从平等、尊重的角度来看待问题。非暴力沟通的思想，在很多个国家和国际组织里都产生了强烈反响。当越来越多的人学习非暴力沟通以后，他们发现，这个世界并非是冷酷无情的，而是可以通过人们的努力，变得越来越和谐。</p>
</br>
</br>]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title>不再思考 - 读《娱乐至死》</title>
    <url>/2019/12/07/book-notes/book-notes-sociology/%E5%A8%B1%E4%B9%90%E8%87%B3%E6%AD%BB/</url>
    <content><![CDATA[<p>每年的双十一都会屯一波书，从去年开始就一直想读这本书，期间因为种种原因一直没有读上。今年双十一终于屯上了，这批书到了之后，第一本看的就是这本<a href="https://book.douban.com/subject/26319730/">《娱乐至死》</a>，而它也没让我失望，给我带来了很多的思考。</p>
<p>有人说，时间和思考是人类最伟大的财富，希望我们每个人都不要浪费我们的财富。</p>
<p>这本书的出版是尼尔·波滋曼于1985年所著。主要是对20世纪后半叶美国文化中最重大的变化的探究：印刷术时代步入没落，而电视时代蒸蒸日上。这种转换从根本上不可逆的改变了公众话语的内容和意义，因为这样两种截然不同的媒介不可能传达同样的思想。随着印刷术影响的减退，政治、宗教、教育和任何其他构成公共事务的领域都要改变其内容，并且用最适用于电视的表达方式去重新定义。</p>
<p>这里面的“电视”替换成我们今天的“互联网”，“移动互联网”都是成立的。</p>
<h2 id="媒介"><a href="#媒介" class="headerlink" title="媒介"></a>媒介</h2><p><strong>媒介即隐喻</strong></p>
<p>“我相信，某个文化种交流的媒介对于这个文化精神重心和物质重心的形成有着决定性的影响。”</p>
<p>媒介的独特之处在于，虽然它指导着我们看待和了解事物的方式，但它的这种介入却往往不为人所注意。</p>
<p>伽利略说过，大自然的语言是数学。他这样说只是打个比方。大自然不会自己说话，我们的身体和大脑也不会说话。我们关于大自然以及这身的对话，是用一种我们觉得便利的“语言”进行的。我们认识到的自然、智力、人类动机或思想，并不是它们本来的面目，而是它们在语言种的表现形式。我们的语言即媒介，我们的媒介即隐喻，我们隐喻的创造了我们的文化内容。</p>
<p>我们透过媒介去认识自然、世界、社会等等。</p>
<p><strong>媒介即认识论</strong></p>
<p>人类对于真理的认识是同表达方式密切相连的。真理不能，也从没有毫无修饰的存在。它必须穿着某种合适的外衣出现，否则就可能得不到承认，这也正说明了“真理”是一种文化偏见。一种文化认为用某种象征形式表达的真理是真实的，而另一种文化却可能认为这样的象征形式是琐碎无聊的。</p>
<p>尼采说过，任何哲学都是某个阶段生活的哲学。我们还应该加一句，任何认识论都是某个媒介发展阶段的认识论。</p>
<h2 id="印刷机文化"><a href="#印刷机文化" class="headerlink" title="印刷机文化"></a>印刷机文化</h2><p>文中介绍了从一开始到19世纪，美国比任何一个社会都痴迷于铅字以及建立在铅字基础上的演讲术。</p>
<p>而这种印刷机文化赋予了人们推崇客观和理性的思维，同时鼓励严肃、有序和具有逻辑性的公共话语。</p>
<p>文字不能不正内容的真实性，而是形成了一个语境，让人们可以问“这是真的还是假的”。</p>
<h2 id="娱乐文化"><a href="#娱乐文化" class="headerlink" title="娱乐文化"></a>娱乐文化</h2><p>电视的思维方式和印刷术的思维方式是格格不入的；电视对话会助长语无伦次和无聊琐碎；电视只有一种不变的声音——娱乐的声音。</p>
<p>娱乐是电视上所有话语的超意识形态。不管是什么内容，也不管采取什么视角，电视上的一切都是为了给我们提供娱乐。</p>
<p>娱乐通过创造出一种可以被称为“假信息”的种类改变了“得到消息”的含义。假信息并不意味着错误的信息，而是意味着使人产生误解的信息——没有依据、毫无关联、支离破碎或流于表面的信息——这些信息让人产生错觉，以为自己知道了很多事实，其实却离事实的真相越来越远。</p>
<h2 id="XX即娱乐"><a href="#XX即娱乐" class="headerlink" title="XX即娱乐"></a>XX即娱乐</h2><p>在这个一切即娱乐的时代，我们通过给政治、教育…披上娱乐的外衣，从而使其火遍大江南北。</p>
<p>但是这里面有一个矛盾的点需要我们去思考：那就是娱乐的本质是碎片化，是持续不断的刺激。但是政治、教育等的本质却是逻辑、思考等。所以将属性如此矛盾的两件事情放在一起，我们到底是通过娱乐达到让大众了解政治，收获教育的目的，还是假借政治、教育等名目去行娱乐之事？我相信我们每个人心里都有自己的答案。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>借用全书的最后一句话来结束本文：“人们感到痛苦的不是他们用笑声代替了思考，而是他们不知道自己为什么笑以及为什么不再思考。”</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>社会学</tag>
      </tags>
  </entry>
  <entry>
    <title>多因素 - 读《异类》</title>
    <url>/2019/05/07/book-notes/book-notes-sociology/%E5%BC%82%E7%B1%BB/</url>
    <content><![CDATA[<p>所谓的成功是一个众多因素综合决定的结果。</p>
<ul>
<li>基本要求：中上水平的智商（逻辑能力）</li>
<li>成长环境决定了你的实践智力（社交常识）</li>
<li>文化传承决定了你看待这个世界的方法和行为模式</li>
<li>足够多的机遇+勤奋可以让你在某一项技能上积累到一万小时的时间</li>
<li>此外，在你掌握的技能达到巅峰的时候，这项技能还要恰巧是这个时代的中心。</li>
</ul>
<p>而这众多的因素当中很多是你出生的那一刻就已经确定下来了。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>社会学</tag>
      </tags>
  </entry>
  <entry>
    <title>系统设计和架构之基础</title>
    <url>/2019/09/23/cs-skill/cs-skill-architecture/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><p><strong>响应时间</strong></p>
<p>指某个请求从发出到收到响应消耗的时间。</p>
<p>在对响应时间进行测试时，通常采用重复请求的方式，然后计算平均响应时间。</p>
<p><strong>吞吐量</strong></p>
<p>指单位时间内系统处理的请求数量。</p>
<ul>
<li>TPS：每秒事务数</li>
<li>QPS：每秒查询数</li>
<li>HPS：每秒HTTP请求数</li>
</ul>
<p><strong>并发用户数</strong></p>
<p>指系统能同时处理的并发用户请求数量。</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="Web-前端性能优化"><a href="#Web-前端性能优化" class="headerlink" title="Web 前端性能优化"></a>Web 前端性能优化</h3><p><strong>浏览器访问优化</strong></p>
<ul>
<li>减少 http 请求</li>
<li>使用浏览器缓存</li>
<li>启用压缩</li>
<li>CSS 放在页面最上面、JavaScript 放在页面最下面</li>
<li>减少 Cookie 传输</li>
</ul>
<p><strong>CDN 加速</strong></p>
<p>CDN（内容分发网络）的本质仍然是一个缓存，而且将数据缓存在离用户最近的地方，使用户以最快速度获取数据，即所谓网络第一跳。</p>
<p>CDN 能够缓存的一般是静态资源，如图片、文件、CSS、Script脚本、静态网页等，但是这些文件访问频率很高，将其缓存在CDN可极大改善网页的打开速度。</p>
<p><strong>反向代理</strong></p>
<p>反向代理除了安全功能，也可以通过配置缓存功能加速Web请求。</p>
<h3 id="应用服务器性能优化"><a href="#应用服务器性能优化" class="headerlink" title="应用服务器性能优化"></a>应用服务器性能优化</h3><p><strong>缓存</strong></p>
<blockquote>
<p>网站性能优化第一定律：优先考虑使用缓存优化性能。</p>
</blockquote>
<p>缓存能够提高性能的原因：</p>
<ul>
<li>缓存数据通常位于内存等介质中，访问速度特别快；</li>
<li>缓存数据通常是通过计算处理得到的，可以起到减少计算时间的作用；</li>
<li>缓存数据可以位于靠近用户的地理位置上（CDN）；</li>
</ul>
<p><strong>异步</strong></p>
<p>某些流程可以将操作转换为消息，将消息发送到消息队列之后立即返回，之后这个操作会被异步处理。</p>
<p><strong>集群</strong></p>
<p>在网站高并发场景下，使用负载均衡技术为一个应用构建一个由多台服务器组成的服务器集群，将并发访问请求分发到多台服务器上处理，避免单一服务器因负载压力过大而响应缓慢，使用户请求具有更好的响应延迟特性。</p>
<p><strong>代码优化</strong></p>
<h3 id="存储性能优化"><a href="#存储性能优化" class="headerlink" title="存储性能优化"></a>存储性能优化</h3><ol>
<li>机械硬盘 vs 固态硬盘</li>
<li>B+ 树 vs LSM 树</li>
<li>RAID vs HDFS</li>
</ol>
<h1 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h1><h2 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h2><p>保证高可用的主要手段是使用冗余，当某个服务器故障时就请求其它服务器。</p>
<p>应用服务器的冗余比较容易实现，只要保证应用服务器不具有状态，那么某个应用服务器故障时，负载均衡器将该应用服务器原先的用户请求转发到另一个应用服务器上，不会对用户有任何影响。</p>
<p>存储服务器的冗余需要使用主从复制来实现，当主服务器故障时，需要提升从服务器为主服务器，这个过程称为切换。</p>
<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>对 CPU、内存、磁盘、网络等系统负载信息进行监控，当某个信息达到一定阈值时通知运维人员，从而在系统发生故障之前及时发现问题。</p>
<h1 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h1><p>指不断向集群中添加服务器来缓解不断上升的用户并发访问压力和不断增长的数据存储需求。</p>
<h2 id="伸缩性与性能"><a href="#伸缩性与性能" class="headerlink" title="伸缩性与性能"></a>伸缩性与性能</h2><p>如果系统存在性能问题，那么单个用户的请求总是很慢的；</p>
<p>如果系统存在伸缩性问题，那么单个用户的请求可能会很快，但是在并发数很高的情况下系统会很慢。</p>
<h2 id="实现伸缩性"><a href="#实现伸缩性" class="headerlink" title="实现伸缩性"></a>实现伸缩性</h2><p>应用服务器只要不具有状态，那么就可以很容易地通过负载均衡器向集群中添加新的服务器。</p>
<p>关系型数据库的伸缩性通过 Sharding 来实现，将数据按一定的规则分布到不同的节点上，从而解决单台存储服务器的存储空间限制。</p>
<p>对于非关系型数据库，它们天生就是为海量数据而诞生，对伸缩性的支持特别好。</p>
<h1 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h1><p>指的是添加新功能时对现有系统的其它应用无影响，这就要求不同应用具备低耦合的特点。</p>
<p>实现可扩展主要有两种方式：</p>
<ul>
<li>使用消息队列进行解耦，应用之间通过消息传递进行通信；</li>
<li>使用分布式服务将业务和可复用的服务分离开来，业务使用分布式服务框架调用可复用的服务。新增的产品可以通过调用可复用的服务来实现业务逻辑，对其它产品没有影响。</li>
</ul>
<h1 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h1><p>要求系统在应对各种攻击手段时能够有可靠的应对措施。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>《大型网站技术架构：核心原理与案例分析》</li>
</ul>
<p>欢迎关注我的公众号：荒古传说        </p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20190806153414.png">
</center>
]]></content>
      <categories>
        <category>专业技能</category>
        <category>架构设计</category>
      </categories>
      <tags>
        <tag>架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>如何做好监控告警</title>
    <url>/2024/01/15/cs-skill/cs-skill-online/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E7%9B%91%E6%8E%A7%E5%91%8A%E8%AD%A6/</url>
    <content><![CDATA[<h2 id="一、为什么要做监控告警"><a href="#一、为什么要做监控告警" class="headerlink" title="一、为什么要做监控告警"></a>一、为什么要做监控告警</h2><blockquote>
<p>“你说说，没有仪表盘的车，你敢开吗？”<br>“没有仪表盘的车开在路上，你怎么知道现在是什么情况？”<br>“客户说你这车又蹦了，咋知道什么时候好的？啥时候出的问题？”</p>
</blockquote>
<p>将思考转换到现实的软件系统中，可想而知没有监控系统的情况下，也就是没有“仪表盘”的情况下实在太可怕了。</p>
<p>你的故障永远都是你的客户告诉你的，而…在什么时候发生的，你也无法确定，只能通过客户反馈倒退时间节点，最后从错误日志中得到相对完整的日志信息。</p>
<p>更要命的是你无法掌握主动权，错误日志有可能会有人漏记录，平均修复时间（MTTR）更不用想了，需要从 0.1 开始定位，先看 APP是哪个模块报错，再猜测是哪个服务导致，再打开链路追踪系统，或是日志平台等。</p>
<p>稍微复杂点的，排查来来往往基本都是半小时、一小时以上，那4 个 9 肯定是达不到的了，一次 P0 几小时怕不是绩效也凉凉，因为故障修复的速度实在是太慢了。</p>
<p>那归根结底，想破局怎么办？核心第一步就是把监控告警给建设好。</p>
<h2 id="二、监控与报警的目标是什么"><a href="#二、监控与报警的目标是什么" class="headerlink" title="二、监控与报警的目标是什么"></a>二、监控与报警的目标是什么</h2><p>简单说，<strong>监控的核心目标就是要解决好两个问题：其一，什么东西出故障了。其二，为什么它出故障了，根因在哪里。</strong></p>
<p>一个监控与报警的系统（简称监控系统），在于它可以让一个业务系统在发生故障时主动通知我们，或者告诉我们即将发生什么。当系统无法自动修复这个问题时，通过报警引导 SRE 人工来介入。SRE 首先判断目前是否真实存在某个故障，如果存在故障则采取手段来消除故障，解决故障后最终还要找出导致故障的根源问题，并推动各方去彻底解决掉它，避免未来出现类似的问题。</p>
<p>一个初级的监控系统是比较好做的。我们坚持不懈地往里面加各种监控项，系统看起来越来越完善。很多人会由此而感觉到了满足。但是，一个有 “完善的监控项” 的监控系统，是不是就是一个好的监控系统了？这当然不是。<strong>要做好监控，我们一定要分清楚什么是现象，而什么是原因</strong>。</p>
<p><strong>某个监控项不正常了，“某个东西出故障了”，这只是一种现象（Symptom）。但这个监控项 “为什么出问题” 了，则是原因。我们找到的原因，也可能只是中间原因，而不是根因（Root Cause）。</strong></p>
<p>在一个复杂系统中，某一个服务的现象可能是另外一个服务的原因。例如，数据库性能问题。数据库读操作很缓慢是数据库 SRE 角度检测到的一个现象。然而，对前端业务的 SRE 来说，他们看到的是网站缓慢这个现象，而数据库读操作的缓慢则是原因。当然数据库慢只是一个中间原因，它还无法对应到一个明确的动作，<strong>但这对缩小问题定位范围已经产生了巨大作用</strong>。</p>
<p><strong>一个完善的监控系统，并不是 “报警很多很完善” 的系统，而是 “信噪比高，有故障就报警，有报警就直指根因” 的监控系统。</strong></p>
<p><strong>“信噪比高”关注的是误报率问题</strong>。我们不应该仅仅因为 “某东西看起来有点问题” 就发出报警。报警处理会占用员工的宝贵时间。如果该员工正在工作时间段，该报警的处理会打断他原本的工作。如果该员工正在家，该报警的处理则会影响他的个人生活，甚至是把他从睡眠中叫醒。当报警出现得太频繁时，员工就会进入“狼来了” 效应，怀疑报警的有效性甚至忽略报警。有的时候在报警过多的时候，甚至会忽略掉真实发生的故障。由于无效信息太多，分析和修复可能会变慢，故障时间也会相应延长。高效的报警系统应该提供足够的信息，并且误报率非常低。</p>
<p><strong>“有故障就报警” 关注的是报警的覆盖率</strong>。如果我们通过客户报障或其他手段发现故障，对于监控系统来说，就应该认为是一次监控事故。</p>
<p><strong>“有报警就直指根因” 关注的是报警的有效性和排障的效率</strong>。一个初级的监控系统，往往很容易产生的报障现象是，线上发生一个故障会同时会产生大量的报警，这些报警杂乱无章，接警人看到一堆报警后，并没有有效的信息指引他如何快速消除故障，并找到故障的根本原因。</p>
<h2 id="三、监控服务"><a href="#三、监控服务" class="headerlink" title="三、监控服务"></a>三、监控服务</h2><h3 id="3-1-日志：监控与报警的基础"><a href="#3-1-日志：监控与报警的基础" class="headerlink" title="3.1. 日志：监控与报警的基础"></a>3.1. 日志：监控与报警的基础</h3><p>一个现代化的监控与报警系统，最底层往往基于一个日志系统。什么是日志？它不局限于业务服务输出的程序日志，实际上更多的数据来源是各种系统指标的采集。简单说，凡是时序相关的、持续产生的数据，都可以称之为日志。</p>
<p>原始的日志有可能是结构化的，也可能是非结构化的。如果是非结构化的数据，那这就需要先经过文本解析过程进行结构化。结构化后的日志存储系统，本质上就是一个时序数据库。</p>
<p>日志通过收集、结构化、清洗等步骤后，就可以对外提供日志分析和检索服务。分析和检索的结果可以直接提供数据结果，也可以用报表形式呈现，或者在满足特定条件下触发报警。</p>
<p>采用时序数据库来做监控系统的好处是，不依赖特定的脚本来判断系统是否正常工作，而是依赖一种标准数据分析模型进行报警。这就使得批量、大规模、低成本的数据收集变得可能。</p>
<p>收集回来的数据可以同时用来渲染图表和报警。报警规则往往用简单的数学表达式形式表达。这样，数据收集过程就不再是一个短暂的一次性过程，所有收集回来的历史数据都可以被用来作为报警规则的计算因素。</p>
<p>不同监控规则产生的报警（alert）可能有不同的优先级，比如紧急状态和一般状态。紧急状态的报警通常意味着已经产生或即将产生用户可见的影响，需要立刻介入处理。而一般状态则可以延迟到第二天再处理。报警的目标对象不一定是某个人，而可能是某个系统，比如工单。</p>
<p>当然，监控一个指标并不一定是出于报警的考虑。它还可以有各种原因，如下：</p>
<ul>
<li>分析长期趋势。例如每日活跃用户的数量，以及数量增长的速度。</li>
<li>跨时间范围的比较，或者是观察 AB 测试组之间的区别。例如，增加新节点后，memcache 的缓存命中率是否增加？网站是否比上周速度要慢？使用 A 方案和 B 方案哪个更有助于用户的活跃？</li>
<li>临时性的回溯分析，即在线调试。例如，我们网站的请求延迟刚刚大幅增加了，有没有其他的现象同时发生？</li>
</ul>
<h2 id="四、添加监控项"><a href="#四、添加监控项" class="headerlink" title="四、添加监控项"></a>四、添加监控项</h2><p>搭建好了监控系统，收集上来了监控数据，我们第一件事情就是添加监控项。不得不承认，它是监控与报警系统中最难的一件事情。我们都需要注意些什么呢？</p>
<h3 id="4-1-三大类监控项"><a href="#4-1-三大类监控项" class="headerlink" title="4.1. 三大类监控项"></a>4.1. 三大类监控项</h3><p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20240118021233.png"></p>
<ul>
<li>业务逻辑：项目所对应的服务其承担的业务逻辑，通常需要对其进行度量。例如：每秒的下单数等。</li>
<li>应用程序：应用程序。</li>
<li>硬件资源：服务器资源情况等。</li>
</ul>
<h3 id="4-2-四个黄金指标"><a href="#4-2-四个黄金指标" class="headerlink" title="4.2. 四个黄金指标"></a>4.2. 四个黄金指标</h3><p><strong>监控系统的 4 个黄金指标分别是：延迟、流量、错误和饱和度。</strong></p>
<p><strong>延迟，也就是服务处理某个请求所需要的时间</strong>。延迟指标区分成功请求和失败请求很有必要。例如，某个由于数据库连接丢失或者其他后端问题造成的 HTTP 500 错误可能延迟很低。在计算总体延迟时，如果将 HTTP 500 回复的延迟也计算在内的话，可能会产生误导性的结果。但是，“慢” 错误要比 “快” 错误更糟！极少量的慢错误请求就可能导致系统吞吐能力的大幅降低。因此，监控错误回复的延迟是很重要的。</p>
<p><strong>流量，是系统负载的度量方式</strong>。通常我们会使用某个高层次的指标来度量，比如 IOPS、每秒交易量等。不同的业务系统的流量指标有较大差别。例如，对于普通 Web 服务器来说，该指标通常是每秒 HTTP 请求量（IOPS），同时可能按请求类型分类（静态请求与动态请求）。对于音频流媒体系统来说，这个指标可能是网络 I&#x2F;O 速率，或者并发会话数量。针对键值存储系统来说，指标可能是每秒交易数量，或每秒的读取操作数量。</p>
<p><strong>错误，也就是请求失败的数量</strong>。请求失败的表现很多样。最简单的当然是显式失败，例如 HTTP 回复 500 状态码。还有的请求可能是隐式失败，例如 HTTP 回复虽然是 200，但回复内容中提示出现了错误。还有一种是策略原因导致的失败。例如，如果我们要求回复在 1s 内发出，任何超过 1s 的请求就都认为是失败请求。</p>
<p><strong>饱和度（Saturation），它度量的是服务容量有多 “满”</strong>。通常是系统中目前最为受限的某种资源的某个具体指标的度量。比如，在内存受限的系统中，即为内存的使用率；在 I&#x2F;O 受限的系统中，即为 I&#x2F;O 的使用率。要注意，很多系统在达到 100% 利用率之前性能就会严重下降，增加一个利用率目标也是非常重要的。</p>
<p>饱和度是最需要进行预测的指标。比如，一个典型的预测是：“看起来数据库会在 5 个小时内填满硬盘”。</p>
<p>在复杂系统中，饱和度可以配合其他高层次的负载度量来使用。例如，该服务是否可以正常处理两倍的流量，是否可以应对 10% 的额外流量？这些是 SRE 面临的非常现实的容量规划上的问题。</p>
<p>为什么我们需要做负载测试，也是为了评判服务的饱和度，究竟受何种度量指标的影响。大部分服务都习惯使用某种间接指标，例如 CPU 利用率，或者网络带宽等来评判饱和度，因为这些指标通常有一个固定的已知的上限。</p>
<p>延迟增加是饱和度的前导现象。所以 99% 的请求延迟（在某一个小的时间范围内，例如五分钟）可以作为一个饱和度早期预警的指标。</p>
<p>如果已经成功度量了这四个黄金指标，且在某个指标出现故障时能够发出告警(或者快要发生故障)，那么在服务的监控层面来讲，基本也就满足了初步的监控诉求。也就是可以做到知道了是什么出问题，问题出在哪里，单这一步就已经提高了不少定位问题的时间效率，是一个从 0 到 1 的起步阶段。</p>
<h3 id="4-3-监控指标"><a href="#4-3-监控指标" class="headerlink" title="4.3. 监控指标"></a>4.3. 监控指标</h3><p>结合三大类监控项和四个黄金指标规划整个系统的度量指标。可以划分出如下几种类型：</p>
<ul>
<li>业务服务<ul>
<li>延迟，P995</li>
<li>流量，QPS</li>
<li>错误，异常码</li>
</ul>
</li>
<li>应用程序<ul>
<li>延迟，P995</li>
<li>流量，QPS</li>
<li>错误，异常码</li>
</ul>
</li>
<li>系统层面&#x2F;语言层面<ul>
<li>延迟，P995</li>
<li>流量，QPS</li>
<li>饱和度，百分比</li>
</ul>
</li>
</ul>
<h2 id="五、配置报警"><a href="#五、配置报警" class="headerlink" title="五、配置报警"></a>五、配置报警</h2><p>在完成监控指标和体系的建设后，告警如何做，成为了一大难题，再好的监控体系，闭环做不好，就无法发挥出很大的作用。当我们打算为监控系统增加新规则时，在心中回答以下问题：</p>
<ul>
<li>该规则是否能够检测到一个目前检测不到的、紧急的、有操作性的，即将发生或者已经发生的用户可见故障？</li>
<li>是否可以忽略这条报警？是否还有其他人也会收到这条报警？</li>
<li>这条报警是否确实显示了用户正在受到影响？是否存在用户没有受到影响也可以触发这条规则的情况？例如，系统维护状态下发出的报警是否应该被过滤掉。</li>
<li>收到报警后，是否要进行某个操作？是否需要立即执行该操作，还是可以等到第二天早上再进行？该操作是否可以被安全地自动化？</li>
<li>该操作的效果是长期的，还是短期的？</li>
</ul>
<p>以上这些问题其实反映了在报警上的深层次的理念：</p>
<ul>
<li>每当收到紧急状态的报警时，应该立即需要我进行某种操作。每天只能进入紧急状态几次，太多就会导致“狼来了”效应。</li>
<li>每个紧急状态的报警都应该是可以具体操作的。</li>
<li>每个紧急状态的报警的处理都应该需要某种智力分析过程。如果某个报警只是需要一个固定的机械化动作，那么它就应该被自动化。</li>
<li>每个紧急状态的报警都应该是关于某个新问题的，不应该彼此重叠。</li>
</ul>
<h2 id="六、故障响应"><a href="#六、故障响应" class="headerlink" title="六、故障响应"></a>六、故障响应</h2><p>接到报警我们应该怎么做？</p>
<p>接警后的第一哲学，是尽快消除故障。找根因不是第一位的。如果故障原因未知，我们可以尽量地保留现场，方便故障消除后进行事故的根因分析。</p>
<p>每一个监控项的报警应该尽可能代表一个清晰的故障场景。这会极大改善监控的有效性，直指根因，消除故障自然也就更快速。</p>
<p>虽然越少越好，但是不清楚故障原因的报警是难以避免的，否则我们的报警就难以完整覆盖所有的故障。比如，对于业务服务的入口级的故障，我们怎么也得报出来。每发生一次新的入口级的故障场景，我们就有必要把这个故障场景独立出来，这样下一次出现同类故障时我们就能够直接定位到根因了。</p>
<p>一般来说，有清晰的故障场景的监控报警，都应该有故障恢复的预案。而在那些故障原因不清晰的情况下，消除故障的最简方法是基于流量调度，它可以迅速把用户请求从故障域切走，同时保留了故障现场。</p>
<p>解决了线上的故障，我们就要开始做故障的根因分析，找到问题发生的源头。</p>
<p>这主要仰仗两种分析方法。</p>
<p>一种是看看同时间段下，除了我们的故障现象外，还有那些异常现象同时发生了。如果我们的监控数据足够全面，这种分析方法可以很快地定位到 “怀疑对象”。</p>
<p>另一种方式是分析故障请求的调用链。这方面的技术已经非常成熟。很多公司的业务实现都会把请求从前端入口到后端的整个调用过程通过一个 request id 串起来。</p>
<p>通过随机抽样一些故障请求的日志，然后在日志系统中搜索 request id 找到整个调用链，分析调用链找到问题的根源。</p>
]]></content>
      <categories>
        <category>专业技能</category>
        <category>业务治理</category>
      </categories>
      <tags>
        <tag>业务治理</tag>
      </tags>
  </entry>
  <entry>
    <title>UML 类图</title>
    <url>/2019/03/18/cs-skill/cs-skill-system/UML-%E7%B1%BB%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>这里不会将UML的各种元素都提到，我只想讲讲类图中各个类之间的关系； 能看懂类图中各个类之间的线条、箭头代表什么意思后，也就足够应对 日常的工作和交流； 同时，我们应该能将类图所表达的含义和最终的代码对应起来。</p>
<p>下面看一个示例：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tKfTcgy1g16y6tuupmj31gv0u079d.jpg"></p>
<p>看完这篇文章之后，能看懂这张图中类与类之间的关系，目的就达到了。</p>
<h1 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h1><h2 id="泛化关系-generalization"><a href="#泛化关系-generalization" class="headerlink" title="泛化关系(generalization)"></a>泛化关系(generalization)</h2><p>类的继承结构表现在UML中为：**泛化(generalize)与实现(realize)**。</p>
<p>泛化关系用一条带空心箭头的直接表示，如下图表示（A继承自B）:</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tKfTcgy1g16ybu1q82j308a0363yh.jpg"></p>
<p><font color=#FF0000><strong>最终在代码中，泛化关系表现为继承非抽象类。</strong></font></p>
<h2 id="实现关系-realize"><a href="#实现关系-realize" class="headerlink" title="实现关系(realize)"></a>实现关系(realize)</h2><p>实现关系用一条带空心箭头的虚线表示。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tKfTcly1g16ye5wt4xj309407hdfz.jpg"></p>
<p><font color=#FF0000><strong>最终代码中，实现关系表现为继承抽象类。</strong></font></p>
<h2 id="聚合关系-aggregation"><a href="#聚合关系-aggregation" class="headerlink" title="聚合关系(aggregation)"></a>聚合关系(aggregation)</h2><p>聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成；</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tKfTcly1g16ymmzi7dj307o02v0sp.jpg"></p>
<p>聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义。</p>
<p>与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在。</p>
<h2 id="组合关系-composition"><a href="#组合关系-composition" class="headerlink" title="组合关系(composition)"></a>组合关系(composition)</h2><p>组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成:</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tKfTcgy1g170kjxad7j307t02tweg.jpg"></p>
<p>与聚合关系一样，组合关系同样表示整体由部分构成的语义。</p>
<p>但聚合关系不同的是，组合关系一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了。</p>
<h2 id="关联关系-association"><a href="#关联关系-association" class="headerlink" title="关联关系(association)"></a>关联关系(association)</h2><p>关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系。</p>
<p>关联关系默认不强调方向，表示对象间相互知道。如果特别强调方向，如下图，表示A知道B，但 B不知道A：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tKfTcgy1g170mogohoj308903a0sp.jpg"></p>
<p><font color=#FF0000>在最终代码中，关联对象通常是以成员变量的形式实现的。</font></p>
<h2 id="依赖关系-dependency"><a href="#依赖关系-dependency" class="headerlink" title="依赖关系(dependency)"></a>依赖关系(dependency)</h2><p>依赖关系是用一套带箭头的虚线表示的。如下图表示A依赖于B，他描述一个对象在运行期间会用到另一个对象的关系：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tKfTcgy1g170ntuq3lj30860353yh.jpg"></p>
<p>与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化；</p>
<p>显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生；</p>
<p><font color=#FF0000>在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性。<font></p>
]]></content>
      <categories>
        <category>专业技能</category>
        <category>系统设计</category>
      </categories>
      <tags>
        <tag>系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式系统唯一ID生成方案浅析</title>
    <url>/2019/10/12/cs-skill/cs-skill-system/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h1 id="分布式系统唯一ID生成方案浅析"><a href="#分布式系统唯一ID生成方案浅析" class="headerlink" title="分布式系统唯一ID生成方案浅析"></a>分布式系统唯一ID生成方案浅析</h1><p>在复杂分布式系统中，往往需要对大量的数据和消息进行唯一标识。业务ID需要满足的要求如下</p>
<ul>
<li>全局唯一性：不能出现重复的ID号，既然是唯一标识，这是最基本的要求。</li>
<li>趋势递增：在MySQL InnoDB引擎中使用的是聚集索引，由于多数RDBMS使用B-tree的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。</li>
<li>单调递增：保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求。</li>
<li>信息安全：如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要ID无规则、不规则。</li>
</ul>
<h2 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h2><p>UUID(Universally Unique Identifier)的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的36个字符，示例：550e8400-e29b-41d4-a716-446655440000，到目前为止业界一共有5种方式生成UUID，详情见IETF发布的UUID规范<a href="https://www.ietf.org/rfc/rfc4122.txt">A Universally Unique IDentifier (UUID) URN Namespace</a></p>
<p>优点:</p>
<ul>
<li>性能非常高：本地生成，没有网络消耗。</li>
</ul>
<p>缺点:</p>
<ul>
<li><p>不易于存储：UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用。</p>
</li>
<li><p>信息不安全：基于MAC地址生成UUID的算法可能会造成MAC地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。</p>
</li>
</ul>
<p>UUID作为主键时在特定的环境会存在一些问题，比如做DB主键的场景下，UUID就非常不适用：</p>
<ul>
<li>MySQL官方有明确的建议主键要尽量越短越好，36个字符长度的UUID不符合要求。</li>
</ul>
<blockquote>
<p>All indexes other than the clustered index are known as secondary indexes. In InnoDB, each record in a secondary index contains the primary key columns for the row, as well as the columns specified for the secondary index. InnoDB uses this primary key value to search for the row in the clustered index. <strong>If the primary key is long, the secondary indexes use more space, so it is advantageous to have a short primary key</strong>.</p>
</blockquote>
<ul>
<li>对MySQL索引不利：如果作为数据库主键，在InnoDB引擎下，UUID的无序性可能会引起数据位置频繁变动，严重影响性能。</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">v4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">sprintf</span>(<span class="string">&#x27;%04x%04x-%04x-%04x-%04x-%04x%04x%04x&#x27;</span>,</span><br><span class="line"></span><br><span class="line">            // <span class="number">32</span> bits <span class="keyword">for</span> <span class="string">&quot;time_low&quot;</span></span><br><span class="line">            <span class="title function_ invoke__">mt_rand</span>(<span class="number">0</span>, <span class="number">0xffff</span>), <span class="title function_ invoke__">mt_rand</span>(<span class="number">0</span>, <span class="number">0xffff</span>),</span><br><span class="line"></span><br><span class="line">            // <span class="number">16</span> bits <span class="keyword">for</span> <span class="string">&quot;time_mid&quot;</span></span><br><span class="line">            <span class="title function_ invoke__">mt_rand</span>(<span class="number">0</span>, <span class="number">0xffff</span>),</span><br><span class="line"></span><br><span class="line">            // <span class="number">16</span> bits <span class="keyword">for</span> <span class="string">&quot;time_hi_and_version&quot;</span>,</span><br><span class="line">            // four most significant bits holds version number <span class="number">4</span></span><br><span class="line">            <span class="title function_ invoke__">mt_rand</span>(<span class="number">0</span>, <span class="number">0x0fff</span>) | <span class="number">0x4000</span>,</span><br><span class="line"></span><br><span class="line">            // <span class="number">16</span> bits, <span class="number">8</span> bits <span class="keyword">for</span> <span class="string">&quot;clk_seq_hi_res&quot;</span>,</span><br><span class="line">            // <span class="number">8</span> bits <span class="keyword">for</span> <span class="string">&quot;clk_seq_low&quot;</span>,</span><br><span class="line">            // two most significant bits holds zero <span class="keyword">and</span> one <span class="keyword">for</span> variant DCE1.<span class="number">1</span></span><br><span class="line">            <span class="title function_ invoke__">mt_rand</span>(<span class="number">0</span>, <span class="number">0x3fff</span>) | <span class="number">0x8000</span>,</span><br><span class="line"></span><br><span class="line">            // <span class="number">48</span> bits <span class="keyword">for</span> <span class="string">&quot;node&quot;</span></span><br><span class="line">            <span class="title function_ invoke__">mt_rand</span>(<span class="number">0</span>, <span class="number">0xffff</span>), <span class="title function_ invoke__">mt_rand</span>(<span class="number">0</span>, <span class="number">0xffff</span>), <span class="title function_ invoke__">mt_rand</span>(<span class="number">0</span>, <span class="number">0xffff</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="类snowlack"><a href="#类snowlack" class="headerlink" title="类snowlack"></a>类snowlack</h2><p>这种方案大致来说是一种以划分命名空间（UUID也算，由于比较常见，所以单独分析）来生成ID的一种算法，这种方案把64-bit分别划分成多段，分开来标示机器、时间等，比如在snowflake中的64-bit分别表示如下图（图片来自网络）所示：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20191011213141.png" alt="snowlack"></p>
<p>41-bit的时间可以表示（1L&lt;&lt;41）&#x2F;(1000L<em>3600</em>24*365)&#x3D;69年的时间，10-bit机器可以分别表示1024台机器。如果我们对IDC划分有需求，还可以将10-bit分5-bit给IDC，分5-bit给工作机器。这样就可以表示32个IDC，每个IDC下可以有32台机器，可以根据自身需求定义。12个自增序列号可以表示2^12个ID，理论上snowflake方案的QPS约为409.6w&#x2F;s，这种分配方式可以保证在任何一个IDC的任何一台机器在任意毫秒内生成的ID都是不同的。</p>
<p>这种方式的优缺点是：</p>
<p><strong>优点：</strong></p>
<p>毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。</p>
<p>不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。</p>
<p>可以根据自身业务特性分配bit位，非常灵活。</p>
<p><strong>缺点：</strong></p>
<p>强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。</p>
<p><strong>应用举例Mongdb objectID：</strong></p>
<p><a href="https://docs.mongodb.com/manual/reference/method/ObjectId/#description">MongoDB官方文档</a> ObjectID可以算作是和snowflake类似方法，通过“时间+机器码+pid+inc”共12个字节，通过4+3+2+3的方式最终标识成一个24长度的十六进制字</p>
<h2 id="数据库生成"><a href="#数据库生成" class="headerlink" title="数据库生成"></a>数据库生成</h2><p>以MySQL举例，利用给字段设置auto_increment_increment和auto_increment_offset来保证ID自增，每次业务使用下列SQL读写MySQL得到ID号。</p>
<p>这种方案的优缺点如下：</p>
<p><strong>优点：</strong></p>
<ul>
<li>非常简单，利用现有数据库系统的功能实现，成本小，有DBA专业维护。<br>ID号单调自增，可以实现一些对ID有特殊要求的业务。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>强依赖DB，当DB异常时整个系统不可用，属于致命问题。配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号。</li>
<li>ID发号性能瓶颈限制在单台MySQL的读写性能。</li>
</ul>
<h2 id="微信-seqsvr"><a href="#微信-seqsvr" class="headerlink" title="微信 seqsvr"></a>微信 seqsvr</h2><p>不考虑 seqsvr 的具体架构的话，它应该是一个巨大的 64 位数组，而我们每一个微信用户，都在这个大数组里独占一格 8bytes 的空间，这个格子就放着用户已经分配出去的最后一个 sequence：cur_seq。每个用户来申请 sequence 的时候，只需要将用户的 cur_seq+&#x3D;1，保存回数组，并返回给用户。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20191012163308.png" alt="图 1. 小明申请了一个 sequence，返回 101"></p>
<p>图 1. 小明申请了一个 sequence，返回 101</p>
<p><strong>预分配中间层:</strong></p>
<p>任何一件看起来很简单的事，在海量的访问量下都会变得不简单。前文提到，seqsvr 需要保证分配出去的 sequence 递增（数据可靠），还需要满足海量的访问量（每天接近万亿级别的访问）。满足数据可靠的话，我们很容易想到把数据持久化到硬盘，但是按照目前每秒千万级的访问量（~10^7 QPS），基本没有任何硬盘系统能扛住。</p>
<p>后台架构设计很多时候是一门关于权衡的哲学，针对不同的场景去考虑能不能降低某方面的要求，以换取其它方面的提升。仔细考虑我们的需求，我们只要求递增，并没有要求连续，也就是说出现一大段跳跃是允许的（例如分配出的 sequence 序列：1,2,3,10,100,101）。于是我们实现了一个简单优雅的策略：</p>
<ol>
<li>内存中储存最近一个分配出去的 sequence：cur_seq，以及分配上限：max_seq</li>
<li>分配 sequence 时，将 cur_seq++，同时与分配上限 max_seq 比较：如果 cur_seq &gt; max_seq，将分配上限提升一个步长 max_seq +&#x3D; step，并持久化 max_seq</li>
<li>重启时，读出持久化的 max_seq，赋值给 cur_seq</li>
</ol>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20191012163521.png" alt="图 2. 小明、小红、小白都各自申请了一个 sequence，但只有小白的 max_seq 增加了步长 100"></p>
<p>图 2. 小明、小红、小白都各自申请了一个 sequence，但只有小白的 max_seq 增加了步长 100</p>
<p>这样通过增加一个预分配 sequence 的中间层，在保证 sequence 不回退的前提下，大幅地提升了分配 sequence 的性能。实际应用中每次提升的步长为 10000，那么持久化的硬盘 IO 次数从之前<del>10^7 QPS 降低到</del>10^3 QPS，处于可接受范围。在正常运作时分配出去的 sequence 是顺序递增的，只有在机器重启后，第一次分配的 sequence 会产生一个比较大的跳跃，跳跃大小取决于步长大小。</p>
<p><strong>分号段共享存储:</strong></p>
<p>请求带来的硬盘 IO 问题解决了，可以支持服务平稳运行，但该模型还是存在一个问题：重启时要读取大量的 max_seq 数据加载到内存中。</p>
<p>我们可以简单计算下，以目前 uid（用户唯一 ID）上限 2^32 个、一个 max_seq 8bytes 的空间，数据大小一共为 32GB，从硬盘加载需要不少时间。另一方面，出于数据可靠性的考虑，必然需要一个可靠存储系统来保存 max_seq 数据，重启时通过网络从该可靠存储系统加载数据。如果 max_seq 数据过大的话，会导致重启时在数据传输花费大量时间，造成一段时间不可服务。</p>
<p>为了解决这个问题，我们引入号段 Section 的概念，uid 相邻的一段用户属于一个号段，而同个号段内的用户共享一个 max_seq，这样大幅减少了 max_seq 数据的大小，同时也降低了 IO 次数。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20191012163622.png" alt="图 3. 小明、小红、小白属于同个 Section，他们共用一个 max_seq。在每个人都申请一个 sequence 的时候，只有小白突破了 max_seq 上限，需要更新 max_seq 并持久化"></p>
<p>图 3. 小明、小红、小白属于同个 Section，他们共用一个 max_seq。在每个人都申请一个 sequence 的时候，只有小白突破了 max_seq 上限，需要更新 max_seq 并持久化</p>
<p>目前 seqsvr 一个 Section 包含 10 万个 uid，max_seq 数据只有 300+KB，为我们实现从可靠存储系统读取 max_seq 数据重启打下基础。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>文章：</strong></p>
<ul>
<li><a href="https://juejin.im/entry/59eb02806fb9a0451049a0ab">高并发分布式系统唯一ID生成</a></li>
<li><a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf——美团点评分布式ID生成系统</a></li>
<li><a href="https://github.com/didi/tinyid/wiki/tinyid%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D">Tinyid 原理介绍</a></li>
<li><a href="https://www.infoq.cn/article/wechat-serial-number-generator-architecture/">微信序列号生成器架构设计及演变</a></li>
</ul>
<p><strong>各大公司的开源项目：</strong></p>
<ul>
<li><a href="https://github.com/twitter-archive/snowflake">twitter snowflake</a></li>
<li><a href="https://github.com/baidu/uid-generator">baidu uid-generator</a></li>
<li><a href="https://github.com/Meituan-Dianping/Leaf">meituan leaf</a></li>
<li><a href="https://github.com/didi/tinyid">didi tinyid</a></li>
</ul>
]]></content>
      <categories>
        <category>专业技能</category>
        <category>系统设计</category>
      </categories>
      <tags>
        <tag>系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title>后端分页设计方案</title>
    <url>/2022/10/01/cs-skill/cs-skill-system/%E5%90%8E%E7%AB%AF%E5%88%86%E9%A1%B5%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近要对帐单历史数据清洗，发现清洗后的数据存在乱序问题。简单来说就是补10月份补1条1月份的账单，页面展示的时候这条账单会出现9月份数据之前。</p>
<p>原因是因为这里用的是游标分页，而分页的字段是id（严格自增），所以10月份补的账单id会比9月份的账单id大，展示的时候也就会展示在前面。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>移动端按照时间序展示账单。</p>
<h2 id="常规方案"><a href="#常规方案" class="headerlink" title="常规方案"></a>常规方案</h2><p>在设计具体方案之前对后端实现分页的方法做了一下简单梳理。</p>
<p>目前后端分页设计一般分为两种类型：传统网站比较常见的电梯式分页布局及移动端比较常见的流式分页布局。</p>
<h3 id="传统网站电梯式分页布局"><a href="#传统网站电梯式分页布局" class="headerlink" title="传统网站电梯式分页布局"></a>传统网站电梯式分页布局</h3><p>电梯式分页布局在传统网站中非常常见，比如百度、淘宝：<br><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20221001221839.png"><br><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20221001221855.png"></p>
<p>它的特点是在网站的底部有分页栏，用户不仅可以点击上一页、下一页浏览数据，还可以直接点击页码跳转到特定页，所以电梯式分页的的 SQL 查询（以下称为传统分页）也比较统一，基本上为前端提供页数及每页的数量，后端套用下面的 SQL 查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#currentPage 为当前页数（以 <span class="number">1</span> 开始），pagingSize 为每页的数据量</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> ... <span class="keyword">where</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ... limit (currentPage<span class="operator">-</span> <span class="number">1</span>) <span class="operator">*</span> pagingSize, pagingSize;</span><br></pre></td></tr></table></figure>

<h3 id="流式分页布局"><a href="#流式分页布局" class="headerlink" title="流式分页布局"></a>流式分页布局</h3><p>流式分页布局在移动端比较流行，因为移动端的屏幕尺寸普遍较小，会导致分页栏不容易点击。并且移动端拥有良好的滑动体验，向上滑动加载更多，向下滑动刷新的操作方式更加便利。</p>
<p>流式分页布局在后端的处理上，有两种实现方案，一种是直接将传统分页逻辑套用到移动端流式分页上，另一种是游标分页。</p>
<h4 id="直接将传统分页套用到移动端流式分页上"><a href="#直接将传统分页套用到移动端流式分页上" class="headerlink" title="直接将传统分页套用到移动端流式分页上"></a>直接将传统分页套用到移动端流式分页上</h4><p>直接将传统分页套用到移动端流式分页上的主要问题如下：</p>
<p><strong>数据重复</strong></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20221001222845.png"></p>
<p><strong>数据缺失</strong></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20221001222936.png"></p>
<p><strong>效率低</strong></p>
<p>使用 limit 在数据量小的时候并不会有效率问题，但是当数据偏移量很大时性能会开始急剧下降。</p>
<h4 id="游标分页"><a href="#游标分页" class="headerlink" title="游标分页"></a>游标分页</h4><p>游标分页则不需要提供当前页码，而是提供当前页的起始位置（也称为游标）用于定位，游标分页的 SQL 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">cursor</span> 为上一页最后一条新闻的 create_date（如果是第一页则为当前时间），pagingSize 为每页的数据量</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> news_ <span class="keyword">where</span> create_date <span class="operator">&gt;</span> $<span class="keyword">cursor</span> <span class="keyword">order</span> <span class="keyword">by</span> create_date <span class="keyword">desc</span> limit $pagingSize</span><br></pre></td></tr></table></figure>

<p>传统分页的偏移量是固定的，所以会因为数据的新增或减少导致接下来加载数据重复或丢失。而游标分页则不会出现这种情况，因为当数据发生新增和减少时，游标的位置也会相对变化。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>经过分析发现，目前的游标分页方案还是要采用的，现在的问题是游标字段id不能代表实际在页面上要展示的顺序。</p>
<p><strong>方案一：</strong>换一个游标字段，将id换成create_time。存在问题，当create_time相同时，非第一页数据会丢掉。</p>
<p><strong>方案二：</strong>在方案一的基础上只要能保证同一时间只有1条记录就没问题了，比如根据时间生成id，时间大的id也大。</p>
<p><strong>方案三：</strong>我这里遇到的问题不太好通过根据时间生成id来解决（id生成不在我这边），所以增加一个冗余字段，通过将账单实际生成时间和id拼接来达到先生成的账单一定先展示，同一时间生成的账单按照id大小顺序展示的目的。</p>
<p>这里只能采用方案三来解决这个问题，mysql索引长度限制为131个字节，经过计算13位的时间戳+18位的id完全够用。</p>
<p>问题一：未来时间戳长度会不会增加？<br>经过计算200年内不会增长</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(9999999999999-1664635278000)/(365*24*60*60*1000) = 264.31(年)</span><br></pre></td></tr></table></figure>

<p>问题二：id会不会增长？<br>之前为了保证id的严格自增，id的生成采用的是 snowflake 算法生成的，所以不会增长</p>
<p>生成冗余字段规则如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sort_id = (create_time * 1000000000000000000) + id;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>分页方案主要分传统PC电梯分页和移动端流式分页</li>
<li>用传统电梯分页方案实现流式分页主要的问题有数据重复、数据丢失、数据量大时性能低。</li>
<li>流式分页主要通过游标分页方案来实现</li>
<li>当出现因为洗数据导致分页乱序问题时，最直接的方案时将游标字段改为一个和数据生成时间相关的字段。</li>
<li>如果数据量比较大数据统一时间可能存在多条记录要么想办法保证相同时间内只能有一条记录，要么增加一个冗余字段将生成时间和id冗余到一起。</li>
</ol>
]]></content>
      <categories>
        <category>专业技能</category>
        <category>系统设计</category>
      </categories>
      <tags>
        <tag>系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title>复杂度分析：如何分析、统计算法的执行效率和资源消耗？</title>
    <url>/2019/07/27/cs-basic/cs-basic-basic/cs-basic-basic-algorithm/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E3%80%81%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E5%92%8C%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20190727202003.png"></p>
<p>我们都知道，数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。那如何来衡量你编写的算法代码的执行效率呢？这里就要用到我们今天要讲的内容：时间、空间复杂度分析。</p>
<p>其实，只要讲到数据结构与算法，就一定离不开时间、空间复杂度分析。<strong>复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。</strong></p>
<h1 id="大-O-复杂度表示法"><a href="#大-O-复杂度表示法" class="headerlink" title="大 O 复杂度表示法"></a>大 O 复杂度表示法</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; j &lt;= n; ++j) &#123;</span><br><span class="line">      sum = sum +  i * j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/22900968aa2b190072c985a08b0e92ef.png"></p>
<p>我来具体解释一下这个公式。其中，</p>
<ul>
<li>T(n)表示代码执行的时间；</li>
<li>n 表示数据规模的大小；</li>
<li>f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。</li>
<li>O 表示代码的执行时间 T(n) 与 f(n) 表达式成正比。</li>
</ul>
<p>这就是<strong>大 O 时间复杂度表示法</strong>。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作<strong>渐进时间复杂度</strong>（asymptotic time complexity），简称<strong>时间复杂度</strong>。</p>
<h1 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h1><h2 id="只关注循环次数最多的一段代码"><a href="#只关注循环次数最多的一段代码" class="headerlink" title="只关注循环次数最多的一段代码"></a>只关注循环次数最多的一段代码</h2><p>大 O 这种复杂度表示方法只是表示一种变化趋势。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，<strong>我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了</strong>。这段核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; j &lt;= n; ++j) &#123;</span><br><span class="line">      sum = sum +  i * j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中第 2、3 行代码都是常量级的执行时间，与 n 的大小无关，所以对于复杂度并没有影响。循环执行次数最多的是第 4、5 行代码，所以这块代码要重点分析。前面我们也讲过，这两行代码被执行了 n 次，所以总的时间复杂度就是 O(n)。</p>
<h2 id="加法法则：总复杂度等于量级最大的那段代码的复杂度"><a href="#加法法则：总复杂度等于量级最大的那段代码的复杂度" class="headerlink" title="加法法则：总复杂度等于量级最大的那段代码的复杂度"></a>加法法则：总复杂度等于量级最大的那段代码的复杂度</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">   <span class="type">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; p &lt; <span class="number">100</span>; ++p) &#123;</span><br><span class="line">     sum_1 = sum_1 + p;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> q = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; q &lt; n; ++q) &#123;</span><br><span class="line">     sum_2 = sum_2 + q;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="type">int</span> sum_3 = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">     j = <span class="number">1</span>; </span><br><span class="line">     <span class="keyword">for</span> (; j &lt;= n; ++j) &#123;</span><br><span class="line">       sum_3 = sum_3 +  i * j;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> sum_1 + sum_2 + sum_3;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>综合这三段代码的时间复杂度，我们取其中最大的量级。所以，整段代码的时间复杂度就为 O(n^2)。也就是说：<strong>等于量级最大的那段代码的时间复杂度</strong>。</p>
<h2 id="乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"><a href="#乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积" class="headerlink" title="乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"></a>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</h2><p>也就是说，假设 T1(n) &#x3D; O(n)，T2(n) &#x3D; O(n^2)，则 T1(n) * T2(n) &#x3D; O(n^2)。落实到具体的代码上，我们可以把乘法法则看成是<strong>嵌套循环</strong>，我举个例子给你解释一下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">   <span class="type">int</span> ret = <span class="number">0</span>; </span><br><span class="line">   <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">     ret = ret + f(i);</span><br><span class="line">   &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们单独看 cal() 函数。假设 f() 只是一个普通的操作，那第 4～6 行的时间复杂度就是，T1(n) &#x3D; O(n)。但 f() 函数本身不是一个简单的操作，它的时间复杂度是 T2(n) &#x3D; O(n)，所以，整个 cal() 函数的时间复杂度就是，T(n) &#x3D; T1(n) * T2(n) &#x3D; O(n*n) &#x3D; O(n^2)。</p>
<h1 id="几种常见的时间复杂度实例分析"><a href="#几种常见的时间复杂度实例分析" class="headerlink" title="几种常见的时间复杂度实例分析"></a>几种常见的时间复杂度实例分析</h1><h2 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h2><p>首先你必须明确一个概念，O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> sum = i + j;</span><br></pre></td></tr></table></figure>

<p>我稍微总结一下，只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，**一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)**。</p>
<h2 id="O-logn-、O-nlogn"><a href="#O-logn-、O-nlogn" class="headerlink" title="O(logn)、O(nlogn)"></a>O(logn)、O(nlogn)</h2><p>对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。我通过一个例子来说明一下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)  &#123;</span><br><span class="line">  i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据我们前面讲的复杂度分析方法，第三行代码是循环执行次数最多的。所以，我们只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。</p>
<p>从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。还记得我们高中学过的等比数列吗？实际上，变量 i 的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/9b1c88264e7a1a20b5954be9bc4bec9a%E7%9A%84%E5%89%AF%E6%9C%AC.jpg"></p>
<p>所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了。通过 2^x&#x3D;n 求解 x 这个问题我们想高中应该就学过了，我就不多说了。x&#x3D;log2n，所以，这段代码的时间复杂度就是 O(log2n)。</p>
<p>现在，我把代码稍微改下，你再看看，这段代码的时间复杂度是多少？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)  &#123;</span><br><span class="line">  i = i * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据我刚刚讲的思路，很简单就能看出来，这段代码的时间复杂度为 O(log3n)。</p>
<p>实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。为什么呢？</p>
<p>我们知道，对数之间是可以互相转换的，log(3)(n) 就等于 log(3)(2) * log(2)(n)，所以 O(log(3)(n)) &#x3D; &#x3D; O(C * log(2)(n))，其中 C&#x3D;log(3)(2) 是一个常量。基于我们前面的一个理论：**在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) &#x3D; O(f(n))**。所以，O(log2n) 就等于 O(log3n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。</p>
<p>如果你理解了我前面讲的 O(logn)，那 O(nlogn) 就很容易理解了。还记得我们刚讲的乘法法则吗？如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。</p>
<h2 id="O-m-n-、O-m-n"><a href="#O-m-n-、O-m-n" class="headerlink" title="O(m+n)、O(m*n)"></a>O(m+n)、O(m*n)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; m; ++i) &#123;</span><br><span class="line">    sum_1 = sum_1 + i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">    sum_2 = sum_2 + j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。</p>
<p>针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) &#x3D; O(f(m) + g(n))。但是乘法法则继续有效：T1(m)*T2(n) &#x3D; O(f(m) * f(n))。</p>
<h1 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void print(int n) &#123;</span><br><span class="line">  int i = 0;</span><br><span class="line">  int[] a = new int[n];</span><br><span class="line">  for (i; i &lt;n; ++i) &#123;</span><br><span class="line">    a[i] = i * i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (i = n-1; i &gt;= 0; --i) &#123;</span><br><span class="line">    print out a[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。</p>
<p>我们常见的空间复杂度就是 O(1)、O(n)、O(n^2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。所以，对于空间复杂度，掌握刚我说的这些内容已经足够了。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/497a3f120b7debee07dc0d03984faf04.jpg"></p>
<p>参考：<a href="https://time.geekbang.org/column/article/40036">https://time.geekbang.org/column/article/40036</a></p>
]]></content>
      <categories>
        <category>专业知识</category>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title>0005最长回文子串</title>
    <url>/2024/01/14/cs-basic/cs-basic-basic/cs-basic-basic-algorithm/0005%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><p>给你一个字符串 s，找到 s 中最长的回文子串。</p>
<p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;babad&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bab&quot;</span></span><br><span class="line">解释：<span class="string">&quot;aba&quot;</span> 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;cbbd&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bb&quot;</span></span><br></pre></td></tr></table></figure>


<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; s.length &lt;&#x3D; 1000</li>
<li>s 仅由数字和英文字母组成</li>
</ul>
<p>Related Topics</p>
<ul>
<li>字符串</li>
<li>动态规划</li>
</ul>
<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>本题最容易想到的一种方法应该就是 中心扩散法。中心扩散法怎么去找回文串？</p>
<p>从每一个位置出发，向两边扩散即可。遇到不是回文的时候结束。</p>
<p>举个例子，str&#x3D;acdbbdaa 我们需要寻找从第一个 b（位置为 3）出发最长回文串为多少。怎么寻找？</p>
<ul>
<li><p>首先往左寻找与当期位置相同的字符，直到遇到不相等为止。</p>
</li>
<li><p>然后往右寻找与当期位置相同的字符，直到遇到不相等为止。</p>
</li>
<li><p>最后左右双向扩散，直到左和右不相等。如下图所示：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20240116232946.png"></p>
<p>每个位置向两边扩散都会出现一个窗口大小（len）。如果 len&gt;maxLen(用来表示最长回文串的长度）。则更新 maxLen 的值。</p>
<p>因为我们最后要返回的是具体子串，而不是长度，因此，还需要记录一下 maxLen 时的起始位置（maxStart），即此时还要 maxStart&#x3D;len。</p>
<h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">strLen</span> <span class="operator">=</span> s.length();</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">maxStart</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strLen; i++) &#123;</span><br><span class="line">                left = i - <span class="number">1</span>;</span><br><span class="line">                right = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; s.charAt(left) == s.charAt(i)) &#123;</span><br><span class="line">                    len++;</span><br><span class="line">                    left--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (right &lt; strLen &amp;&amp; s.charAt(right) == s.charAt(i)) &#123;</span><br><span class="line">                    len++;</span><br><span class="line">                    right++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; strLen &amp;&amp; s.charAt(right) == s.charAt(left)) &#123;</span><br><span class="line">                    len = len + <span class="number">2</span>;</span><br><span class="line">                    left--;</span><br><span class="line">                    right++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (len &gt; maxLen) &#123;</span><br><span class="line">                    maxLen = len;</span><br><span class="line">                    maxStart = left;</span><br><span class="line">                &#125;</span><br><span class="line">                len = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> s.substring(maxStart + <span class="number">1</span>, maxStart + maxLen + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>专业知识</category>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Go编程</title>
    <url>/2019/08/16/cs-basic/cs-basic-language/cs-basic-language-go/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Go%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>注：该文章摘自go官方文档。</p>
</blockquote>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本文档展示了一个简单Go包的开发，并介绍了用go工具来获取、 构建并安装Go包及命令的标准方式。</p>
<p>go 工具需要你按照指定的方式来组织代码。请仔细阅读本文档， 它说明了如何以最简单的方式来准备并运行你的Go安装。</p>
<h1 id="代码的组织"><a href="#代码的组织" class="headerlink" title="代码的组织"></a>代码的组织</h1><h2 id="工作空间"><a href="#工作空间" class="headerlink" title="工作空间"></a>工作空间</h2><p>go 工具为公共代码仓库中维护的开源代码而设计。 无论你会不会公布代码，该模型设置工作环境的方法都是相同的。</p>
<p>Go代码必须放在工作空间内。它其实就是一个目录，其中包含三个子目录：</p>
<ul>
<li>src 目录包含Go的源文件，它们被组织成包（每个目录都对应一个包），</li>
<li>pkg 目录包含包对象，</li>
<li>bin 目录包含可执行命令。</li>
</ul>
<p>go 工具用于构建源码包，并将其生成的二进制文件安装到 pkg 和 bin 目录中。</p>
<p>src 子目录通常包会含多种版本控制的代码仓库（例如Git或Mercurial）， 以此来跟踪一个或多个源码包的开发。</p>
<p>以下例子展现了实践中工作空间的概念：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bin/</span><br><span class="line">	streak                         # 可执行命令</span><br><span class="line">	todo                           # 可执行命令</span><br><span class="line">pkg/</span><br><span class="line">	linux_amd64/</span><br><span class="line">		code.google.com/p/goauth2/</span><br><span class="line">			oauth.a                # 包对象</span><br><span class="line">		github.com/nf/todo/</span><br><span class="line">			task.a                 # 包对象</span><br><span class="line">src/</span><br><span class="line">	code.google.com/p/goauth2/</span><br><span class="line">		.hg/                       # mercurial 代码库元数据</span><br><span class="line">		oauth/</span><br><span class="line">			oauth.<span class="keyword">go</span>               # 包源码</span><br><span class="line">			oauth_test.<span class="keyword">go</span>          # 测试源码</span><br><span class="line">	github.com/nf/</span><br><span class="line">		streak/</span><br><span class="line">		.git/                      # git 代码库元数据</span><br><span class="line">			oauth.<span class="keyword">go</span>               # 命令源码</span><br><span class="line">			streak.<span class="keyword">go</span>              # 命令源码</span><br><span class="line">		todo/</span><br><span class="line">		.git/                      # git 代码库元数据</span><br><span class="line">			task/</span><br><span class="line">				task.<span class="keyword">go</span>            # 包源码</span><br><span class="line">			todo.<span class="keyword">go</span>                # 命令源码</span><br></pre></td></tr></table></figure>

<p>此工作空间包含三个代码库（goauth2、streak 和 todo），两个命令（streak 和 todo） 以及两个库（oauth 和 task）。</p>
<p>命令和库从不同的源码包编译而来。稍后我们会对讨论它的特性。</p>
<h2 id="GOPATH-环境变量"><a href="#GOPATH-环境变量" class="headerlink" title="GOPATH 环境变量"></a>GOPATH 环境变量</h2><p>GOPATH 环境变量指定了你的工作空间位置。它或许是你在开发Go代码时， 唯一需要设置的环境变量。</p>
<p>首先创建一个工作空间目录，并设置相应的 GOPATH。你的工作空间可以放在任何地方， 在此文档中我们使用 $HOME&#x2F;work。注意，它绝对不能和你的Go安装目录相同。 （另一种常见的设置是 GOPATH&#x3D;$HOME。）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ mkdir $HOME/work</span><br><span class="line">$ export GOPATH=$HOME/work</span><br></pre></td></tr></table></figure>

<p>作为约定，请将此工作空间的 bin 子目录添加到你的 PATH 中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ export PATH=$PATH:$GOPATH/bin</span><br></pre></td></tr></table></figure>

<p>To learn more about setting up the GOPATH environment variable, please see go help gopath</p>
<h2 id="包路径"><a href="#包路径" class="headerlink" title="包路径"></a>包路径</h2><p>标准库中的包有给定的短路径，比如 “fmt” 和 “net&#x2F;http”。 对于你自己的包，你必须选择一个基本路径，来保证它不会与将来添加到标准库， 或其它扩展库中的包相冲突。</p>
<p>如果你将你的代码放到了某处的源码库，那就应当使用该源码库的根目录作为你的基本路径。 例如，若你在 GitHub 上有账户 github.com&#x2F;user 那么它就应该是你的基本路径。</p>
<p>注意，在你能构建这些代码之前，无需将其公布到远程代码库上。只是若你某天会发布它， 这会是个好习惯。在实践中，你可以选择任何路径名，只要它对于标准库和更大的Go生态系统来说， 是唯一的就行。</p>
<p>我们将使用 github.com&#x2F;user 作为基本路径。在你的工作空间里创建一个目录， 我们将源码存放到其中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkdir -p $GOPATH/src/github.com/user</span><br></pre></td></tr></table></figure>

<h2 id="你的第一个程序"><a href="#你的第一个程序" class="headerlink" title="你的第一个程序"></a>你的第一个程序</h2><p>要编译并运行简单的程序，首先要选择包路径（我们在这里使用 github.com&#x2F;user&#x2F;hello），并在你的工作空间内创建相应的包目录：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ mkdir $GOPATH/src/github.com/user/hello</span><br></pre></td></tr></table></figure>

<p>接着，在该目录中创建名为 hello.go 的文件，其内容为以下Go代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Hello, world.\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在你可以用 go 工具构建并安装此程序了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> install github.com/user/hello</span><br></pre></td></tr></table></figure>

<p>注意，你可以在系统的任何地方运行此命令。go 工具会根据 GOPATH 指定的工作空间，在 github.com&#x2F;user&#x2F;hello 包内查找源码。</p>
<p>若在从包目录中运行 go install，也可以省略包路径：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ cd $GOPATH/src/github.com/user/hello</span><br><span class="line">$ <span class="keyword">go</span> install</span><br></pre></td></tr></table></figure>

<p>此命令会构建 hello 命令，产生一个可执行的二进制文件。 接着它会将该二进制文件作为 hello（在 Windows 下则为 hello.exe）安装到工作空间的 bin 目录中。 在我们的例子中为 $GOPATH&#x2F;bin&#x2F;hello，具体一点就是 $HOME&#x2F;go&#x2F;bin&#x2F;hello。</p>
<p>go 工具只有在发生错误时才会打印输出，因此若这些命令没有产生输出， 就表明执行成功了。</p>
<p>现在，你可以在命令行下输入它的完整路径来运行它了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ $GOPATH/bin/hello</span><br><span class="line">Hello, world.</span><br></pre></td></tr></table></figure>

<p>若你已经将 $GOPATH&#x2F;bin 添加到 PATH 中了，只需输入该二进制文件名即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ hello</span><br><span class="line">Hello, world.</span><br></pre></td></tr></table></figure>

<p>若你使用源码控制系统，那现在就该初始化仓库，添加文件并提交你的第一次更改了。 再次强调，这一步是可选的：你无需使用源码控制来编写Go代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ cd $GOPATH/src/github.com/user/hello</span><br><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in /home/user/work/src/github.com/user/hello/.git/</span><br><span class="line">$ git add hello.<span class="keyword">go</span></span><br><span class="line">$ git commit -m <span class="string">&quot;initial commit&quot;</span></span><br><span class="line">[master (root-commit) <span class="number">0</span>b4507d] initial commit</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br><span class="line">  create mode <span class="number">100644</span> hello.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<p>将代码推送到远程仓库（Github）可以参考<a href="https://haxianhe.com/post/git/%E5%B0%86%E5%B7%B2%E6%9C%89%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E5%88%B0github/">这篇文章</a>。</p>
<h2 id="你的第一个库"><a href="#你的第一个库" class="headerlink" title="你的第一个库"></a>你的第一个库</h2><p>让我们编写一个库，并让 hello 程序来使用它。</p>
<p>同样，第一步还是选择包路径（我们将使用 github.com&#x2F;user&#x2F;stringutil） 并创建包目录：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ mkdir $GOPATH/src/github.com/user/stringutil</span><br></pre></td></tr></table></figure>

<p>接着，在该目录中创建名为 reverse.go 的文件，内容如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stringutil 包含有用于处理字符串的工具函数。</span></span><br><span class="line"><span class="keyword">package</span> stringutil</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reverse 将其实参字符串以符文为单位左右反转。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	r := []<span class="type">rune</span>(s)</span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(r)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(r)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">		r[i], r[j] = r[j], r[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在用 go build 命令来测试该包的编译：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build github.com/user/stringutil</span><br></pre></td></tr></table></figure>

<p>当然，若你在该包的源码目录中，只需执行：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build</span><br></pre></td></tr></table></figure>

<p>即可。这不会产生输出文件。想要输出的话，必须使用 go install 命令，它会将包的对象放到工作空间的 pkg 目录中。</p>
<p>确认 stringutil 包构建完毕后，修改原来的 hello.go 文件（它位于 $GOPATH&#x2F;src&#x2F;github.com&#x2F;user&#x2F;hello）去使用它：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/user/stringutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(stringutil.Reverse(<span class="string">&quot;!oG ,olleH&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论是安装包还是二进制文件，go 工具都会安装它所依赖的任何东西。 因此当我们通过</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> install github.com/user/hello</span><br></pre></td></tr></table></figure>

<p>来安装 hello 程序时，stringutil 包也会被自动安装。</p>
<p>运行此程序的新版本，你应该能看到一条新的，反向的信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ hello</span><br><span class="line">Hello, Go!</span><br></pre></td></tr></table></figure>

<p>做完上面这些步骤后，你的工作空间应该是这样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bin/</span><br><span class="line">	hello                 # 可执行命令</span><br><span class="line">pkg/</span><br><span class="line">	linux_amd64/          # 这里会反映出你的操作系统和架构</span><br><span class="line">		github.com/user/</span><br><span class="line">			stringutil.a  # 包对象</span><br><span class="line">src/</span><br><span class="line">	github.com/user/</span><br><span class="line">		hello/</span><br><span class="line">			hello.<span class="keyword">go</span>      # 命令源码</span><br><span class="line">		stringutil/</span><br><span class="line">			reverse.<span class="keyword">go</span>       # 包源码</span><br></pre></td></tr></table></figure>

<p>注意 go install 会将 stringutil.a 对象放到 pkg&#x2F;linux_amd64 目录中，它会反映出其源码目录。 这就是在此之后调用 go 工具，能找到包对象并避免不必要的重新编译的原因。 linux_amd64 这部分能帮助跨平台编译，并反映出你的操作系统和架构。</p>
<p>Go的可执行命令是静态链接的；在运行Go程序时，包对象无需存在。</p>
<h2 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h2><p>Go源文件中的第一个语句必须是</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 名称</span><br></pre></td></tr></table></figure>

<p>这里的 名称 即为导入该包时使用的默认名称。 （一个包中的所有文件都必须使用相同的 名称。）</p>
<p>Go的约定是包名为导入路径的最后一个元素：作为 “crypto&#x2F;rot13” 导入的包应命名为 rot13。</p>
<p>可执行命令必须使用 package main。</p>
<p>链接成单个二进制文件的所有包，其包名无需是唯一的，只有导入路径（它们的完整文件名） 才是唯一的。</p>
<p>共多关于Go的命名约定见 实效Go编程。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>Go拥有一个轻量级的测试框架，它由 go test 命令和 testing 包构成。</p>
<p>你可以通过创建一个名字以 _test.go 结尾的，包含名为 TestXXX 且签名为 func (t *testing.T) 函数的文件来编写测试。 测试框架会运行每一个这样的函数；若该函数调用了像 t.Error 或 t.Fail 这样表示失败的函数，此测试即表示失败。</p>
<p>我们可通过创建文件 $GOPATH&#x2F;src&#x2F;github.com&#x2F;user&#x2F;stringutil&#x2F;reverse_test.go 来为 stringutil 添加测试，其内容如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stringutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReverse</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	cases := []<span class="keyword">struct</span> &#123;</span><br><span class="line">		in, want <span class="type">string</span></span><br><span class="line">	&#125;&#123;</span><br><span class="line">		&#123;<span class="string">&quot;Hello, world&quot;</span>, <span class="string">&quot;dlrow ,olleH&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;Hello, 世界&quot;</span>, <span class="string">&quot;界世 ,olleH&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> cases &#123;</span><br><span class="line">		got := Reverse(c.in)</span><br><span class="line">		<span class="keyword">if</span> got != c.want &#123;</span><br><span class="line">			t.Errorf(<span class="string">&quot;Reverse(%q) == %q, want %q&quot;</span>, c.in, got, c.want)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着使用 go test 运行该测试：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> test github.com/user/stringutil</span><br><span class="line">ok  	github.com/user/stringutil <span class="number">0.165</span>s</span><br></pre></td></tr></table></figure>

<p>同样，若你在包目录下运行 go 工具，也可以忽略包路径</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> test</span><br><span class="line">ok  	github.com/user/stringutil <span class="number">0.165</span>s</span><br></pre></td></tr></table></figure>

<p>更多详情可运行 go help test 或从 testing 包文档 中查看。</p>
<h2 id="远程包"><a href="#远程包" class="headerlink" title="远程包"></a>远程包</h2><p>像Git或Mercurial这样的版本控制系统，可根据导入路径的描述来获取包源代码。go 工具可通过此特性来从远程代码库自动获取包。例如，本文档中描述的例子也可存放到Google Code上的Mercurial仓库 code.google.com&#x2F;p&#x2F;go.example 中，若你在包的导入路径中包含了代码仓库的URL，go get 就会自动地获取、 构建并安装它：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> get github.com/golang/example/hello</span><br><span class="line">$ $GOPATH/bin/hello</span><br><span class="line">Hello, Go examples!</span><br></pre></td></tr></table></figure>

<p>若指定的包不在工作空间中，go get 就会将会将它放到 GOPATH 指定的第一个工作空间内。（若该包已存在，go get 就会跳过远程获取， 其行为与 go install 相同）</p>
<p>在执行完上面的go get 命令后，工作空间的目录树看起来应该是这样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bin/</span><br><span class="line">	hello                 # 可执行命令</span><br><span class="line">pkg/</span><br><span class="line">	linux_amd64/</span><br><span class="line">		code.google.com/p/<span class="keyword">go</span>.example/</span><br><span class="line">			stringutil.a     # 包对象</span><br><span class="line">		github.com/user/</span><br><span class="line">			stringutil.a     # 包对象</span><br><span class="line">src/</span><br><span class="line">	code.google.com/p/<span class="keyword">go</span>.example/</span><br><span class="line">		hello/</span><br><span class="line">			hello.<span class="keyword">go</span>      # 命令源码</span><br><span class="line">		stringutil/</span><br><span class="line">			reverse.<span class="keyword">go</span>       # 包源码</span><br><span class="line">			reverse_test.<span class="keyword">go</span>  # 测试源码</span><br><span class="line">	github.com/user/</span><br><span class="line">		hello/</span><br><span class="line">			hello.<span class="keyword">go</span>      # 命令源码</span><br><span class="line">		stringutil/</span><br><span class="line">			reverse.<span class="keyword">go</span>       # 包源码</span><br><span class="line">			reverse_test.<span class="keyword">go</span>  # 测试源码</span><br></pre></td></tr></table></figure>

<p>hello 命令及其依赖的 stringutil 包都托管在Google Code上的同一代码库中。hello.go 文件使用了同样的导入路径约定， 因此 go get 命令也能够定位并安装其依赖包。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/golang/example/stringutil&quot;</span></span><br></pre></td></tr></table></figure>

<p>遵循此约定可让他人以最简单的方式使用你的Go包。 Go维基 与 godoc.org 提供了外部Go项目的列表。</p>
<p>通过 go 工具使用远程代码库的更多详情，见 go help remote。</p>
<h2 id="接下来做什么"><a href="#接下来做什么" class="headerlink" title="接下来做什么"></a>接下来做什么</h2><p>订阅 golang-announce 邮件列表来获取Go的稳定版发布信息。</p>
<p>关于如何编写清晰、地道的Go代码的技巧，见实效Go编程。</p>
<p>要学习Go语言，请跟随Go语言之旅。</p>
<p>关于Go语言的深入性文章及其库和工具，见文档页面。</p>
<h2 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h2><p>要获取实时帮助，请询问 Freenode IRC 上 #go-nuts 中的 Gopher 们。</p>
<p>Go 语言的官方讨论邮件列表为 Go Nuts。</p>
<p>请使用Go 问题跟踪器报告 Bug。</p>
<h2 id="补充材料"><a href="#补充材料" class="headerlink" title="补充材料"></a>补充材料</h2><ol>
<li>go 安装相关，请参考<a href="http://docscn.studygolang.com/doc/install">http://docscn.studygolang.com/doc/install</a></li>
<li>本篇文章，完整项目，我放在了github上，如有需要请自行获取：<br> <a href="https://github.com/haxianhe/hello-world">https://github.com/haxianhe/hello-world</a><br> <a href="https://github.com/haxianhe/stringutil">https://github.com/haxianhe/stringutil</a></li>
</ol>
]]></content>
      <categories>
        <category>专业知识</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 核心技术 - IO</title>
    <url>/2021/09/14/cs-basic/cs-basic-language/cs-basic-language-java/Java%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%20-%20IO/</url>
    <content><![CDATA[<p>IO是指Input&#x2F;Output，即输入和输出。以内存为中心：</p>
<ul>
<li>Input指从外部读入数据到内存，例如，把文件从磁盘读取到内存，从网络读取数据到内存等等。</li>
<li>Output指把数据从内存输出到外部，例如，把数据从内存写入到文件，把数据从内存输出到网络等等。</li>
</ul>
<p>为什么要把数据读到内存才能处理这些数据？因为代码是在内存中运行的，数据也必须读到内存，最终的表示方式无非是byte数组，字符串等，都必须存放在内存里。</p>
<p>从Java代码来看，输入实际上就是从外部，例如，硬盘上的某个文件，把内容读到内存，并且以Java提供的某种数据类型表示，例如，byte[]，String，这样，后续代码才能处理这些数据。</p>
<p>因为内存有“易失性”的特点，所以必须把处理后的数据以某种方式输出，例如，写入到文件。Output实际上就是把Java表示的数据格式，例如，byte[]，String等输出到某个地方。</p>
<p>IO流是一种顺序读写数据的模式，它的特点是单向流动。数据类似自来水一样在水管中流动，所以我们把它称为IO流。</p>
<p><strong>InputStream &#x2F; OutputStream</strong></p>
<p>IO流以byte（字节）为最小单位，因此也称为字节流。例如，我们要从磁盘读入一个文件，包含6个字节，就相当于读入了6个字节的数据：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626230307.png"></p>
<p>这6个字节是按顺序读入的，所以是输入字节流。</p>
<p>反过来，我们把6个字节从内存写入磁盘文件，就是输出字节流：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626230326.png"></p>
<p>在Java中，InputStream代表输入字节流，OuputStream代表输出字节流，这是最基本的两种IO流。</p>
<p><strong>Reader &#x2F; Writer</strong></p>
<p>如果我们需要读写的是字符，并且字符不全是单字节表示的ASCII字符，那么，按照char来读写显然更方便，这种流称为字符流。</p>
<p>Java提供了Reader和Writer表示字符流，字符流传输的最小数据单位是char。</p>
<p>例如，我们把char[]数组Hi你好这4个字符用Writer字符流写入文件，并且使用UTF-8编码，得到的最终文件内容是8个字节，英文字符H和i各占一个字节，中文字符你好各占3个字节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0x48</span></span><br><span class="line"><span class="number">0x69</span></span><br><span class="line"><span class="number">0xe4bda0</span></span><br><span class="line"><span class="number">0xe5a5bd</span></span><br></pre></td></tr></table></figure>

<p>反过来，我们用Reader读取以UTF-8编码的这8个字节，会从Reader中得到Hi你好这4个字符。</p>
<p>因此，Reader和Writer本质上是一个能自动编解码的InputStream和OutputStream。</p>
<p>使用Reader，数据源虽然是字节，但我们读入的数据都是char类型的字符，原因是Reader内部把读入的byte做了解码，转换成了char。使用InputStream，我们读入的数据和原始二进制数据一模一样，是byte[]数组，但是我们可以自己把二进制byte[]数组按照某种编码转换为字符串。究竟使用Reader还是InputStream，要取决于具体的使用场景。如果数据源不是文本，就只能使用InputStream，如果数据源是文本，使用Reader更方便一些。Writer和OutputStream是类似的。</p>
<p><strong>同步和异步</strong></p>
<p>同步IO是指，读写IO时代码必须等待数据返回后才继续执行后续代码，它的优点是代码编写简单，缺点是CPU执行效率低。</p>
<p>而异步IO是指，读写IO时仅发出请求，然后立刻执行后续代码，它的优点是CPU执行效率高，缺点是代码编写复杂。</p>
<p>Java标准库的包java.io提供了同步IO，而java.nio则是异步IO。上面我们讨论的InputStream、OutputStream、Reader和Writer都是同步IO的抽象类，对应的具体实现类，以文件为例，有FileInputStream、FileOutputStream、FileReader和FileWriter。</p>
<p>本节我们只讨论Java的同步IO，即输入&#x2F;输出流的IO模型。</p>
<p><strong>小结</strong></p>
<p>IO流是一种流式的数据输入&#x2F;输出模型：</p>
<ul>
<li>二进制数据以byte为最小单位在InputStream&#x2F;OutputStream中单向流动；</li>
<li>字符数据以char为最小单位在Reader&#x2F;Writer中单向流动。</li>
</ul>
<p>Java标准库的java.io包提供了同步IO功能：</p>
<ul>
<li>字节流接口：InputStream&#x2F;OutputStream；</li>
<li>字符流接口：Reader&#x2F;Writer。</li>
</ul>
</br>
</br>

]]></content>
      <categories>
        <category>专业知识</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 核心技术 - 函数式编程</title>
    <url>/2021/09/16/cs-basic/cs-basic-language/cs-basic-language-java/Java%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%20-%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>函数式编程（Functional Programming）是把函数作为基本运算单元，函数可以作为变量，可以接收函数，还可以返回函数。历史上研究函数式编程的理论是Lambda演算，所以我们经常把支持函数式编程的编码风格称为Lambda表达式。</p>
<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>观察Lambda表达式的写法，它只需要写出方法定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(s1, s2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，参数是(s1, s2)，参数类型可以省略，因为编译器可以自动推断出String类型。-&gt; { … }表示方法体，所有代码写在内部即可。Lambda表达式没有class定义，因此写法非常简洁。</p>
<p>如果只有一行return xxx的代码，完全可以用更简单的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(array, (s1, s2) -&gt; s1.compareTo(s2));</span><br></pre></td></tr></table></figure>

<p>返回值的类型也是由编译器自动推断的，这里推断出的返回值是int，因此，只要返回int，编译器就不会报错。</p>
<p><strong>FunctionalInterface</strong></p>
<p>我们把只定义了单方法的接口称之为FunctionalInterface，用注解@FunctionalInterface标记。例如，Callable接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看Comparator接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Comparator&lt;T&gt; <span class="title function_">reversed</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.reverseOrder(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Comparator&lt;T&gt; <span class="title function_">thenComparing</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然Comparator接口有很多方法，但只有一个抽象方法int compare(T o1, T o2)，其他的方法都是default方法或static方法。另外注意到boolean equals(Object obj)是Object定义的方法，不算在接口方法内。因此，Comparator也是一个FunctionalInterface。</p>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>方法引用，是指如果某个方法签名和接口恰好一致，就可以直接传入方法引用。</p>
<p>注意：在这里，方法签名只看参数类型和返回类型，不看方法名称，也不看类的继承关系。</p>
<p>FunctionalInterface允许传入：</p>
<ul>
<li>接口的实现类（传统写法，代码较繁琐）；</li>
<li>Lambda表达式（只需列出参数名，由编译器推断类型）；</li>
<li>符合方法签名的静态方法；</li>
<li>符合方法签名的实例方法（实例类型被看做第一个参数类型）；</li>
<li>符合方法签名的构造方法（实例类型被看做返回类型）。</li>
</ul>
<p>FunctionalInterface不强制继承关系，不需要方法名称相同，只要求方法参数（类型和数量）与方法返回类型相同，即认为方法签名相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用构造方法</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; names = List.of(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Tim&quot;</span>);</span><br><span class="line">        List&lt;Person&gt; persons = names.stream().map(Person::<span class="keyword">new</span>).collect(Collectors.toList());</span><br><span class="line">        System.out.println(persons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person:&quot;</span> + <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Stream-概述"><a href="#Stream-概述" class="headerlink" title="Stream 概述"></a>Stream 概述</h2><p>Java从8开始，不但引入了Lambda表达式，还引入了一个全新的流式API：Stream API。它位于java.util.stream包中。</p>
<p>划重点：这个Stream不同于java.io的InputStream和OutputStream，它代表的是任意Java对象的序列。两者对比如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>java.io</th>
<th>java.util.stream</th>
</tr>
</thead>
<tbody><tr>
<td>存储</td>
<td>顺序读写的byte或char</td>
<td>顺序输出的任意Java对象实例</td>
</tr>
<tr>
<td>用途</td>
<td>序列化至文件或网络</td>
<td>内存计算／业务逻辑</td>
</tr>
</tbody></table>
<p>有同学会问：一个顺序输出的Java对象序列，不就是一个List容器吗？</p>
<p>再次划重点：这个Stream和List也不一样，List存储的每个元素都是已经存储在内存中的某个Java对象，而Stream输出的元素可能并没有预先存储在内存中，而是实时计算出来的。</p>
<p>换句话说，List的用途是操作一组已存在的Java对象，而Stream实现的是惰性计算，两者对比如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>java.util.List</th>
<th>java.util.stream</th>
</tr>
</thead>
<tbody><tr>
<td>元素</td>
<td>已分配并存储在内存</td>
<td>可能未分配，实时计算</td>
</tr>
<tr>
<td>用途</td>
<td>操作一组已存在的Java对象</td>
<td>惰性计算</td>
</tr>
</tbody></table>
<p>Stream的特点：它可以“存储”有限个或无限个元素。这里的存储打了个引号，是因为元素有可能已经全部存储在内存中，也有可能是根据需要实时计算出来的。</p>
<p>Stream的另一个特点是，一个Stream可以轻易地转换为另一个Stream，而不是修改原Stream本身。</p>
<p>最后，真正的计算通常发生在最后结果的获取，也就是惰性计算。</p>
<p>惰性计算的特点是：一个Stream转换为另一个Stream时，实际上只存储了转换规则，并没有任何计算发生。</p>
<p>例如，创建一个全体自然数的Stream，不会进行计算，把它转换为上述s2这个Stream，也不会进行计算。再把s2这个无限Stream转换为s3这个有限的Stream，也不会进行计算。只有最后，调用forEach确实需要Stream输出的元素时，才进行计算。我们通常把Stream的操作写成链式操作，代码更简洁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">createNaturalStream()</span><br><span class="line">    .map(BigInteger::multiply)</span><br><span class="line">    .limit(<span class="number">100</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>因此，Stream API的基本用法就是：创建一个Stream，然后做若干次转换，最后调用一个求值方法获取真正计算的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> createNaturalStream() <span class="comment">// 创建Stream</span></span><br><span class="line">             .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">// 任意个转换</span></span><br><span class="line">             .map(n -&gt; n * n) <span class="comment">// 任意个转换</span></span><br><span class="line">             .limit(<span class="number">100</span>) <span class="comment">// 任意个转换</span></span><br><span class="line">             .sum(); <span class="comment">// 最终计算结果</span></span><br></pre></td></tr></table></figure>

<p>Stream API的特点是：</p>
<ul>
<li>Stream API提供了一套新的流式处理的抽象序列；</li>
<li>Stream API支持函数式编程和链式操作；</li>
<li>Stream可以表示无限序列，并且大多数情况下是惰性求值的。</li>
</ul>
<h1 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h1><p>要使用Stream，就必须先创建它。创建Stream有很多种方法，我们来一一介绍。</p>
<p><strong>Stream.of()</strong></p>
<p>创建Stream最简单的方式是直接用Stream.of()静态方法，传入可变参数即创建了一个能输出确定元素的Stream：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line">        <span class="comment">// forEach()方法相当于内部循环调用，</span></span><br><span class="line">        <span class="comment">// 可传入符合Consumer接口的void accept(T t)的方法引用：</span></span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这种方式基本上没啥实质性用途，但测试的时候很方便。</p>
<p><strong>基于数组或Collection</strong></p>
<p>第二种创建Stream的方法是基于一个数组或者Collection，这样该Stream输出的元素就是数组或者Collection持有的元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; stream1 = Arrays.stream(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span> &#125;);</span><br><span class="line">        Stream&lt;String&gt; stream2 = List.of(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;Y&quot;</span>, <span class="string">&quot;Z&quot;</span>).stream();</span><br><span class="line">        stream1.forEach(System.out::println);</span><br><span class="line">        stream2.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把数组变成Stream使用Arrays.stream()方法。对于Collection（List、Set、Queue等），直接调用stream()方法就可以获得Stream。</p>
<p>上述创建Stream的方法都是把一个现有的序列变为Stream，它的元素是固定的。</p>
<p><strong>基于Supplier</strong></p>
<p>创建Stream还可以通过Stream.generate()方法，它需要传入一个Supplier对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; s = Stream.generate(Supplier&lt;String&gt; sp);</span><br></pre></td></tr></table></figure>

<p>基于Supplier创建的Stream会不断调用Supplier.get()方法来不断产生下一个元素，这种Stream保存的不是元素，而是算法，它可以用来表示无限序列。</p>
<p>例如，我们编写一个能不断生成自然数的Supplier，它的代码非常简单，每次调用get()方法，就生成下一个自然数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;Integer&gt; natual = Stream.generate(<span class="keyword">new</span> <span class="title class_">NatualSupplier</span>());</span><br><span class="line">        <span class="comment">// 注意：无限序列必须先变成有限序列再打印:</span></span><br><span class="line">        natual.limit(<span class="number">20</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NatualSupplier</span> <span class="keyword">implements</span> <span class="title class_">Supplier</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码我们用一个Supplier<Integer>模拟了一个无限序列（当然受int范围限制不是真的无限大）。如果用List表示，即便在int范围内，也会占用巨大的内存，而Stream几乎不占用空间，因为每个元素都是实时计算出来的，用的时候再算。</p>
<p>对于无限序列，如果直接调用forEach()或者count()这些最终求值操作，会进入死循环，因为永远无法计算完这个序列，所以正确的方法是先把无限序列变成有限序列，例如，用limit()方法可以截取前面若干个元素，这样就变成了一个有限序列，对这个有限序列调用forEach()或者count()操作就没有问题。</p>
<p><strong>基本类型</strong></p>
<p>因为Java的范型不支持基本类型，所以我们无法用Stream<int>这样的类型，会发生编译错误。为了保存int，只能使用Stream<Integer>，但这样会产生频繁的装箱、拆箱操作。为了提高效率，Java标准库提供了IntStream、LongStream和DoubleStream这三种使用基本类型的Stream，它们的使用方法和范型Stream没有大的区别，设计这三个Stream的目的是提高运行效率：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将int[]数组变为IntStream:</span></span><br><span class="line"><span class="type">IntStream</span> <span class="variable">is</span> <span class="operator">=</span> Arrays.stream(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);</span><br><span class="line"><span class="comment">// 将Stream&lt;String&gt;转换为LongStream:</span></span><br><span class="line"><span class="type">LongStream</span> <span class="variable">ls</span> <span class="operator">=</span> List.of(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>).stream().mapToLong(Long::parseLong);</span><br></pre></td></tr></table></figure>

<h1 id="使用map"><a href="#使用map" class="headerlink" title="使用map"></a>使用map</h1><p>Stream.map()是Stream最常用的一个转换方法，它把一个Stream转换为另一个Stream。</p>
<p>所谓map操作，就是把一种操作运算，映射到一个序列的每一个元素上。例如，对x计算它的平方，可以使用函数f(x) &#x3D; x * x。我们把这个函数映射到一个序列1，2，3，4，5上，就得到了另一个序列1，4，9，16，25：</p>
<p>map操作，把一个Stream的每个元素一一对应到应用了目标函数的结果上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; s = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Stream&lt;Integer&gt; s2 = s.map(n -&gt; n * n);</span><br></pre></td></tr></table></figure>

<p>如果我们查看Stream的源码，会发现map()方法接收的对象是Function接口对象，它定义了一个apply()方法，负责把一个T类型转换成R类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends R&gt; mapper)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，Function的定义是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line">    <span class="comment">// 将T类型转换为R:</span></span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用map()，不但能完成数学计算，对于字符串操作，以及任何Java对象都是非常有用的。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List.of(<span class="string">&quot;  Apple &quot;</span>, <span class="string">&quot; pear &quot;</span>, <span class="string">&quot; ORANGE&quot;</span>, <span class="string">&quot; BaNaNa &quot;</span>)</span><br><span class="line">                .stream()</span><br><span class="line">                .map(String::trim) <span class="comment">// 去空格</span></span><br><span class="line">                .map(String::toLowerCase) <span class="comment">// 变小写</span></span><br><span class="line">                .forEach(System.out::println); <span class="comment">// 打印</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过若干步map转换，可以写出逻辑简单、清晰的代码。</p>
<h1 id="使用filter"><a href="#使用filter" class="headerlink" title="使用filter"></a>使用filter</h1><p>Stream.filter()是Stream的另一个常用转换方法。</p>
<p>所谓filter()操作，就是对一个Stream的所有元素一一进行测试，不满足条件的就被“滤掉”了，剩下的满足条件的元素就构成了一个新的Stream。</p>
<p>filter()方法接收的对象是Predicate接口对象，它定义了一个test()方法，负责判断元素是否符合条件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Predicate</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 判断元素t是否符合条件:</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用reduce"><a href="#使用reduce" class="headerlink" title="使用reduce"></a>使用reduce</h1><p>map()和filter()都是Stream的转换方法，而Stream.reduce()则是Stream的一个聚合方法，它可以把一个Stream的所有元素按照聚合函数聚合成一个结果。</p>
<p>reduce()方法传入的对象是BinaryOperator接口，它定义了一个apply()方法，负责把上次累加的结果和本次的元素 进行运算，并返回累加的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BinaryOperator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// Bi操作：两个输入，一个输出</span></span><br><span class="line">    T <span class="title function_">apply</span><span class="params">(T t, T u)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="输出集合"><a href="#输出集合" class="headerlink" title="输出集合"></a>输出集合</h1><p>我们介绍了Stream的几个常见操作：map()、filter()、reduce()。这些操作对Stream来说可以分为两类，一类是转换操作，即把一个Stream转换为另一个Stream，例如map()和filter()，另一类是聚合操作，即对Stream的每个元素进行计算，得到一个确定的结果，例如reduce()。</p>
<p>区分这两种操作是非常重要的，因为对于Stream来说，对其进行转换操作并不会触发任何计算！</p>
<p>聚合操作是真正需要从Stream请求数据的，对一个Stream做聚合计算后，结果就不是一个Stream，而是一个其他的Java对象。</p>
<p><strong>输出为List</strong></p>
<p>reduce()只是一种聚合操作，如果我们希望把Stream的元素保存到集合，例如List，因为List的元素是确定的Java对象，因此，把Stream变为List不是一个转换操作，而是一个聚合操作，它会强制Stream输出每个元素。</p>
<p>下面的代码演示了如何将一组String先过滤掉空字符串，然后把非空字符串保存到List中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;  &quot;</span>, <span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list = stream.filter(s -&gt; s != <span class="literal">null</span> &amp;&amp; !s.isBlank()).collect(Collectors.toList());</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>把Stream的每个元素收集到List的方法是调用collect()并传入Collectors.toList()对象，它实际上是一个Collector实例，通过类似reduce()的操作，把每个元素添加到一个收集器中（实际上是ArrayList）。</p>
<p>类似的，collect(Collectors.toSet())可以把Stream的每个元素收集到Set中。</p>
<p><strong>输出为数组</strong></p>
<p>把Stream的元素输出为数组和输出为List类似，我们只需要调用toArray()方法，并传入数组的“构造方法”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">String[] array = list.stream().toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<p>注意到传入的“构造方法”是String[]::new，它的签名实际上是IntFunction&lt;String[]&gt;定义的String[] apply(int)，即传入int参数，获得String[]数组的返回值。</p>
<p><strong>输出为Map</strong></p>
<p>如果我们要把Stream的元素收集到Map中，就稍微麻烦一点。因为对于每个元素，添加到Map时需要key和value，因此，我们要指定两个映射函数，分别把元素映射为key和value：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;APPL:Apple&quot;</span>, <span class="string">&quot;MSFT:Microsoft&quot;</span>);</span><br><span class="line">        Map&lt;String, String&gt; map = stream</span><br><span class="line">                .collect(Collectors.toMap(</span><br><span class="line">                        <span class="comment">// 把元素s映射为key:</span></span><br><span class="line">                        s -&gt; s.substring(<span class="number">0</span>, s.indexOf(<span class="string">&#x27;:&#x27;</span>)),</span><br><span class="line">                        <span class="comment">// 把元素s映射为value:</span></span><br><span class="line">                        s -&gt; s.substring(s.indexOf(<span class="string">&#x27;:&#x27;</span>) + <span class="number">1</span>)));</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分组输出</strong></p>
<p>Stream还有一个强大的分组功能，可以按组输出。我们看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Blackberry&quot;</span>, <span class="string">&quot;Coconut&quot;</span>, <span class="string">&quot;Avocado&quot;</span>, <span class="string">&quot;Cherry&quot;</span>, <span class="string">&quot;Apricots&quot;</span>);</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; groups = list.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(s -&gt; s.substring(<span class="number">0</span>, <span class="number">1</span>), Collectors.toList()));</span><br><span class="line">        System.out.println(groups);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分组输出使用Collectors.groupingBy()，它需要提供两个函数：一个是分组的key，这里使用s -&gt; s.substring(0, 1)，表示只要首字母相同的String分到一组，第二个是分组的value，这里直接使用Collectors.toList()，表示输出为List，上述代码运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    A=[Apple, Avocado, Apricots],</span><br><span class="line">    B=[Banana, Blackberry],</span><br><span class="line">    C=[Coconut, Cherry]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，结果一共有3组，按”A”，”B”，”C”分组，每一组都是一个List。</p>
<h1 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h1><p>我们把Stream提供的操作分为两类：转换操作和聚合操作。除了前面介绍的常用操作外，Stream还提供了一系列非常有用的方法。</p>
<p><strong>排序</strong></p>
<p>对Stream的元素进行排序十分简单，只需调用sorted()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>)</span><br><span class="line">            .stream()</span><br><span class="line">            .sorted()</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法要求Stream的每个元素必须实现Comparable接口。如果要自定义排序，传入指定的Comparator即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>)</span><br><span class="line">    .stream()</span><br><span class="line">    .sorted(String::compareToIgnoreCase)</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>注意sorted()只是一个转换操作，它会返回一个新的Stream。</p>
<p><strong>去重</strong></p>
<p>对一个Stream的元素进行去重，没必要先转换为Set，可以直接用distinct()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;D&quot;</span>)</span><br><span class="line">    .stream()</span><br><span class="line">    .distinct()</span><br><span class="line">    .collect(Collectors.toList()); <span class="comment">// [A, B, C, D]</span></span><br></pre></td></tr></table></figure>

<p><strong>截取</strong></p>
<p>截取操作常用于把一个无限的Stream转换成有限的Stream，skip()用于跳过当前Stream的前N个元素，limit()用于截取当前Stream最多前N个元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span>)</span><br><span class="line">    .stream()</span><br><span class="line">    .skip(<span class="number">2</span>) <span class="comment">// 跳过A, B</span></span><br><span class="line">    .limit(<span class="number">3</span>) <span class="comment">// 截取C, D, E</span></span><br><span class="line">    .collect(Collectors.toList()); <span class="comment">// [C, D, E]</span></span><br></pre></td></tr></table></figure>

<p>截取操作也是一个转换操作，将返回新的Stream。</p>
<p><strong>合并</strong></p>
<p>将两个Stream合并为一个Stream可以使用Stream的静态方法concat()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; s1 = List.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>).stream();</span><br><span class="line">Stream&lt;String&gt; s2 = List.of(<span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>).stream();</span><br><span class="line"><span class="comment">// 合并:</span></span><br><span class="line">Stream&lt;String&gt; s = Stream.concat(s1, s2);</span><br><span class="line">System.out.println(s.collect(Collectors.toList())); <span class="comment">// [A, B, C, D, E]</span></span><br></pre></td></tr></table></figure>

<p><strong>flatMap</strong></p>
<p>如果Stream的元素是集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt; s = Stream.of(</span><br><span class="line">        Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">        Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">        Arrays.asList(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>));</span><br></pre></td></tr></table></figure>

<p>而我们希望把上述Stream转换为Stream<Integer>，就可以使用flatMap()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; i = s.flatMap(list -&gt; list.stream());</span><br></pre></td></tr></table></figure>

<p>因此，所谓flatMap()，是指把Stream的每个元素（这里是List）映射为Stream，然后合并成一个新的Stream：</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210916184519.png"></p>
<p><strong>并行</strong></p>
<p>通常情况下，对Stream的元素进行处理是单线程的，即一个一个元素进行处理。但是很多时候，我们希望可以并行处理Stream的元素，因为在元素数量非常大的情况，并行处理可以大大加快处理速度。</p>
<p>把一个普通Stream转换为可以并行处理的Stream非常简单，只需要用parallel()进行转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; s = ...</span><br><span class="line">String[] result = s.parallel() <span class="comment">// 变成一个可以并行处理的Stream</span></span><br><span class="line">                   .sorted() <span class="comment">// 可以进行并行排序</span></span><br><span class="line">                   .toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<p>经过parallel()转换后的Stream只要可能，就会对后续操作进行并行处理。我们不需要编写任何多线程代码就可以享受到并行处理带来的执行效率的提升。</p>
<p><strong>其他聚合方法</strong></p>
<p>除了reduce()和collect()外，Stream还有一些常用的聚合方法：</p>
<ul>
<li>count()：用于返回元素个数；</li>
<li>max(Comparator&lt;? super T&gt; cp)：找出最大元素；</li>
<li>min(Comparator&lt;? super T&gt; cp)：找出最小元素。</li>
</ul>
<p>针对IntStream、LongStream和DoubleStream，还额外提供了以下聚合方法：</p>
<ul>
<li>sum()：对所有元素求和；</li>
<li>average()：对所有元素求平均数。</li>
</ul>
<p>还有一些方法，用来测试Stream的元素是否满足以下条件：</p>
<ul>
<li>boolean allMatch(Predicate&lt;? super T&gt;)：测试是否所有元素均满足测试条件；</li>
<li>boolean anyMatch(Predicate&lt;? super T&gt;)：测试是否至少有一个元素满足测试条件。</li>
</ul>
<p>最后一个常用的方法是forEach()，它可以循环处理Stream的每个元素，我们经常传入System.out::println来打印Stream的元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; s = ...</span><br><span class="line">s.forEach(str -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello, &quot;</span> + str);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Stream提供的常用操作有：</p>
<ul>
<li>转换操作：map()，filter()，sorted()，distinct()； </li>
<li>合并操作：concat()，flatMap()；</li>
<li>并行处理：parallel()；</li>
<li>聚合操作：reduce()，collect()，count()，max()，min()，sum()，average()；</li>
<li>其他操作：allMatch(), anyMatch(), forEach()。</li>
</ul>
<br>
<br>]]></content>
      <categories>
        <category>专业知识</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 核心技术 - 单元测试</title>
    <url>/2021/09/15/cs-basic/cs-basic-language/cs-basic-language-java/Java%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%20-%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="编写JUnit测试"><a href="#编写JUnit测试" class="headerlink" title="编写JUnit测试"></a>编写JUnit测试</h2><p>什么是单元测试呢？单元测试就是针对最小的功能单元编写测试代码。Java程序最小的功能单元是方法，因此，对Java程序进行单元测试就是针对单个Java方法的测试。</p>
<p>单元测试有什么好处呢？在学习单元测试前，我们可以先了解一下测试驱动开发。</p>
<p>所谓测试驱动开发，是指先编写接口，紧接着编写测试。编写完测试后，我们才开始真正编写实现代码。在编写实现代码的过程中，一边写，一边测，什么时候测试全部通过了，那就表示编写的实现完成了：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626230737.png"></p>
<p>这就是传说中的……</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626230802.png"></p>
<p>当然，这是一种理想情况。大部分情况是我们已经编写了实现代码，需要对已有的代码进行测试。</p>
<p>JUnit</p>
<p>JUnit是一个开源的Java语言的单元测试框架，专门针对Java设计，使用最广泛。JUnit是事实上的单元测试的标准框架，任何Java开发者都应当学习并使用JUnit编写单元测试。</p>
<p>使用JUnit编写单元测试的好处在于，我们可以非常简单地组织测试代码，并随时运行它们，JUnit就会给出成功的测试和失败的测试，还可以生成测试报告，不仅包含测试的成功率，还可以统计测试的代码覆盖率，即被测试的代码本身有多少经过了测试。对于高质量的代码来说，测试覆盖率应该在80%以上。</p>
<p>此外，几乎所有的IDE工具都集成了JUnit，这样我们就可以直接在IDE中编写并运行JUnit测试。</p>
<p>核心测试方法testFact()加上了@Test注解，这是JUnit要求的，它会把带有@Test的方法识别为测试方法。在测试方法内部，我们用assertEquals(1, Factorial.fact(1))表示，期望Factorial.fact(1)返回1。assertEquals(expected, actual)是最常用的测试方法，它在Assertion类中定义。Assertion还定义了其他断言方法，例如：</p>
<ul>
<li>assertTrue(): 期待结果为true</li>
<li>assertFalse(): 期待结果为false</li>
<li>assertNotNull(): 期待结果为非null</li>
<li>assertArrayEquals(): 期待结果为数组并与期望数组每个元素的值均相等</li>
<li>…</li>
</ul>
<p><strong>单元测试的好处</strong></p>
<p>单元测试可以确保单个方法按照正确预期运行，如果修改了某个方法的代码，只需确保其对应的单元测试通过，即可认为改动正确。此外，测试代码本身就可以作为示例代码，用来演示如何调用该方法。</p>
<p>使用JUnit进行单元测试，我们可以使用断言（Assertion）来测试期望结果，可以方便地组织和运行测试，并方便地查看测试结果。此外，JUnit既可以直接在IDE中运行，也可以方便地集成到Maven这些自动化工具中运行。</p>
<p>在编写单元测试的时候，我们要遵循一定的规范：</p>
<p>一是单元测试代码本身必须非常简单，能一下看明白，决不能再为测试代码编写测试；</p>
<p>二是每个单元测试应当互相独立，不依赖运行的顺序；</p>
<p>三是测试时不但要覆盖常用测试用例，还要特别注意测试边界条件，例如输入为0，null，空字符串””等情况。</p>
<h2 id="使用Fixture"><a href="#使用Fixture" class="headerlink" title="使用Fixture"></a>使用Fixture</h2><p>在一个单元测试中，我们经常编写多个@Test方法，来分组、分类对目标代码进行测试。</p>
<p>在测试的时候，我们经常遇到一个对象需要初始化，测试完可能还需要清理的情况。如果每个@Test方法都写一遍这样的重复代码，显然比较麻烦。</p>
<p>JUnit提供了编写测试前准备、测试后清理的固定代码，我们称之为Fixture。</p>
<p>编写Fixture的套路如下：</p>
<ul>
<li><p>对于实例变量，在@BeforeEach中初始化，在@AfterEach中清理，它们在各个@Test方法中互不影响，因为是不同的实例；</p>
</li>
<li><p>对于静态变量，在@BeforeAll中初始化，在@AfterAll中清理，它们在各个@Test方法中均是唯一实例，会影响各个@Test方法。</p>
</li>
</ul>
<p>大多数情况下，使用@BeforeEach和@AfterEach就足够了。只有某些测试资源初始化耗费时间太长，以至于我们不得不尽量“复用”时才会用到@BeforeAll和@AfterAll。</p>
<p>最后，注意到每次运行一个@Test方法前，JUnit首先创建一个XxxTest实例，因此，每个@Test方法内部的成员变量都是独立的，不能也无法把成员变量的状态从一个@Test方法带到另一个@Test方法。</p>
<h2 id="异常测试"><a href="#异常测试" class="headerlink" title="异常测试"></a>异常测试</h2><p>在Java程序中，异常处理是非常重要的。</p>
<p>我们自己编写的方法，也经常抛出各种异常。对于可能抛出的异常进行测试，本身就是测试的重要环节。</p>
<p>因此，在编写JUnit测试的时候，除了正常的输入输出，我们还要特别针对可能导致异常的情况进行测试。</p>
<p>JUnit提供assertThrows()来期望捕获一个指定的异常。第二个参数Executable封装了我们要执行的会产生异常的代码。当我们执行Factorial.fact(-1)时，必定抛出IllegalArgumentException。assertThrows()在捕获到指定异常时表示通过测试，未捕获到异常，或者捕获到的异常类型不对，均表示测试失败。</p>
<p>有些童鞋会觉得编写一个Executable的匿名类太繁琐了。实际上，Java 8开始引入了函数式编程，所有单方法接口都可以简写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testNegative</span><span class="params">()</span> &#123;</span><br><span class="line">    assertThrows(IllegalArgumentException.class, () -&gt; &#123;</span><br><span class="line">        Factorial.fact(-<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h2><p>在运行测试的时候，有些时候，我们需要排出某些@Test方法，不要让它运行，这时，我们就可以给它标记一个@Disabled：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Disabled</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBug101</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这个测试不会运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么我们不直接注释掉@Test，而是要加一个@Disabled？这是因为注释掉@Test，JUnit就不知道这是个测试方法，而加上@Disabled，JUnit仍然识别出这是个测试方法，只是暂时不运行。它会在测试结果中显示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Tests run: <span class="number">68</span>, Failures: <span class="number">2</span>, Errors: <span class="number">0</span>, Skipped: <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>类似@Disabled这种注解就称为条件测试，JUnit根据不同的条件注解，决定是否运行当前的@Test方法。</p>
<h2 id="参数化测试"><a href="#参数化测试" class="headerlink" title="参数化测试"></a>参数化测试</h2><p>果待测试的输入和输出是一组数据： 可以把测试数据组织起来 用不同的测试数据调用相同的测试方法</p>
<p>参数化测试和普通测试稍微不同的地方在于，一个测试方法需要接收至少一个参数，然后，传入一组参数反复运行。</p>
<p>JUnit提供了一个@ParameterizedTest注解，用来进行参数化测试。</p>
<p>假设我们想对Math.abs()进行测试，先用一组正数进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(ints = &#123; 0, 1, 5, 100 &#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAbs</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    assertEquals(x, Math.abs(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再用一组负数进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(ints = &#123; -1, -5, -100 &#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAbsNegative</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    assertEquals(-x, Math.abs(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到参数化测试的注解是@ParameterizedTest，而不是普通的@Test。</p>
<p>实际的测试场景往往没有这么简单。假设我们自己编写了一个StringUtils.capitalize()方法，它会把字符串的第一个字母变为大写，后续字母变为小写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">capitalize</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Character.toUpperCase(s.charAt(<span class="number">0</span>)) + s.substring(<span class="number">1</span>).toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要用参数化测试的方法来测试，我们不但要给出输入，还要给出预期输出。因此，测试方法至少需要接收两个参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCapitalize</span><span class="params">(String input, String result)</span> &#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在问题来了：参数如何传入？</p>
<p>最简单的方法是通过@MethodSource注解，它允许我们编写一个同名的静态方法来提供测试参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@MethodSource</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCapitalize</span><span class="params">(String input, String result)</span> &#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> List&lt;Arguments&gt; <span class="title function_">testCapitalize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> List.of( <span class="comment">// arguments:</span></span><br><span class="line">            Arguments.arguments(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;Abc&quot;</span>), <span class="comment">//</span></span><br><span class="line">            Arguments.arguments(<span class="string">&quot;APPLE&quot;</span>, <span class="string">&quot;Apple&quot;</span>), <span class="comment">//</span></span><br><span class="line">            Arguments.arguments(<span class="string">&quot;gooD&quot;</span>, <span class="string">&quot;Good&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码很容易理解：静态方法testCapitalize()返回了一组测试参数，每个参数都包含两个String，正好作为测试方法的两个参数传入。</p>
<blockquote>
<p>如果静态方法和测试方法的名称不同，@MethodSource也允许指定方法名。但使用默认同名方法最方便</p>
</blockquote>
<p>另一种传入测试参数的方法是使用@CsvSource，它的每一个字符串表示一行，一行包含的若干参数用,分隔，因此，上述测试又可以改写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvSource(&#123; &quot;abc, Abc&quot;, &quot;APPLE, Apple&quot;, &quot;gooD, Good&quot; &#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCapitalize</span><span class="params">(String input, String result)</span> &#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有成百上千的测试输入，那么，直接写@CsvSource就很不方便。这个时候，我们可以把测试数据提到一个独立的CSV文件中，然后标注上@CsvFileSource：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvFileSource(resources = &#123; &quot;/test-capitalize.csv&quot; &#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCapitalizeUsingCsvFile</span><span class="params">(String input, String result)</span> &#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JUnit只在classpath中查找指定的CSV文件，因此，test-capitalize.csv这个文件要放到test目录下，内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">apple, Apple</span><br><span class="line">HELLO, Hello</span><br><span class="line">JUnit, Junit</span><br><span class="line">reSource, Resource</span><br></pre></td></tr></table></figure>

</br>
</br>]]></content>
      <categories>
        <category>专业知识</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 核心技术 - JVM</title>
    <url>/2022/06/26/cs-basic/cs-basic-language/cs-basic-language-java/Java%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%20-%20JVM/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626223006.png"></p>
<h2 id="JVM-体系结构"><a href="#JVM-体系结构" class="headerlink" title="JVM 体系结构"></a>JVM 体系结构</h2><p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626095252.png"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626100749.png"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626111850.png"></p>
<p>堆内存模型</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626163802.png"></p>
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626110129.png"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。</p>
<h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626110536.png"></p>
<p>该区域可能抛出以下异常：</p>
<ul>
<li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</li>
<li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。</p>
<p>本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626110717.png"></p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。</p>
<p>现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：</p>
<p>新生代（Young Generation）<br>老年代（Old Generation）<br>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。</p>
<p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</p>
<p>HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</p>
<p>方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。</p>
<h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</p>
<h3 id="判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收" class="headerlink" title="判断一个对象是否可被回收"></a>判断一个对象是否可被回收</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p>
<p>在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">Test</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        a.instance = b;</span><br><span class="line">        b.instance = a;</span><br><span class="line">        a = <span class="literal">null</span>;</span><br><span class="line">        b = <span class="literal">null</span>;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626164856.png"></p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。</p>
<p>Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：</p>
<ul>
<li>虚拟机栈中局部变量表中引用的对象</li>
<li>本地方法栈中 JNI 中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626165040.png"></p>
<h4 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h4><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。</p>
<p>主要是对常量池的回收和对类的卸载。</p>
<p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</p>
<p>类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</p>
<ul>
<li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li>
</ul>
<h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h4><p>类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p>
<p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。</p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p>
<p>Java 提供了四种强度不同的引用类型。</p>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>被强引用关联的对象不会被回收。</p>
<p>使用 new 一个新对象的方式来创建强引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p>
<p>使用 SoftReference 类来创建软引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure>

<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p>
<p>使用 WeakReference 类来创建弱引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p>
<p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p>
<p>使用 PhantomReference 来创建虚引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(obj, <span class="literal">null</span>);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记 - 清除"></a>标记 - 清除</h4><p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626201313.png"></p>
<p>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。</p>
<p>在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。</p>
<p>在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。</p>
<p>不足：</p>
<ul>
<li>标记和清除过程效率都不高；</li>
<li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li>
</ul>
<h4 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记 - 整理"></a>标记 - 整理</h4><p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626201444.png"></p>
<p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>优点:</p>
<ul>
<li>不会产生内存碎片</li>
</ul>
<p>不足:</p>
<ul>
<li>需要移动大量对象，处理效率比较低。</li>
</ul>
<h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626201524.png"></p>
<p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p>
<p>主要不足是只使用了内存的一半。</p>
<p>现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。</p>
<p>HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。</p>
<h4 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h4><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p>
<p>一般将堆分为新生代和老年代。</p>
<p>新生代使用：复制算法<br>老年代使用：标记 - 清除 或者 标记 - 整理 算法</p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626214223.png"></p>
<p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p>
<ul>
<li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li>
<li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li>
</ul>
<h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h4><p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626215742.png"></p>
<p>Serial 翻译为串行，也就是说它以串行的方式执行。</p>
<p>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。</p>
<p>它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p>
<p>它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。</p>
<h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626215824.png"></p>
<p>它是 Serial 收集器的多线程版本。</p>
<p>它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。</p>
<h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><p>与 ParNew 一样是多线程收集器。</p>
<p>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。</p>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p>
<p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p>
<p>可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>
<h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626215905.png"></p>
<p>是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：</p>
<ul>
<li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ul>
<h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626215946.png"></p>
<p>是 Parallel Scavenge 收集器的老年代版本。</p>
<p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p>
<h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h4><p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626220011.png"></p>
<p>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。</p>
<p>分为以下四个流程：</p>
<ul>
<li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li>
<li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li>
<li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li>
<li>并发清除：不需要停顿。</li>
</ul>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p>
<p>具有以下缺点：</p>
<ul>
<li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li>
<li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li>
<li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li>
</ul>
<h4 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h4><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p>
<p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626220154.png"></p>
<p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626220213.png"></p>
<p>过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p>
<p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626220251.png"></p>
<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ul>
<p>具备如下特点：</p>
<ul>
<li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li>
</ul>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><h3 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h3><ul>
<li><p>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</p>
</li>
<li><p>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</p>
</li>
</ul>
<h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><h4 id="对象优先在-Eden-分配"><a href="#对象优先在-Eden-分配" class="headerlink" title="对象优先在 Eden 分配"></a>对象优先在 Eden 分配</h4><p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p>
<h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p>
<p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p>
<p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p>
<h4 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h4><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p>
<p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p>
<h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p>
<p>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</p>
<h3 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件"></a>Full GC 的触发条件</h3><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</p>
<h4 id="调用-System-gc"><a href="#调用-System-gc" class="headerlink" title="调用 System.gc()"></a>调用 System.gc()</h4><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p>
<h4 id="老年代空间不足"><a href="#老年代空间不足" class="headerlink" title="老年代空间不足"></a>老年代空间不足</h4><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p>
<p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p>
<h4 id="空间分配担保失败"><a href="#空间分配担保失败" class="headerlink" title="空间分配担保失败"></a>空间分配担保失败</h4><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。</p>
<h4 id="JDK-1-7-及以前的永久代空间不足"><a href="#JDK-1-7-及以前的永久代空间不足" class="headerlink" title="JDK 1.7 及以前的永久代空间不足"></a>JDK 1.7 及以前的永久代空间不足</h4><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p>
<p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p>
<p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p>
<h4 id="Concurrent-Mode-Failure"><a href="#Concurrent-Mode-Failure" class="headerlink" title="Concurrent Mode Failure"></a>Concurrent Mode Failure</h4><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。</p>
<h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626220828.png"></p>
<p>包括以下 7 个阶段：</p>
<ul>
<li>加载（Loading）</li>
<li>验证（Verification）</li>
<li>准备（Preparation）</li>
<li>解析（Resolution）</li>
<li>初始化（Initialization）</li>
<li>使用（Using）</li>
<li>卸载（Unloading）</li>
</ul>
<h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><p>包含了加载、验证、准备、解析和初始化这 5 个阶段。</p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>加载是类加载的一个阶段，注意不要混淆。</p>
<p>加载过程完成以下三件事：</p>
<ul>
<li>通过类的完全限定名称获取定义该类的二进制字节流。</li>
<li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。</li>
<li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。</li>
</ul>
<p>其中二进制字节流可以从以下方式中获取：</p>
<ul>
<li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。</li>
<li>从网络中获取，最典型的应用是 Applet。</li>
<li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。</li>
<li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类。</li>
</ul>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。</p>
<p>实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。</p>
<p>初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>将常量池的符号引用替换为直接引用的过程。</p>
<p>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 &lt;clinit&gt;() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。</p>
<p><clinit>() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;                <span class="comment">// 给变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.print(i);  <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于父类的 <clinit>() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">B</span> <span class="operator">=</span> A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     System.out.println(Sub.B);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 <clinit>() 方法。但接口与类不同的是，执行接口的 <clinit>() 方法不需要先执行父接口的 <clinit>() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 <clinit>() 方法。</p>
<p>虚拟机会保证一个类的 <clinit>() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 <clinit>() 方法，其它线程都会阻塞等待，直到活动线程执行 <clinit>() 方法完毕。如果在一个类的 <clinit>() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</p>
<h3 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h3><h4 id="主动引用"><a href="#主动引用" class="headerlink" title="主动引用"></a>主动引用</h4><p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：</p>
<ul>
<li><p>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。</p>
</li>
<li><p>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。</p>
</li>
<li><p>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p>
</li>
<li><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；</p>
</li>
<li><p>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</p>
</li>
</ul>
<h4 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h4><p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p>
<p>通过子类引用父类的静态字段，不会导致子类初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(SubClass.value);  <span class="comment">// value 字段在 SuperClass 中定义</span></span><br></pre></td></tr></table></figure>

<p>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SuperClass[] sca = <span class="keyword">new</span> <span class="title class_">SuperClass</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br></pre></td></tr></table></figure>

<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。</p>
<p>这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。</p>
<h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：</p>
<ul>
<li><p>启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；</p>
</li>
<li><p>所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。</p>
</li>
</ul>
<p>从 Java 开发人员的角度看，类加载器可以划分得更细致一些：</p>
<ul>
<li><p>启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 <JRE_HOME>\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。</p>
</li>
<li><p>扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 <JAVA_HOME>&#x2F;lib&#x2F;ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</p>
</li>
<li><p>应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
</li>
</ul>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。</p>
<p>下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626221637.png"></p>
<h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h4><p>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。</p>
<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。</p>
<p>例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="comment">// The parent class loader for delegation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自动移类加载器实现"><a href="#自动移类加载器实现" class="headerlink" title="自动移类加载器实现"></a>自动移类加载器实现</h3><p>以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。</p>
<p>java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileSystemClassLoader</span><span class="params">(String rootDir)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">byte</span>[] classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> classNameToPath(className);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">bufferSize</span> <span class="operator">=</span> <span class="number">4096</span>;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[bufferSize];</span><br><span class="line">            <span class="type">int</span> bytesNumRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">classNameToPath</span><span class="params">(String className)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ul>
<li>JVM 的内存模型和分区 - 详细到每个区放什么？</li>
<li>堆里面的分区有哪些？Eden，from，to，老年区，说说他们的特点。</li>
<li>GC 的算法有哪些？标记清除、标记整理、复制算法、引用计数器，怎么用的？</li>
<li>轻GC 和重GC 分别在什么时候发生？</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8">https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8</a></li>
</ul>
</br>
</br>]]></content>
      <categories>
        <category>专业知识</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 核心技术 - Maven</title>
    <url>/2021/09/24/cs-basic/cs-basic-language/cs-basic-language-java/Java%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%20-%20Maven/</url>
    <content><![CDATA[<p>Maven是一个Java项目管理和构建工具，它可以定义项目结构、项目依赖，并使用统一的方式进行自动化构建，是Java项目不可缺少的工具。</p>
<h2 id="Maven介绍"><a href="#Maven介绍" class="headerlink" title="Maven介绍"></a>Maven介绍</h2><p>在了解Maven之前，我们先来看看一个Java项目需要的东西。首先，我们需要确定引入哪些依赖包。例如，如果我们需要用到commons logging，我们就必须把commons logging的jar包放入classpath。如果我们还需要log4j，就需要把log4j相关的jar包都放到classpath中。这些就是依赖包的管理。</p>
<p>其次，我们要确定项目的目录结构。例如，src目录存放Java源码，resources目录存放配置文件，bin目录存放编译生成的.class文件。</p>
<p>此外，我们还需要配置环境，例如JDK的版本，编译打包的流程，当前代码的版本号。</p>
<p>最后，除了使用Eclipse这样的IDE进行编译外，我们还必须能通过命令行工具进行编译，才能够让项目在一个独立的服务器上编译、测试、部署。</p>
<p>这些工作难度不大，但是非常琐碎且耗时。如果每一个项目都自己搞一套配置，肯定会一团糟。我们需要的是一个标准化的Java项目管理和构建工具。</p>
<p>Maven就是是专门为Java项目打造的管理和构建工具，它的主要功能有：</p>
<ul>
<li>提供了一套标准化的项目结构；</li>
<li>提供了一套标准化的构建流程（编译，测试，打包，发布……）；</li>
<li>提供了一套依赖管理机制。</li>
</ul>
<h3 id="Maven项目结构"><a href="#Maven项目结构" class="headerlink" title="Maven项目结构"></a>Maven项目结构</h3><p>一个使用Maven管理的普通的Java项目，它的目录结构默认如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a-maven-project</span><br><span class="line">├── pom.xml</span><br><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   ├── java</span><br><span class="line">│   │   └── resources</span><br><span class="line">│   └── test</span><br><span class="line">│       ├── java</span><br><span class="line">│       └── resources</span><br><span class="line">└── target</span><br></pre></td></tr></table></figure>

<p>项目的根目录a-maven-project是项目名，它有一个项目描述文件pom.xml，存放Java源码的目录是src&#x2F;main&#x2F;java，存放资源文件的目录是src&#x2F;main&#x2F;resources，存放测试源码的目录是src&#x2F;test&#x2F;java，存放测试资源的目录是src&#x2F;test&#x2F;resources，最后，所有编译、打包生成的文件都放在target目录里。这些就是一个Maven项目的标准目录结构。</p>
<p>所有的目录结构都是约定好的标准结构，我们千万不要随意修改目录结构。使用标准结构不需要做任何配置，Maven就可以正常使用。</p>
<p>我们再来看最关键的一个项目描述文件pom.xml，它的内容长得像下面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;project ...&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hello&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<p>其中，groupId类似于Java的包名，通常是公司或组织名称，artifactId类似于Java的类名，通常是项目名称，再加上version，一个Maven工程就是由groupId，artifactId和version作为唯一标识。我们在引用其他第三方库的时候，也是通过这3个变量确定。例如，依赖commons-logging：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>使用<dependency>声明一个依赖后，Maven就会自动下载这个依赖包并把它放到classpath中。</p>
<p><strong>Maven是一个Java项目的管理和构建工具：</strong></p>
<ul>
<li>Maven使用pom.xml定义项目内容，并使用预设的目录结构；</li>
<li>在Maven中声明一个依赖项可以自动下载并导入classpath；</li>
<li>Maven使用groupId，artifactId和version唯一定位一个依赖。</li>
</ul>
<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>如果我们的项目依赖第三方的jar包，例如commons logging，那么问题来了：commons logging发布的jar包在哪下载？</p>
<p>如果我们还希望依赖log4j，那么使用log4j需要哪些jar包？</p>
<p>类似的依赖还包括：JUnit，JavaMail，MySQL驱动等等，一个可行的方法是通过搜索引擎搜索到项目的官网，然后手动下载zip包，解压，放入classpath。但是，这个过程非常繁琐。</p>
<p>Maven解决了依赖管理问题。例如，我们的项目依赖abc这个jar包，而abc又依赖xyz这个jar包：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626231225.png"></p>
<p>当我们声明了abc的依赖时，Maven自动把abc和xyz都加入了我们的项目依赖，不需要我们自己去研究abc是否需要依赖xyz。</p>
<p>因此，Maven的第一个作用就是解决依赖管理。我们声明了自己的项目需要abc，Maven会自动导入abc的jar包，再判断出abc需要xyz，又会自动导入xyz的jar包，这样，最终我们的项目会依赖abc和xyz两个jar包。</p>
<h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>Maven定义了几种依赖关系，分别是compile、test、runtime和provided：</p>
<table>
<thead>
<tr>
<th>scope</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>compile</td>
<td>编译时需要用到该jar包（默认）</td>
<td>commons-logging</td>
</tr>
<tr>
<td>test</td>
<td>编译Test时需要用到该jar包</td>
<td>junit</td>
</tr>
<tr>
<td>runtime</td>
<td>编译时不需要，但运行时需要用到</td>
<td>mysql</td>
</tr>
<tr>
<td>provided</td>
<td>编译时需要用到，但运行时由JDK或某个服务器提供</td>
<td>servlet-api</td>
</tr>
</tbody></table>
<p>最后一个问题是，Maven如何知道从何处下载所需的依赖？也就是相关的jar包？答案是Maven维护了一个中央仓库（repo1.maven.org），所有第三方库将自身的jar以及相关信息上传至中央仓库，Maven就可以从中央仓库把所需依赖下载到本地。</p>
<p>Maven并不会每次都从中央仓库下载jar包。一个jar包一旦被下载过，就会被Maven自动缓存在本地目录（用户主目录的.m2目录），所以，除了第一次编译时因为下载需要时间会比较慢，后续过程因为有本地缓存，并不会重复下载相同的jar包。</p>
<h3 id="唯一ID"><a href="#唯一ID" class="headerlink" title="唯一ID"></a>唯一ID</h3><p>对于某个依赖，Maven只需要3个变量即可唯一确定某个jar包：</p>
<ul>
<li>groupId：属于组织的名称，类似Java的包名；</li>
<li>artifactId：该jar包自身的名称，类似Java的类名；</li>
<li>version：该jar包的版本。</li>
</ul>
<p>通过上述3个变量，即可唯一确定某个jar包。Maven通过对jar包进行PGP签名确保任何一个jar包一经发布就无法修改。修改已发布jar包的唯一方法是发布一个新版本。</p>
<p>因此，某个jar包一旦被Maven下载过，即可永久地安全缓存在本地。</p>
<p>注：只有以-SNAPSHOT结尾的版本号会被Maven视为开发版本，开发版本每次都会重复下载，这种SNAPSHOT版本只能用于内部私有的Maven repo，公开发布的版本不允许出现SNAPSHOT。</p>
<h3 id="Maven镜像"><a href="#Maven镜像" class="headerlink" title="Maven镜像"></a>Maven镜像</h3><p>除了可以从Maven的中央仓库下载外，还可以从Maven的镜像仓库下载。如果访问Maven的中央仓库非常慢，我们可以选择一个速度较快的Maven的镜像仓库。Maven镜像仓库定期从中央仓库同步：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626231246.png"></p>
<p>中国区用户可以使用阿里云提供的Maven镜像仓库。使用Maven镜像仓库需要一个配置，在用户主目录下进入.m2目录，创建一个settings.xml配置文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">    &lt;mirrors&gt;</span><br><span class="line">        &lt;mirror&gt;</span><br><span class="line">            &lt;id&gt;aliyun&lt;/id&gt;</span><br><span class="line">            &lt;name&gt;aliyun&lt;/name&gt;</span><br><span class="line">            &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">            &lt;!-- 国内推荐阿里云的Maven镜像 --&gt;</span><br><span class="line">            &lt;url&gt;https://maven.aliyun.com/repository/central&lt;/url&gt;</span><br><span class="line">        &lt;/mirror&gt;</span><br><span class="line">    &lt;/mirrors&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>

<p>配置镜像仓库后，Maven的下载速度就会非常快。</p>
<h3 id="搜索第三方组件"><a href="#搜索第三方组件" class="headerlink" title="搜索第三方组件"></a>搜索第三方组件</h3><p>最后一个问题：如果我们要引用一个第三方组件，比如okhttp，如何确切地获得它的groupId、artifactId和version？方法是通过search.maven.org搜索关键字，找到对应的组件后，直接复制：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626231306.png"></p>
<h3 id="命令行编译"><a href="#命令行编译" class="headerlink" title="命令行编译"></a>命令行编译</h3><p>在命令中，进入到pom.xml所在目录，输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mvn clean package</span></span><br></pre></td></tr></table></figure>

<h2 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h2><p>Maven不但有标准化的项目结构，而且还有一套标准化的构建流程，可以自动化实现编译，打包，发布，等等。</p>
<h3 id="Lifecycle和Phase"><a href="#Lifecycle和Phase" class="headerlink" title="Lifecycle和Phase"></a>Lifecycle和Phase</h3><p>使用Maven时，我们首先要了解什么是Maven的生命周期（lifecycle）。</p>
<p>Maven的生命周期由一系列阶段（phase）构成，以内置的生命周期default为例，它包含以下phase：</p>
<ul>
<li>validate</li>
<li>initialize</li>
<li>generate-sources</li>
<li>process-sources</li>
<li>generate-resources</li>
<li>process-resources</li>
<li>compile</li>
<li>process-classes</li>
<li>generate-test-sources</li>
<li>process-test-sources</li>
<li>generate-test-resources</li>
<li>process-test-resources</li>
<li>test-compile</li>
<li>process-test-classes</li>
<li>test</li>
<li>prepare-package</li>
<li>package</li>
<li>pre-integration-test</li>
<li>integration-test</li>
<li>post-integration-test</li>
<li>verify</li>
<li>install</li>
<li>deploy</li>
</ul>
<p>如果我们运行mvn package，Maven就会执行default生命周期，它会从开始一直运行到package这个phase为止：</p>
<ul>
<li>validate</li>
<li>…</li>
<li>package</li>
</ul>
<p>如果我们运行mvn compile，Maven也会执行default生命周期，但这次它只会运行到compile，即以下几个phase：</p>
<ul>
<li>validate</li>
<li>…</li>
<li>compile</li>
</ul>
<p>Maven另一个常用的生命周期是clean，它会执行3个phase：</p>
<ul>
<li>pre-clean</li>
<li>clean （注意这个clean不是lifecycle而是phase）</li>
<li>post-clean</li>
</ul>
<p>所以，我们使用mvn这个命令时，后面的参数是phase，Maven自动根据生命周期运行到指定的phase。</p>
<p>更复杂的例子是指定多个phase，例如，运行mvn clean package，Maven先执行clean生命周期并运行到clean这个phase，然后执行default生命周期并运行到package这个phase，实际执行的phase如下：</p>
<ul>
<li>pre-clean</li>
<li>clean （注意这个clean是phase）</li>
<li>validate</li>
<li>…</li>
<li>package</li>
</ul>
<p>在实际开发过程中，经常使用的命令有：</p>
<ul>
<li>mvn clean：清理所有生成的class和jar；</li>
<li>mvn clean compile：先清理，再执行到compile；</li>
<li>mvn clean test：先清理，再执行到test，因为执行test前必须执行compile，所以这里不必指定compile；</li>
<li>mvn clean package：先清理，再执行到package。</li>
</ul>
<p>大多数phase在执行过程中，因为我们通常没有在pom.xml中配置相关的设置，所以这些phase什么事情都不做。</p>
<p>经常用到的phase其实只有几个：</p>
<ul>
<li>clean：清理</li>
<li>compile：编译</li>
<li>test：运行测试</li>
<li>package：打包</li>
</ul>
<p><strong>Goal</strong></p>
<p>执行一个phase又会触发一个或多个goal：</p>
<table>
<thead>
<tr>
<th>执行的Phase</th>
<th>对应执行的Goal</th>
</tr>
</thead>
<tbody><tr>
<td>compile</td>
<td>compiler:compile</td>
</tr>
<tr>
<td>test</td>
<td>compiler:testCompile</td>
</tr>
<tr>
<td>surefire:test</td>
<td></td>
</tr>
</tbody></table>
<p>goal的命名总是abc:xyz这种形式。</p>
<p>看到这里，相信大家对lifecycle、phase和goal已经明白了吧？</p>
<p>其实我们类比一下就明白了：</p>
<ul>
<li>lifecycle相当于Java的package，它包含一个或多个phase；</li>
<li>phase相当于Java的class，它包含一个或多个goal；</li>
<li>goal相当于class的method，它其实才是真正干活的。</li>
</ul>
<p>大多数情况，我们只要指定phase，就默认执行这些phase默认绑定的goal，只有少数情况，我们可以直接指定运行一个goal，例如，启动Tomcat服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn tomcat:run</span><br></pre></td></tr></table></figure>

<p>Maven通过lifecycle、phase和goal来提供标准的构建流程。</p>
<p>最常用的构建命令是指定phase，然后让Maven执行到指定的phase：</p>
<ul>
<li>mvn clean</li>
<li>mvn clean compile</li>
<li>mvn clean test</li>
<li>mvn clean package</li>
</ul>
<p>通常情况，我们总是执行phase默认绑定的goal，因此不必指定goal。</p>
<h3 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h3><p>在软件开发中，把一个大项目分拆为多个模块是降低软件复杂度的有效方法：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626231329.png"></p>
<p>对于Maven工程来说，原来是一个大项目：</p>
<p>single-project<br>├── pom.xml<br>└── src</p>
<p>现在可以分拆成3个模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutiple-project</span><br><span class="line">├── module-a</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">├── module-b</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">└── module-c</span><br><span class="line">    ├── pom.xml</span><br><span class="line">    └── src</span><br></pre></td></tr></table></figure>

<p>Maven可以有效地管理多个模块，我们只需要把每个模块当作一个独立的Maven项目，它们有各自独立的pom.xml。例如，模块A的pom.xml：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">    xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;<span class="keyword">module</span>-a&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.0</span>&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;<span class="keyword">module</span>-a&lt;/name&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-<span class="number">8</span>&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-<span class="number">8</span>&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;<span class="number">11</span>&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;<span class="number">11</span>&lt;/maven.compiler.target&gt;</span><br><span class="line">        &lt;java.version&gt;<span class="number">11</span>&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.7</span><span class="number">.28</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.2</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">5.5</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<p>模块B的pom.xml：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">    xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;<span class="keyword">module</span>-b&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.0</span>&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;<span class="keyword">module</span>-b&lt;/name&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-<span class="number">8</span>&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-<span class="number">8</span>&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;<span class="number">11</span>&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;<span class="number">11</span>&lt;/maven.compiler.target&gt;</span><br><span class="line">        &lt;java.version&gt;<span class="number">11</span>&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.7</span><span class="number">.28</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.2</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">5.5</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<p>可以看出来，模块A和模块B的pom.xml高度相似，因此，我们可以提取出共同部分作为parent：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">    xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.0</span>&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;parent&lt;/name&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-<span class="number">8</span>&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-<span class="number">8</span>&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;<span class="number">11</span>&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;<span class="number">11</span>&lt;/maven.compiler.target&gt;</span><br><span class="line">        &lt;java.version&gt;<span class="number">11</span>&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.7</span><span class="number">.28</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.2</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">5.5</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<p>注意到parent的<packaging>是pom而不是jar，因为parent本身不含任何Java代码。编写parent的pom.xml只是为了在各个模块中减少重复的配置。现在我们的整个工程结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">multiple-project</span><br><span class="line">├── pom.xml</span><br><span class="line">├── parent</span><br><span class="line">│   └── pom.xml</span><br><span class="line">├── module-a</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">├── module-b</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">└── module-c</span><br><span class="line">    ├── pom.xml</span><br><span class="line">    └── src</span><br></pre></td></tr></table></figure>

<p>这样模块A就可以简化为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">    xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;relativePath&gt;../parent/pom.xml&lt;/relativePath&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;<span class="keyword">module</span>-a&lt;/artifactId&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">    &lt;name&gt;<span class="keyword">module</span>-a&lt;/name&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<p>模块B、模块C都可以直接从parent继承，大幅简化了pom.xml的编写。</p>
<p>如果模块A依赖模块B，则模块A需要模块B的jar包才能正常编译，我们需要在模块A中引入模块B：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;<span class="keyword">module</span>-b&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>后，在编译的时候，需要在根目录创建一个pom.xml统一编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">    xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;build&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.0</span>&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">    &lt;name&gt;build&lt;/name&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;<span class="keyword">module</span>&gt;parent&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">module</span>&gt;<span class="keyword">module</span>-a&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">module</span>&gt;<span class="keyword">module</span>-b&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">module</span>&gt;<span class="keyword">module</span>-c&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<p>这样，在根目录执行mvn clean package时，Maven根据根目录的pom.xml找到包括parent在内的共4个<module>，一次性全部编译。</p>
<p><strong>中央仓库</strong></p>
<p>其实我们使用的大多数第三方模块都是这个用法，例如，我们使用commons logging、log4j这些第三方模块，就是第三方模块的开发者自己把编译好的jar包发布到Maven的中央仓库中。</p>
<p><strong>私有仓库</strong></p>
<p>私有仓库是指公司内部如果不希望把源码和jar包放到公网上，那么可以搭建私有仓库。私有仓库总是在公司内部使用，它只需要在本地的~&#x2F;.m2&#x2F;settings.xml中配置好，使用方式和中央仓位没有任何区别。</p>
<p><strong>本地仓库</strong></p>
<p>本地仓库是指把本地开发的项目“发布”在本地，这样其他项目可以通过本地仓库引用它。但是我们不推荐把自己的模块安装到Maven的本地仓库，因为每次修改某个模块的源码，都需要重新安装，非常容易出现版本不一致的情况。更好的方法是使用模块化编译，在编译的时候，告诉Maven几个模块之间存在依赖关系，需要一块编译，Maven就会自动按依赖顺序编译这些模块。</p>
<h2 id="发布Artifact"><a href="#发布Artifact" class="headerlink" title="发布Artifact"></a>发布Artifact</h2><p>当我们使用commons-logging这些第三方开源库的时候，我们实际上是通过Maven自动下载它的jar包，并根据其pom.xml解析依赖，自动把相关依赖包都下载后加入到classpath。</p>
<p>那么问题来了：当我们自己写了一个牛逼的开源库时，非常希望别人也能使用，总不能直接放个jar包的链接让别人下载吧？</p>
<p>如果我们把自己的开源库放到Maven的repo中，那么，别人只需按标准引用groupId:artifactId:version，即可自动下载jar包以及相关依赖。因此，本节我们介绍如何发布一个库到Maven的repo中。</p>
<p>把自己的库发布到Maven的repo中有好几种方法，我们介绍3种最常用的方法。</p>
<h3 id="以静态文件发布"><a href="#以静态文件发布" class="headerlink" title="以静态文件发布"></a>以静态文件发布</h3><p>如果我们观察一个中央仓库的Artifact结构，例如Commons Math，它的groupId是org.apache.commons，artifactId是commons-math3，以版本3.6.1为例，发布在中央仓库的文件夹路径就是<a href="https://repo1.maven.org/maven2/org/apache/commons/commons-math3/3.6.1/%EF%BC%8C%E5%9C%A8%E6%AD%A4%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%EF%BC%8Ccommons-math3-3.6.1.jar%E5%B0%B1%E6%98%AF%E5%8F%91%E5%B8%83%E7%9A%84jar%E5%8C%85%EF%BC%8Ccommons-math3-3.6.1.pom%E5%B0%B1%E6%98%AF%E5%AE%83%E7%9A%84pom.xml%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6%EF%BC%8Ccommons-math3-3.6.1-sources.jar%E6%98%AF%E6%BA%90%E4%BB%A3%E7%A0%81%EF%BC%8Ccommons-math3-3.6.1-javadoc.jar%E6%98%AF%E6%96%87%E6%A1%A3%E3%80%82%E5%85%B6%E5%AE%83%E4%BB%A5.asc%E3%80%81.md5%E3%80%81.sha1%E7%BB%93%E5%B0%BE%E7%9A%84%E6%96%87%E4%BB%B6%E5%88%86%E5%88%AB%E6%98%AFGPG%E7%AD%BE%E5%90%8D%E3%80%81MD5%E6%91%98%E8%A6%81%E5%92%8CSHA-1%E6%91%98%E8%A6%81%E3%80%82">https://repo1.maven.org/maven2/org/apache/commons/commons-math3/3.6.1/，在此文件夹下，commons-math3-3.6.1.jar就是发布的jar包，commons-math3-3.6.1.pom就是它的pom.xml描述文件，commons-math3-3.6.1-sources.jar是源代码，commons-math3-3.6.1-javadoc.jar是文档。其它以.asc、.md5、.sha1结尾的文件分别是GPG签名、MD5摘要和SHA-1摘要。</a></p>
<p>我们只要按照这种目录结构组织文件，它就是一个有效的Maven仓库。</p>
<p>我们以广受好评的开源项目how-to-become-rich为例，先创建Maven工程目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">how-to-become-rich</span><br><span class="line">├── maven-repo        &lt;-- Maven本地文件仓库</span><br><span class="line">├── pom.xml           &lt;-- 项目文件</span><br><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   ├── java      &lt;-- 源码目录</span><br><span class="line">│   │   └── resources &lt;-- 资源目录</span><br><span class="line">│   └── test</span><br><span class="line">│       ├── java      &lt;-- 测试源码目录</span><br><span class="line">│       └── resources &lt;-- 测试资源目录</span><br><span class="line">└── target            &lt;-- 编译输出目录</span><br></pre></td></tr></table></figure>

<p>在pom.xml中添加如下内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;project ...&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;distributionManagement&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">            &lt;id&gt;local-repo-release&lt;/id&gt;</span><br><span class="line">            &lt;name&gt;GitHub Release&lt;/name&gt;</span><br><span class="line">            &lt;url&gt;file:<span class="comment">//$&#123;project.basedir&#125;/maven-repo&lt;/url&gt;</span></span><br><span class="line">        &lt;/repository&gt;</span><br><span class="line">    &lt;/distributionManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;attach-sources&lt;/id&gt;</span><br><span class="line">                        &lt;phase&gt;<span class="keyword">package</span>&lt;/phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;jar-no-fork&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;attach-javadocs&lt;/id&gt;</span><br><span class="line">                        &lt;phase&gt;<span class="keyword">package</span>&lt;/phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;jar&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<p>注意到<distributionManagement>，它指示了发布的软件包的位置，这里的<url>是项目根目录下的maven-repo目录，在<build>中定义的两个插件maven-source-plugin和maven-javadoc-plugin分别用来创建源码和javadoc，如果不想发布源码，可以把对应的插件去掉。</p>
<p>我们直接在项目根目录下运行Maven命令mvn clean package deploy，如果一切顺利，我们就可以在maven-repo目录下找到部署后的所有文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maven-repo</span><br><span class="line">└── com</span><br><span class="line">    └── itranswarp</span><br><span class="line">        └── rich</span><br><span class="line">            └── how-to-become-rich</span><br><span class="line">                ├── 1.0.0</span><br><span class="line">                │   ├── how-to-become-rich-1.0.0-javadoc.jar</span><br><span class="line">                │   ├── how-to-become-rich-1.0.0-javadoc.jar.md5</span><br><span class="line">                │   ├── how-to-become-rich-1.0.0-javadoc.jar.sha1</span><br><span class="line">                │   ├── how-to-become-rich-1.0.0-sources.jar</span><br><span class="line">                │   ├── how-to-become-rich-1.0.0-sources.jar.md5</span><br><span class="line">                │   ├── how-to-become-rich-1.0.0-sources.jar.sha1</span><br><span class="line">                │   ├── how-to-become-rich-1.0.0.jar</span><br><span class="line">                │   ├── how-to-become-rich-1.0.0.jar.md5</span><br><span class="line">                │   ├── how-to-become-rich-1.0.0.jar.sha1</span><br><span class="line">                │   ├── how-to-become-rich-1.0.0.pom</span><br><span class="line">                │   ├── how-to-become-rich-1.0.0.pom.md5</span><br><span class="line">                │   └── how-to-become-rich-1.0.0.pom.sha1</span><br><span class="line">                ├── maven-metadata.xml</span><br><span class="line">                ├── maven-metadata.xml.md5</span><br><span class="line">                └── maven-metadata.xml.sha1</span><br></pre></td></tr></table></figure>

<p>最后一步，是把这个工程推到GitHub上，并选择Settings-GitHub Pages，选择master branch启用Pages服务：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626231349.png"></p>
<p>这样，把全部内容推送至GitHub后，即可作为静态网站访问Maven的repo，它的地址是<a href="https://michaelliao.github.io/how-to-become-rich/maven-repo/%E3%80%82%E7%89%88%E6%9C%AC1.0.0%E5%AF%B9%E5%BA%94%E7%9A%84jar%E5%8C%85%E5%9C%B0%E5%9D%80%E6%98%AF%EF%BC%9A">https://michaelliao.github.io/how-to-become-rich/maven-repo/。版本1.0.0对应的jar包地址是：</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//michaelliao.github.io/how-to-become-rich/maven-repo/com/itranswarp/rich/how-to-become-rich/1.0.0/how-to-become-rich-1.0.0.jar</span></span><br></pre></td></tr></table></figure>

<p>现在，如果其他人希望引用这个Maven包，我们可以告知如下依赖即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.itranswarp.rich&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;how-to-become-rich&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.0</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>但是，除了正常导入依赖外，对方还需要再添加一个<repository>的声明，即使用方完整的pom.xml如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">    xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;example&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;how-to-become-rich-usage&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;<span class="number">11</span>&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;<span class="number">11</span>&lt;/maven.compiler.target&gt;</span><br><span class="line">        &lt;java.version&gt;<span class="number">11</span>&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;repositories&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">            &lt;id&gt;github-rich-repo&lt;/id&gt;</span><br><span class="line">            &lt;name&gt;The Maven Repository on Github&lt;/name&gt;</span><br><span class="line">            &lt;url&gt;https:<span class="comment">//michaelliao.github.io/how-to-become-rich/maven-repo/&lt;/url&gt;</span></span><br><span class="line">        &lt;/repository&gt;</span><br><span class="line">    &lt;/repositories&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.itranswarp.rich&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;how-to-become-rich&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.0</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<p>在<repository>中，我们必须声明发布的Maven的repo地址，其中<id>和<name>可以任意填写，<url>填入GitHub Pages提供的地址+&#x2F;maven-repo&#x2F;后缀。现在，即可正常引用这个库并编写代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Millionaire</span> <span class="variable">millionaire</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Millionaire</span>();</span><br><span class="line">System.out.println(millionaire.howToBecomeRich());</span><br></pre></td></tr></table></figure>

<p>有的童鞋会问，为什么使用commons-logging等第三方库时，并不需要声明repo地址？这是因为这些库都是发布到Maven中央仓库的，发布到中央仓库后，不需要告诉Maven仓库地址，因为它知道中央仓库的地址默认是<a href="https://repo1.maven.org/maven2/%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87~/.m2/settings.xml%E6%8C%87%E5%AE%9A%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%90%86%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80%E4%BB%A5%E6%9B%BF%E4%BB%A3%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93%E6%9D%A5%E6%8F%90%E9%AB%98%E9%80%9F%E5%BA%A6%EF%BC%88%E5%8F%82%E8%80%83%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E7%9A%84Maven%E9%95%9C%E5%83%8F%EF%BC%89%E3%80%82">https://repo1.maven.org/maven2/，也可以通过~/.m2/settings.xml指定一个代理仓库地址以替代中央仓库来提高速度（参考依赖管理的Maven镜像）。</a></p>
<p>因为GitHub Pages并不会把我们发布的Maven包同步到中央仓库，所以自然使用方必须手动添加一个我们提供的仓库地址。</p>
<p>此外，通过GitHub Pages发布Maven repo时需要注意一点，即不要改动已发布的版本。因为Maven的仓库是不允许修改任何版本的，对一个库进行修改的唯一方法是发布一个新版本。但是通过静态文件的方式发布repo，实际上我们是可以修改jar文件的，但最好遵守规范，不要修改已发布版本。</p>
<h3 id="通过Nexus发布到中央仓库"><a href="#通过Nexus发布到中央仓库" class="headerlink" title="通过Nexus发布到中央仓库"></a>通过Nexus发布到中央仓库</h3><p>有的童鞋会问，能不能把自己的开源库发布到Maven的中央仓库，这样用户就不需要声明repo地址，可以直接引用，显得更专业。</p>
<p>当然可以，但我们不能直接发布到Maven中央仓库，而是通过曲线救国的方式，发布到central.sonatype.org，它会定期自动同步到Maven的中央仓库。Nexus是一个支持Maven仓库的软件，由Sonatype开发，有免费版和专业版两个版本，很多大公司内部都使用Nexus作为自己的私有Maven仓库，而这个central.sonatype.org相当于面向开源的一个Nexus公共服务。</p>
<p>所以，第一步是在central.sonatype.org上注册一个账号，注册链接非常隐蔽，可以自己先找找，找半小时没找到点这里查看攻略。</p>
<p>如果注册顺利并审核通过，会得到一个登录账号，然后，通过这个页面一步一步操作就可以成功地将自己的Artifact发布到Nexus上，再耐心等待几个小时后，你的Artifact就会出现在Maven的中央仓库中。</p>
<p>这里简单提一下发布重点与难点：</p>
<ul>
<li>必须正确创建GPG签名，Linux和Mac下推荐使用gnupg2；</li>
<li>必须在~&#x2F;.m2&#x2F;settings.xml中配置好登录用户名和口令，以及GPG口令：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;settings ...&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;servers&gt;</span><br><span class="line">        &lt;server&gt;</span><br><span class="line">            &lt;id&gt;ossrh&lt;/id&gt;</span><br><span class="line">            &lt;username&gt;OSSRH-USERNAME&lt;/username&gt;</span><br><span class="line">            &lt;password&gt;OSSRH-PASSWORD&lt;/password&gt;</span><br><span class="line">        &lt;/server&gt;</span><br><span class="line">    &lt;/servers&gt;</span><br><span class="line">    &lt;profiles&gt;</span><br><span class="line">        &lt;profile&gt;</span><br><span class="line">            &lt;id&gt;ossrh&lt;/id&gt;</span><br><span class="line">            &lt;activation&gt;</span><br><span class="line">                &lt;activeByDefault&gt;<span class="literal">true</span>&lt;/activeByDefault&gt;</span><br><span class="line">            &lt;/activation&gt;</span><br><span class="line">            &lt;properties&gt;</span><br><span class="line">                &lt;gpg.executable&gt;gpg2&lt;/gpg.executable&gt;</span><br><span class="line">                &lt;gpg.passphrase&gt;GPG-PASSWORD&lt;/gpg.passphrase&gt;</span><br><span class="line">            &lt;/properties&gt;</span><br><span class="line">        &lt;/profile&gt;</span><br><span class="line">    &lt;/profiles&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>

<p>在待发布的Artifact的pom.xml中添加OSS的Maven repo地址，以及maven-jar-plugin、maven-source-plugin、maven-javadoc-plugin、maven-gpg-plugin、nexus-staging-maven-plugin：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;project ...&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;distributionManagement&gt;</span><br><span class="line">        &lt;snapshotRepository&gt;</span><br><span class="line">            &lt;id&gt;ossrh&lt;/id&gt;</span><br><span class="line">            &lt;url&gt;https:<span class="comment">//oss.sonatype.org/content/repositories/snapshots&lt;/url&gt;</span></span><br><span class="line">        &lt;/snapshotRepository&gt;</span><br><span class="line"></span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">            &lt;id&gt;ossrh&lt;/id&gt;</span><br><span class="line">            &lt;name&gt;Nexus Release Repository&lt;/name&gt;</span><br><span class="line">            &lt;url&gt;http:<span class="comment">//oss.sonatype.org/service/local/staging/deploy/maven2/&lt;/url&gt;</span></span><br><span class="line">        &lt;/repository&gt;</span><br><span class="line">    &lt;/distributionManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;jar&lt;/goal&gt;</span><br><span class="line">                            &lt;goal&gt;test-jar&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;attach-sources&lt;/id&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;jar-no-fork&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;attach-javadocs&lt;/id&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;jar&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;additionalOption&gt;</span><br><span class="line">                                &lt;additionalOption&gt;-Xdoclint:none&lt;/additionalOption&gt;</span><br><span class="line">                            &lt;/additionalOption&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-gpg-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;sign-artifacts&lt;/id&gt;</span><br><span class="line">                        &lt;phase&gt;verify&lt;/phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;sign&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.sonatype.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;nexus-staging-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;<span class="number">1.6</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">                &lt;extensions&gt;<span class="literal">true</span>&lt;/extensions&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;serverId&gt;ossrh&lt;/serverId&gt;</span><br><span class="line">                    &lt;nexusUrl&gt;https:<span class="comment">//oss.sonatype.org/&lt;/nexusUrl&gt;</span></span><br><span class="line">                    &lt;autoReleaseAfterClose&gt;<span class="literal">true</span>&lt;/autoReleaseAfterClose&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<p>最后执行命令mvn clean package deploy即可发布至central.sonatype.org。</p>
<p>此方法前期需要复杂的申请账号和项目的流程，后期需要安装调试GPG，但只要跑通流程，后续发布都只需要一行命令。</p>
<h3 id="发布到私有仓库"><a href="#发布到私有仓库" class="headerlink" title="发布到私有仓库"></a>发布到私有仓库</h3><p>通过nexus-staging-maven-plugin除了可以发布到central.sonatype.org外，也可以发布到私有仓库，例如，公司内部自己搭建的Nexus服务器。</p>
<p>如果没有私有Nexus服务器，还可以发布到GitHub Packages。GitHub Packages是GitHub提供的仓库服务，支持Maven、NPM、Docker等。使用GitHub Packages时，无论是发布Artifact，还是引用已发布的Artifact，都需要明确的授权Token，因此，GitHub Packages只能作为私有仓库使用。</p>
<p>在发布前，我们必须首先登录后在用户的Settings-Developer settings-Personal access tokens中创建两个Token，一个用于发布，一个用于使用。发布Artifact的Token必须有repo、write:packages和read:packages权限：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626231408.png"></p>
<p>使用Artifact的Token只需要read:packages权限。</p>
<p>在发布端，把GitHub的用户名和发布Token写入~&#x2F;.m2&#x2F;settings.xml配置中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;settings ...&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;servers&gt;</span><br><span class="line">        &lt;server&gt;</span><br><span class="line">            &lt;id&gt;github-release&lt;/id&gt;</span><br><span class="line">            &lt;username&gt;GITHUB-USERNAME&lt;/username&gt;</span><br><span class="line">            &lt;password&gt;f052...c21f&lt;/password&gt;</span><br><span class="line">        &lt;/server&gt;</span><br><span class="line">    &lt;/servers&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>

<p>然后，在需要发布的Artifact的pom.xml中，添加一个<repository>声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;project ...&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;distributionManagement&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">            &lt;id&gt;github-release&lt;/id&gt;</span><br><span class="line">            &lt;name&gt;GitHub Release&lt;/name&gt;</span><br><span class="line">            &lt;url&gt;https:<span class="comment">//maven.pkg.github.com/michaelliao/complex&lt;/url&gt;</span></span><br><span class="line">        &lt;/repository&gt;</span><br><span class="line">    &lt;/distributionManagement&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<p>注意到<id>和~&#x2F;.m2&#x2F;settings.xml配置中的<id>要保持一致，因为发布时Maven根据id找到用于登录的用户名和Token，才能成功上传文件到GitHub。我们直接通过命令mvn clean package deploy部署，成功后，在GitHub用户页面可以看到该Artifact：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626231426.png"></p>
<p>完整的配置请参考complex项目，这是一个非常简单的支持复数运算的库。</p>
<p>使用该Artifact时，因为GitHub的Package只能作为私有仓库使用，所以除了在使用方的pom.xml中声明<repository>外：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;project ...&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;repositories&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">            &lt;id&gt;github-release&lt;/id&gt;</span><br><span class="line">            &lt;name&gt;GitHub Release&lt;/name&gt;</span><br><span class="line">            &lt;url&gt;https:<span class="comment">//maven.pkg.github.com/michaelliao/complex&lt;/url&gt;</span></span><br><span class="line">        &lt;/repository&gt;</span><br><span class="line">    &lt;/repositories&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.itranswarp&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;complex&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.0</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<p>还需要把有读权限的Token配置到~&#x2F;.m2&#x2F;settings.xml文件中。</p>
<p>使用Maven发布一个Artifact时：</p>
<ul>
<li>可以发布到本地，然后推送到远程Git库，由静态服务器提供基于网页的repo服务，使用方必须声明repo地址；</li>
<li>可以发布到central.sonatype.org，并自动同步到Maven中央仓库，需要前期申请账号以及本地配置；</li>
<li>可以发布到GitHub Packages作为私有仓库使用，必须提供Token以及正确的权限才能发布和使用。</li>
</ul>
</br>
</br>]]></content>
      <categories>
        <category>专业知识</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 核心技术 - 异常处理机制</title>
    <url>/2023/04/04/cs-basic/cs-basic-language/cs-basic-language-java/Java%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%20-%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="一、异常分类"><a href="#一、异常分类" class="headerlink" title="一、异常分类"></a>一、异常分类</h2><p>Java 异常可以分为三类：受检查异常（checked exception）、运行时异常（runtime exception）和错误（error）。 </p>
<p>受检查异常是在编译时就需要处理的异常，如果没有处理会导致编译错误。例如，IOException、ClassNotFoundException 等。</p>
<p>运行时异常是指不需要在编译时处理的异常，它们通常表示程序逻辑错误或输入错误。例如，NullPointerException、ArrayIndexOutOfBoundsException 等。</p>
<p>错误通常是指无法恢复的严重问题，例如 VirtualMachineError、OutOfMemoryError 等。与异常不同，程序无法通过捕获和处理错误来进行恢复。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20230404131723.png"></p>
<h2 id="二、异常具体场景"><a href="#二、异常具体场景" class="headerlink" title="二、异常具体场景"></a>二、异常具体场景</h2><h3 id="2-1-ClassNotFoundException"><a href="#2-1-ClassNotFoundException" class="headerlink" title="2.1.ClassNotFoundException"></a>2.1.ClassNotFoundException</h3><p>ClassNotFoundException一般在Java程序中出现，表示无法找到指定类。以下是一个ClassNotFoundException的例子： </p>
<p>假设我们在Java代码中使用了一个类库，但是这个类库没有被正确地添加到项目的类路径中，那么当我们在代码中引用这个类时，就会抛出ClassNotFoundException异常，因为编译器和JVM无法找到这个缺失的类。</p>
<p>例如，在以下代码中，我们尝试使用一个名为”com.example.MyClass”的类，但是这个类并没有被正确地添加到类路径中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在运行该代码时，将会抛出ClassNotFoundException异常，因为无法找到指定的MyClass类。</p>
<h3 id="2-2-NullPointerException"><a href="#2-2-NullPointerException" class="headerlink" title="2.2.NullPointerException"></a>2.2.NullPointerException</h3><p>NullPointerException 是 Java 编程语言中的一个异常类型，通常在使用 null 值的对象或调用 null 值的方法时抛出。以下是一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str.length(); <span class="comment">// 这里会抛出 NullPointerException 异常，因为 str 变量的值为 null。</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，变量 str 被赋值为 null，而在下一行代码中我们试图调用它的 length() 方法。由于 str 变量的值为 null，它不指向任何对象，所以在尝试访问它的属性或方法时会抛出 NullPointerException 异常。</p>
<h3 id="2-3-ArrayIndexOutOfBoundsException"><a href="#2-3-ArrayIndexOutOfBoundsException" class="headerlink" title="2.3.ArrayIndexOutOfBoundsException"></a>2.3.ArrayIndexOutOfBoundsException</h3><p>当我们尝试访问数组中不存在的索引位置时，就会抛出 ArrayIndexOutOfBoundsException 异常。 </p>
<p>例如，如果我们定义了一个长度为5的数组，并且尝试访问第6个元素，就会抛出此异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]; System.out.println(array[<span class="number">5</span>]);  <span class="comment">// 抛出 ArrayIndexOutOfBoundsException</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-OutOfMemoryError"><a href="#2-4-OutOfMemoryError" class="headerlink" title="2.4.OutOfMemoryError"></a>2.4.OutOfMemoryError</h3><p>OutOfMemoryError一般在Java程序中出现，表示JVM中没有足够的内存来分配新的对象。以下是一个OutOfMemoryError的例子： </p>
<p>假设我们编写了一个Java应用程序，该程序需要处理大量的数据，并将这些数据存储在内存中。如果我们没有正确地管理内存，或者数据量过大，那么就可能会导致JVM耗尽内存并抛出OutOfMemoryError异常。</p>
<p>例如，以下代码试图创建一个非常大的整数数组，超过了JVM所能容纳的内存限制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[Integer.MAX_VALUE]; </span><br></pre></td></tr></table></figure>
<p>在运行该代码时，将会抛出OutOfMemoryError异常，因为JVM无法分配足够的内存以创建如此大的数组。</p>
<h3 id="2-5-VirtualMachineError"><a href="#2-5-VirtualMachineError" class="headerlink" title="2.5.VirtualMachineError"></a>2.5.VirtualMachineError</h3><p>VirtualMachineError是Java虚拟机（JVM）抛出的一种错误，表示JVM出现了内部错误。以下是一个可能导致VirtualMachineError的例子： </p>
<p>在运行时不断创建新线程并不停地加载类，这可能会导致JVM内存不足而抛出OutOfMemoryError或StackOverflowError，进而引发VirtualMachineError。</p>
<h2 id="三、异常捕获"><a href="#三、异常捕获" class="headerlink" title="三、异常捕获"></a>三、异常捕获</h2><p>在Java中，异常可以使用try-catch语句进行捕获和处理。try块包含可能会抛出异常的代码，如果发生异常，则在try块中立即跳转到相应的catch块进行处理。 以下是一个简单的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能会抛出异常的代码</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>; <span class="comment">// 这里会抛出ArithmeticException异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">    <span class="comment">// 异常处理代码</span></span><br><span class="line">    System.out.println(<span class="string">&quot;发生了算术异常：&quot;</span> + e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，try块中的代码尝试将10除以0，这会导致ArithmeticException异常被抛出。该异常将由catch块捕获，然后打印一条错误消息。注意，catch块中的参数类型必须与try块中抛出的异常类型匹配。</p>
<p>除了try-catch语句之外，Java还提供了finally子句，它可以在try块执行结束后无论是否有异常都执行一些清理操作，例如关闭文件或释放资源。以下是一个带有finally子句的完整示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能会抛出异常的代码</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 处理文件...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    <span class="comment">// 文件未找到异常处理代码</span></span><br><span class="line">    System.out.println(<span class="string">&quot;文件未找到：&quot;</span> + e.getMessage());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 清理代码</span></span><br><span class="line">    <span class="keyword">if</span> (file != <span class="literal">null</span>) &#123;</span><br><span class="line">        file.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，try块中打开了一个文件输入流，并进行处理。如果发生FileNotFoundException异常，则由catch块捕获并打印错误消息。无论是否有异常，finally子句都会尝试关闭文件输入流，以确保资源得到释放。</p>
]]></content>
      <categories>
        <category>专业知识</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 核心技术 - 日志</title>
    <url>/2022/03/10/cs-basic/cs-basic-language/cs-basic-language-java/Java%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%20-%20%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>刚学习 Java 的时候我们都是用 <code>System.out.println()</code> 来打印我们的输出结果，但是在实际工作中除了单元测试几乎不会使用这种输出方式。</p>
<p>这是为什么呢？</p>
<p>这主要是因为 <code>System.out.println()</code> 会将内容打印到控制台，线上会打印到 tomcat 控制台，这样：</p>
<ol>
<li>严重影响程序性能</li>
<li>不方便后续排查问题的时候查看和使用</li>
</ol>
<p>那生产环境怎么查看程序运行和异常信息呢？</p>
<p>答案就是：Log</p>
<p>线上主要使用log4j2或者logback这些第三方库的异步方法，进行日志的统一收集。</p>
<p>输出日志，而不是用System.out.println()，有以下几个好处</p>
<ol>
<li>可以设置输出样式，避免自己每次都写”ERROR: “ + var；</li>
<li>可以设置输出级别，禁止某些级别输出。例如，只输出错误日志；</li>
<li>可以被重定向到文件，这样可以在程序运行结束后查看日志；</li>
<li>可以按包名控制日志级别，只输出某些包打的日志；</li>
<li>可以……</li>
</ol>
<p>那如何使用日志？下面我们就来逐一进行介绍。</p>
<h2 id="Commons-Logging"><a href="#Commons-Logging" class="headerlink" title="Commons Logging"></a>Commons Logging</h2><p>Commons Logging是一个第三方日志库，它是由Apache创建的日志模块。</p>
<p>Commons Logging的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，Commons Loggin自动搜索并使用Log4j（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Logging。</p>
<p>使用Commons Logging只需要和两个类打交道，并且只有两步：</p>
<p>第一步，通过LogFactory获取Log类的实例； 第二步，使用Log实例的方法打日志。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Log</span> <span class="variable">log</span> <span class="operator">=</span> LogFactory.getLog(Main.class);</span><br><span class="line">        log.info(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;end.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码，肯定会得到编译错误，类似error: package org.apache.commons.logging does not exist（找不到org.apache.commons.logging这个包）。</p>
<p>可以在pom里配置下，比如</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h2><p>前面介绍了Commons Logging，可以作为“日志接口”来使用。而真正的“日志实现”可以使用Log4j。</p>
<p>Log4j是一种非常流行的日志框架。</p>
<p>Log4j是一个组件化设计的日志系统，它的架构大致如下：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626230938.png"></p>
<p>当我们使用Log4j输出一条日志时，Log4j自动通过不同的Appender把同一条日志输出到不同的目的地。例如：</p>
<p>console：输出到屏幕；<br>file：输出到文件；<br>socket：通过网络输出到远程计算机；<br>jdbc：输出到数据库<br>在输出日志的过程中，通过Filter来过滤哪些log需要被输出，哪些log不需要被输出。例如，仅输出ERROR级别的日志。</p>
<p>最后，通过Layout来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。</p>
<p>上述结构虽然复杂，但我们在实际使用的时候，并不需要关心Log4j的API，而是通过配置文件来配置它。</p>
<p>以XML配置为例，使用Log4j的时候，我们把一个log4j2.xml的文件放到classpath下就可以让Log4j读取配置文件并按照我们的配置来输出日志。下面是一个配置文件的例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义日志格式 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;log.pattern&quot;</span>&gt;</span>%d&#123;MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125;%n%msg%n%n<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义文件名变量 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;file.err.filename&quot;</span>&gt;</span>log/err.log<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;file.err.pattern&quot;</span>&gt;</span>log/err.%i.log.gz<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义Appender，即目的地 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义输出到屏幕 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">&quot;console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志格式引用上面定义的log.pattern --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;err&quot;</span> <span class="attr">bufferedIO</span>=<span class="string">&quot;true&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;file.err.filename&#125;&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;file.err.pattern&#125;&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 根据文件大小自动切割日志 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;1 MB&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 保留最近10份 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 对info级别的日志，输出到console --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;err&quot;</span> <span class="attr">level</span>=<span class="string">&quot;error&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>虽然配置Log4j比较繁琐，但一旦配置完成，使用起来就非常方便。对上面的配置文件，凡是INFO级别的日志，会自动输出到屏幕，而ERROR级别的日志，不但会输出到屏幕，还会同时输出到文件。并且，一旦日志文件达到指定大小（1MB），Log4j就会自动切割新的日志文件，并最多保留10份。</p>
<p>同样 Log4j 也需要在pom里配置下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.17.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.17.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-jcl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.17.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="SLF4J和Logback"><a href="#SLF4J和Logback" class="headerlink" title="SLF4J和Logback"></a>SLF4J和Logback</h2><p>前面介绍了Commons Logging和Log4j这一对好基友，它们一个负责充当日志API，一个负责实现日志底层，搭配使用非常便于开发。</p>
<p>有的童鞋可能还听说过SLF4J和Logback。这两个东东看上去也像日志，它们又是啥？</p>
<p>其实SLF4J类似于Commons Logging，也是一个日志接口，而Logback类似于Log4j，是一个日志的实现。</p>
<p>为什么有了Commons Logging和Log4j，又会蹦出来SLF4J和Logback？这是因为Java有着非常悠久的开源历史，不但OpenJDK本身是开源的，而且我们用到的第三方库，几乎全部都是开源的。开源生态丰富的一个特定就是，同一个功能，可以找到若干种互相竞争的开源库。</p>
<p>因为对Commons Logging的接口不满意，有人就搞了SLF4J。因为对Log4j的性能不满意，有人就搞了Logback。</p>
<p>我们先来看看SLF4J对Commons Logging的接口有何改进。在Commons Logging中，我们要打印日志，有时候得这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">p.setScore(score);</span><br><span class="line">log.info(<span class="string">&quot;Set score &quot;</span> + score + <span class="string">&quot; for Person &quot;</span> + p.getName() + <span class="string">&quot; ok.&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>拼字符串是一个非常麻烦的事情，所以SLF4J的日志接口改进成这样了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">p.setScore(score);</span><br><span class="line">logger.info(<span class="string">&quot;Set score &#123;&#125; for Person &#123;&#125; ok.&quot;</span>, score, p.getName());</span><br></pre></td></tr></table></figure>

<p>SLF4J的日志接口传入的是一个带占位符的字符串，用后面的变量自动替换占位符，所以看起来更加自然。</p>
<p>如何使用SLF4J？它的接口实际上和Commons Logging几乎一模一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样需要在pom里配置一下要使用的包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0-alpha6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0-alpha14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0-alpha14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>和Log4j类似，我们仍然需要一个Logback的配置文件，把logback.xml放到classpath下，配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">file</span>&gt;</span>log/output.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>log/output.log.%i<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">MaxFileSize</span>&gt;</span>1MB<span class="tag">&lt;/<span class="name">MaxFileSize</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>首先贴一下我的代码</p>
<p>DateTimeUtils.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.haxianhe.utils;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> haxianhe haxianhe@gmail.com</span></span><br><span class="line"><span class="comment"> * Created on 2022-02-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateTimeUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(DateTimeUtils.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DateTimeFormatter</span> <span class="variable">FORMATTER_TIME</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  当前的时间，HH:mm:ss</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">currentTime</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;调用方法: &#123;&#125;&quot;</span>, <span class="string">&quot;currentTime&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> LocalTime.now().format(FORMATTER_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>DateUtilsTest.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test.com.haxianhe.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.haxianhe.utils.DateTimeUtils;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> haxianhe &lt;haxianhe@gmail.com&gt;</span></span><br><span class="line"><span class="comment"> * Created on 2022-02-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateUtilsTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDayOfWeekTest</span><span class="params">()</span> &#123;</span><br><span class="line">        DateTimeUtils.currentTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>程序运行后在log里打印的内容如下</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626231005.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264738932870688">使用Commons Logging</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264739436350112">使用Log4j</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264739155914176">使用SLF4J和Logback</a></li>
</ul>
<br>
<br>]]></content>
      <categories>
        <category>专业知识</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 核心技术 - 集合</title>
    <url>/2021/09/12/cs-basic/cs-basic-language/cs-basic-language-java/Java%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%20-%20%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>Java标准库自带的java.util包提供了集合类：Collection，它是除Map外所有其他集合类的根接口。Java的java.util包主要提供了以下三种类型的集合：</p>
<ul>
<li>List：一种有序列表的集合，例如，按索引排列的Student的List；</li>
<li>Set：一种保证没有重复元素的集合，例如，所有无重复名称的Student的Set；</li>
<li>Map：一种通过键值（key-value）查找的映射表集合，例如，根据Student的name查找对应Student的Map。</li>
</ul>
<p>Java集合的设计有几个特点：一是实现了接口和实现类相分离，例如，有序表的接口是List，具体的实现类有ArrayList，LinkedList等，二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 只能放入String类型</span></span><br></pre></td></tr></table></figure>

<p>最后，Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。</p>
<p>由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p>
<ul>
<li>Hashtable：一种线程安全的Map实现；</li>
<li>Vector：一种线程安全的List实现；</li>
<li>Stack：基于Vector实现的LIFO的栈。</li>
</ul>
<p>还有一小部分接口是遗留接口，也不应该继续使用：</p>
<ul>
<li>Enumeration<E>：已被Iterator<E>取代。</li>
</ul>
<p>此外，关于集合具体怎么使用这里不准备展开讲了，用到的时候搜一下就好了。</p>
</br>
</br>]]></content>
      <categories>
        <category>专业知识</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>CGI、FastCGI和PHP-FPM关系解析</title>
    <url>/2019/11/09/cs-basic/cs-basic-language/cs-basic-language-php/CGI%E3%80%81FastCGI%E5%92%8CPHP-FPM%E5%85%B3%E7%B3%BB%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>在搭建 LAMP&#x2F;LNMP 服务器时，会经常遇到 PHP-FPM、FastCGI和CGI 这几个概念。如果对它们一知半解，很难搭建出高性能的服务器。接下来我们就以图形方式，解释这些概念之间的关系。</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>在整个网站架构中，Web Server（如Apache）只是内容的分发者。举个栗子，如果客户端请求的是 index.html，那么Web Server会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20191108104749.png"></p>
<p>如果请求的是 index.php，根据配置文件，Web Server知道这个不是静态文件，需要去找 PHP 解析器来处理，那么他会把这个请求简单处理，然后交给PHP解析器。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20191108104821.png"></p>
<p>当Web Server收到 index.php 这个请求后，会启动对应的 CGI 程序，这里就是PHP的解析器。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程，Web server再把结果返回给浏览器。这就是一个完整的动态PHP Web访问流程，接下来再引出这些概念，就好理解多了，</p>
<ul>
<li><strong>CGI</strong>：是 Web Server 与 Web Application 之间数据交换的一种协议。</li>
<li><strong>FastCGI</strong>：同 CGI，是一种通信协议，但比 CGI 在效率上做了一些优化。同样，SCGI 协议与 FastCGI 类似。</li>
<li><strong>PHP-CGI</strong>：是 PHP （Web Application）对 Web Server 提供的 CGI 协议的接口程序。</li>
<li><strong>PHP-FPM</strong>：是 PHP（Web Application）对 Web Server 提供的 FastCGI 协议的接口程序，额外还提供了相对智能一些任务管理。</li>
</ul>
<p>在Web中的一些概念：</p>
<ul>
<li>Web Server 一般指Apache、Nginx、IIS、Lighttpd、Tomcat等服务器，</li>
<li>Web Application 一般指PHP、Java、Asp.net等应用程序。</li>
</ul>
<h2 id="PHP-Module加载方式"><a href="#PHP-Module加载方式" class="headerlink" title="PHP Module加载方式"></a>PHP Module加载方式</h2><p>在了解 CGI 之前，我们先了解一下Web server 传递数据的另外一种方法：PHP Module加载方式。以 Apache 为例，在PHP Module方式中，是不是在 Apache 的配置文件 httpd.conf 中加上这样几句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 加入以下2句</span><br><span class="line">LoadModule php5_module D:/php/php5apache2_2.dll</span><br><span class="line">AddType application/x-httpd-php .php</span><br><span class="line"></span><br><span class="line"># 修改如下内容</span><br><span class="line">&lt;IfModule dir_module&gt;</span><br><span class="line">    DirectoryIndex index.php index.html</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>

<p>上面是 Windows 下安装php和apache环境后手动配置，在linux下源码安装大致是这样配置的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ./configure --with-mysql=/usr/local --with-apache=/usr/local/apache --enable-track-vars</span><br></pre></td></tr></table></figure>

<p>所以，这种方式，他们的共同本质都是用 LoadModule 来加载 php5_module，就是<strong>把php作为apache的一个子模块来运行</strong>。当通过web访问php文件时，apache就会调用php5_module来解析php代码。</p>
<p>那么php5_module是怎么来将数据传给php解析器来解析php代码的呢？答案是通过sapi。</p>
<p>我们再来看一张图，详细的说说apache 与 php 与 sapi的关系：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20191108105200.png"></p>
<p>从上面图中，我们看出了sapi就是这样的一个中间过程，SAPI提供了一个和外部通信的接口，有点类似于socket，使得PHP可以和其他应用进行交互数据（apache，nginx等）。php默认提供了很多种SAPI，常见的提供给apache和nginx的php5_module、CGI、FastCGI，给IIS的ISAPI，以及Shell的CLI。</p>
<p>所以，以上的apache调用php执行的过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apache -&gt; httpd -&gt; php5_module -&gt; sapi -&gt; php</span><br></pre></td></tr></table></figure>

<p>好了。apache与php通过php5_module的方式就搞清楚了吧！</p>
<p>这种模式将php模块安装到apache中，所以每一次apache结束请求，都会产生一条进程，这个进程就完整的包括php的各种运算计算等操作。</p>
<p>在上图中，我们很清晰的可以看到，apache每接收一个请求，都会产生一个进程来连接php通过sapi来完成请求，可想而知，如果一旦用户过多，并发数过多，服务器就会承受不住了。</p>
<p>而且，把mod_php编进apache时，出问题时很难定位是php的问题还是apache的问题。</p>
<h2 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h2><p><strong>CGI（Common Gateway Interface）全称是“通用网关接口”</strong>，WEB 服务器与PHP应用进行“交谈”的一种工具，其程序须运行在网络服务器上。CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php、perl、tcl等。</p>
<p>WEB服务器会传哪些数据给PHP解析器呢？<strong>URL、查询字符串、POST数据、HTTP header</strong>都会有。所以，CGI就是规定要传哪些数据，以什么样的格式传递给后方处理这个请求的协议。仔细想想，你在PHP代码中使用的用户从哪里来的。</p>
<p>也就是说，CGI就是专门用来和 web 服务器打交道的。web服务器收到用户请求，就会把请求提交给cgi程序（如php-cgi），cgi程序根据请求提交的参数作应处理（解析php），然后输出标准的html语句，返回给web服服务器，WEB服务器再返回给客户端，这就是普通cgi的工作原理。</p>
<p>CGI的好处就是完全独立于任何服务器，仅仅是做为中间分子。提供接口给apache和php。他们通过cgi搭线来完成数据传递。这样做的好处了尽量减少2个的关联，使他们2变得更独立。</p>
<p>但是CGI有个蛋疼的地方，就是每一次web请求都会有启动和退出过程，也就是最为人诟病的fork-and-execute模式，这样一在大规模并发下，就死翘翘了。</p>
<h2 id="FastCGI"><a href="#FastCGI" class="headerlink" title="FastCGI"></a>FastCGI</h2><h3 id="FastCGI介绍"><a href="#FastCGI介绍" class="headerlink" title="FastCGI介绍"></a>FastCGI介绍</h3><p>从根本上来说，FastCGI是用来提高CGI程序性能的。类似于CGI，<strong>FastCGI也可以说是一种协议</strong>。</p>
<p>FastCGI像是一个<strong>常驻(long-live)型的CGI</strong>，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次。它还支持分布式的运算, 即 FastCGI 程序可以在网站服务器以外的主机上执行，并且接受来自其它网站服务器来的请求。</p>
<p>FastCGI是语言无关的、可伸缩架构的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中，并因此获得较高的性能。众所周知，CGI解释器的反复加载是CGI性能低下的主要原因，如果CGI解释器保持在内存中，并接受FastCGI进程管理器调度，则可以提供良好的性能、伸缩性、Fail- Over特性等等。</p>
<h3 id="FastCGI的工作原理"><a href="#FastCGI的工作原理" class="headerlink" title="FastCGI的工作原理"></a>FastCGI的工作原理</h3><p>FastCGI接口方式采用C&#x2F;S结构，可以将HTTP服务器和脚本解析服务器分开，同时在脚本解析服务器上启动一个或者多个脚本解析守护进程。当HTTP服务器每次遇到动态程序时，可以将其直接交付给FastCGI进程来执行，然后将得到的结果返回给浏览器。这种方式可以让HTTP服务器专一地处理静态请求，或者将动态脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20191108105451.png"></p>
<ol>
<li>Web Server启动时载入FastCGI进程管理器（Apache Module或IIS ISAPI等)</li>
<li>FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可建多个php-cgi)，并等待来自Web Server的连接。<br>当客户端请求到达Web </li>
<li>Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。</li>
<li>FastCGI子进程完成处理后，将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待，并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。 在CGI模式中，php-cgi在此便退出了。</li>
</ol>
<p>FastCGI与CGI特点：</p>
<ul>
<li>FastCGI，所有这些都只在进程启动时发生一次。一个额外的好处是，持续数据库连接(Persistent database connection)可以工作。</li>
<li>由于FastCGI是多进程，所以比CGI多线程消耗更多的服务器内存，php-cgi解释器每进程消耗7至25兆内存，将这个数字乘以50或100就是很大的内存数。</li>
</ul>
<h2 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM"></a>PHP-FPM</h2><p>要了解PHP-FPM，就得先说说PHP-CGI。</p>
<p><strong>PHP-CGI</strong>是 PHP （Web Application）对 Web Server 提供的 CGI 协议的接口程序。虽然是php官方出品，但是这丫的却一点也不给力，性能太差，而且也很麻烦不人性化，主要体现在：</p>
<ol>
<li>php-cgi变更php.ini配置后，需重启php-cgi才能让新的php-ini生效，不可以平滑重启。</li>
<li>直接杀死php-cgi进程，php就不能运行了。</li>
</ol>
<p>上面2个问题，一直让很多人病垢了很久，所以很多人一直还是在用 Module 方式。 直到 2004年一个叫 Andrei Nigmatulin的屌丝发明了PHP-FPM ，这神器的出现就彻底打破了这种局面，这是一个PHP专用的 fastcgi 管理器，它很爽的克服了上面2个问题，而且，还表现在其他方面更表现强劲。</p>
<p>也就是说，PHP-FPM 是对于 FastCGI 协议的具体实现，他负责管理一个进程池，来处理来自Web服务器的请求。<strong>目前，PHP5.3版本之后，PHP-FPM是内置于PHP的</strong>。</p>
<p>因为PHP-CGI只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理。所以就出现了一些能够调度 php-cgi 进程的程序，比如说由lighthttpd分离出来的spawn-fcgi。同样，PHP-FPM也是用于调度管理PHP解析器php-cgi的管理程序。</p>
<p>PHP-FPM通过生成新的子进程可以实现php.ini修改后的平滑重启。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，我们来总结一下，这些技术经过不断的升级，可以解决什么问题（不然也不会升级嘛）。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20191108105958.png"></p>
<p>所以，如果要搭建一个高性能的PHP WEB服务器，目前最佳的方式是Apache&#x2F;Nginx + FastCGI + PHP-FPM(+PHP-CGI)方式了，不要再使用 Module加载或者 CGI 方式了。</p>
]]></content>
      <categories>
        <category>专业知识</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 核心技术 - 基础</title>
    <url>/2021/08/30/cs-basic/cs-basic-language/cs-basic-language-java/Java%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%20-%20%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626223449.png"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java最早是由SUN公司（已被Oracle收购）的詹姆斯·高斯林（高司令，人称Java之父）在上个世纪90年代初开发的一种编程语言，最初被命名为Oak，目标是针对小型家电设备的嵌入式应用，结果市场没啥反响。谁料到互联网的崛起，让Oak重新焕发了生机，于是SUN公司改造了Oak，在1995年以Java的名称正式发布，原因是Oak已经被人注册了，因此SUN注册了Java这个商标。随着互联网的高速发展，Java逐渐成为最重要的网络编程语言。</p>
<p>Java介于编译型语言和解释型语言之间。编译型语言如C、C++，代码是直接编译成机器码执行，但是不同的平台（x86、ARM等）CPU的指令集不同，因此，需要编译出每一种平台的对应机器码。解释型语言如Python、Ruby没有这个问题，可以由解释器直接加载源码然后运行，代价是运行效率太低。而Java是将代码编译成一种“字节码”，它类似于抽象的CPU指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果。当然，这是针对Java开发者而言。对于虚拟机，需要为每个平台分别开发。为了保证不同平台、不同公司开发的虚拟机都能正确执行Java字节码，SUN公司制定了一系列的Java虚拟机规范。从实践的角度看，JVM的兼容性做得非常好，低版本的Java字节码完全可以正常运行在高版本的JVM上。</p>
<p>随着Java的发展，SUN给Java又分出了三个不同版本：</p>
<ul>
<li>Java SE：Standard Edition</li>
<li></li>
<li>Java EE：Enterprise Edition</li>
<li></li>
<li>Java ME：Micro Edition</li>
</ul>
<p>这三者之间有啥关系呢？</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626223524.png"></p>
<p>简单来说，Java SE就是标准版，包含标准的JVM和标准库，而Java EE是企业版，它只是在Java SE的基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务等，Java EE的应用使用的虚拟机和Java SE完全相同。</p>
<p>Java ME就和Java SE不同，它是一个针对嵌入式设备的“瘦身版”，Java SE的标准库无法在Java ME上使用，Java ME的虚拟机也是“瘦身版”。</p>
<p>毫无疑问，Java SE是整个Java平台的核心，而Java EE是进一步学习Web应用所必须的。我们熟悉的Spring等框架都是Java EE开源生态系统的一部分。不幸的是，Java ME从来没有真正流行起来，反而是Android开发成为了移动平台的标准之一，因此，没有特殊需求，不建议学习Java ME。</p>
<p>因此我们推荐的Java学习路线图如下：</p>
<ol>
<li><p>首先要学习Java SE，掌握Java语言本身、Java核心开发技术以及Java标准库的使用；</p>
</li>
<li><p>如果继续学习Java EE，那么Spring框架、数据库开发、分布式架构就是需要学习的；</p>
</li>
<li><p>如果要学习大数据开发，那么Hadoop、Spark、Flink这些大数据平台就是需要学习的，他们都基于Java或Scala开发；</p>
</li>
<li><p>如果想要学习移动开发，那么就深入Android平台，掌握Android App开发。</p>
</li>
</ol>
<p>无论怎么选择，Java SE的核心技术是基础，这个教程的目的就是让你完全精通Java SE！</p>
<h3 id="Java版本"><a href="#Java版本" class="headerlink" title="Java版本"></a>Java版本</h3><p>从1995年发布1.0版本开始，到目前为止，最新的Java版本是Java 15：</p>
<ul>
<li>时间	版本</li>
<li>1995	1.0</li>
<li>1998	1.2</li>
<li>2000	1.3</li>
<li>2002	1.4</li>
<li>2004	1.5 &#x2F; 5.0</li>
<li>2005	1.6 &#x2F; 6.0</li>
<li>2011	1.7 &#x2F; 7.0</li>
<li>2014	1.8 &#x2F; 8.0</li>
<li>2017&#x2F;9	1.9 &#x2F; 9.0</li>
<li>2018&#x2F;3	10</li>
<li>2018&#x2F;9	11</li>
<li>2019&#x2F;3	12</li>
<li>2019&#x2F;9	13</li>
<li>2020&#x2F;3	14</li>
<li>2020&#x2F;9	15</li>
<li>2021&#x2F;3	16</li>
</ul>
<p>Java 8 和 Java 11 现在业界用的比较多。</p>
<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>初学者学Java，经常听到JDK、JRE这些名词，它们到底是啥？</p>
<ul>
<li>JDK：Java Development Kit</li>
<li>JRE：Java Runtime Environment</li>
</ul>
<p>简单地说，JRE就是运行Java字节码的虚拟机。但是，如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了包含JRE，还提供了编译器、调试器等开发工具。</p>
<p>二者关系如下：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626223551.png"></p>
<p>要学习Java开发，当然需要安装JDK了。</p>
<p>那JSR、JCP……又是啥？</p>
<ul>
<li>JSR规范：Java Specification Request</li>
<li>JCP组织：Java Community Process</li>
</ul>
<p>为了保证Java语言的规范性，SUN公司搞了一个JSR规范，凡是想给Java平台加一个功能，比如说访问数据库的功能，大家要先创建一个JSR规范，定义好接口，这样，各个数据库厂商都按照规范写出Java驱动程序，开发者就不用担心自己写的数据库代码在MySQL上能跑，却不能跑在PostgreSQL上。</p>
<p>所以JSR是一系列的规范，从JVM的内存模型到Web程序接口，全部都标准化了。而负责审核JSR的组织就是JCP。</p>
<p>一个JSR规范发布时，为了让大家有个参考，还要同时发布一个“参考实现”，以及一个“兼容性测试套件”：</p>
<ul>
<li>RI：Reference Implementation</li>
<li>TCK：Technology Compatibility Kit</li>
</ul>
<p>比如有人提议要搞一个基于Java开发的消息服务器，这个提议很好啊，但是光有提议还不行，得贴出真正能跑的代码，这就是RI。如果有其他人也想开发这样一个消息服务器，如何保证这些消息服务器对开发者来说接口、功能都是相同的？所以还得提供TCK。</p>
<p>通常来说，RI只是一个“能跑”的正确的代码，它不追求速度，所以，如果真正要选择一个Java的消息服务器，一般是没人用RI的，大家都会选择一个有竞争力的商用或开源产品。</p>
<p>参考：Java消息服务JMS的JSR：<a href="https://jcp.org/en/jsr/detail?id=914">https://jcp.org/en/jsr/detail?id=914</a></p>
<blockquote>
<p>Java 入门的内容都烂大街了，随便一本书里都有，这里就不浪费时间了。</p>
<p>这里我想说一下关于软件安装、环境配置、资料搜索的问题。我大学的时候就沉迷于这三件事情，浪费了许多珍贵的时间，我只想说你要时刻牢记你的目标是什么，不要在那里感动自己。这句话也送给我自己。</p>
</blockquote>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626223945.png"></p>
<p>Java是一种面向对象的编程语言。面向对象编程，英文是Object-Oriented Programming，简称OOP。</p>
<p>那什么是面向对象编程？</p>
<p>和面向对象编程不同的，是面向过程编程。面向过程编程，是把模型分解成一步一步的过程。比如，老板告诉你，要编写一个TODO任务，必须按照以下步骤一步一步来：</p>
<ul>
<li>读取文件；</li>
<li>编写TODO；</li>
<li>保存文件。</li>
</ul>
<p>而面向对象编程，顾名思义，你得首先有个对象：</p>
<p>有了对象后，就可以和对象进行互动：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">GirlFriend</span> <span class="variable">gf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GirlFriend</span>();</span><br><span class="line">gf.name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">gf.send(<span class="string">&quot;flowers&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>因此，面向对象编程，是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。</p>
<p>在本章中，我们将讨论：</p>
<p>面向对象的基本概念，包括：</p>
<ul>
<li>类</li>
<li>实例</li>
<li>方法</li>
</ul>
<p>面向对象的实现方式，包括：</p>
<ul>
<li>继承</li>
<li>多态</li>
</ul>
<p>Java语言本身提供的机制，包括：</p>
<ul>
<li>package</li>
<li>classpath</li>
<li>jar</li>
</ul>
<p>以及Java标准库提供的核心类，包括：</p>
<ul>
<li>字符串</li>
<li>包装类型</li>
<li>JavaBean</li>
<li>枚举</li>
<li>常用工具类</li>
</ul>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>在计算机程序运行的过程中，总是会出现各种各样的错误。</p>
<p>有一些错误是用户造成的，比如，希望用户输入一个int类型的年龄，但是用户的输入是abc：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设用户输入了abc：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(s); <span class="comment">// NumberFormatException!</span></span><br></pre></td></tr></table></figure>

<p>程序想要读写某个文件的内容，但是用户已经把它删除了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用户删除了该文件：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> readFile(<span class="string">&quot;C:\\abc.txt&quot;</span>); <span class="comment">// FileNotFoundException!</span></span><br></pre></td></tr></table></figure>

<p>还有一些错误是随机出现，并且永远不可能避免的。比如：</p>
<ul>
<li>网络突然断了，连接不到远程服务器；</li>
<li>内存耗尽，程序崩溃了；</li>
<li>用户点“打印”，但根本没有打印机；</li>
<li>……</li>
</ul>
<p>所以，一个健壮的程序必须处理各种各样的错误。</p>
<p>所谓错误，就是程序调用某个函数的时候，如果失败了，就表示出错。</p>
<p>调用方如何获知调用失败的信息？有两种方法：</p>
<p>方法一：约定返回错误码。</p>
<p>例如，处理一个文件，如果返回0，表示成功，返回其他整数，表示约定的错误码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> processFile(<span class="string">&quot;C:\\test.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (code == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// ok:</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// error:</span></span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// file not found:</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="comment">// no read permission:</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// unknown error:</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为使用int类型的错误码，想要处理就非常麻烦。这种方式常见于底层C函数。</p>
<p>方法二：在语言层面上提供一个异常处理机制。</p>
<p>Java内置了一套异常处理机制，总是使用异常来表示错误。</p>
<p>异常是一种class，因此它本身带有类型信息。异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> processFile(“C:\\test.txt”);</span><br><span class="line">    <span class="comment">// ok:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    <span class="comment">// file not found:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">    <span class="comment">// no read permission:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// io error:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// other error:</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为Java的异常是class，它的继承关系如下：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626225430.png"></p>
<p>从继承关系可知：Throwable是异常体系的根，它继承自Object。Throwable有两个体系：Error和Exception，Error表示严重的错误，程序对此一般无能为力，例如：</p>
<ul>
<li>OutOfMemoryError：内存耗尽</li>
<li>NoClassDefFoundError：无法加载某个Class</li>
<li>StackOverflowError：栈溢出</li>
</ul>
<p>而Exception则是运行时的错误，它可以被捕获并处理。</p>
<p>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：</p>
<ul>
<li>NumberFormatException：数值类型的格式错误</li>
<li>FileNotFoundException：未找到文件</li>
<li>SocketException：读取网络失败</li>
</ul>
<p>还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：</p>
<ul>
<li>NullPointerException：对某个null的对象调用方法或字段</li>
<li>IndexOutOfBoundsException：数组索引越界</li>
</ul>
<p>Exception又分为两大类：</p>
<ol>
<li>RuntimeException以及它的子类；</li>
<li>非RuntimeException（包括IOException、ReflectiveOperationException等等）</li>
</ol>
<p>Java规定：</p>
<p>必须捕获的异常，包括Exception及其子类，但不包括RuntimeException及其子类，这种类型的异常称为Checked Exception。</p>
<p>不需要捕获的异常，包括Error及其子类，RuntimeException及其子类。</p>
<blockquote>
<p>注意：编译器对RuntimeException及其子类不做强制捕获要求，不是指应用程序本身不应该捕获并处理RuntimeException。是否需要捕获，具体问题具体分析。</p>
</blockquote>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>捕获异常使用try…catch语句，把可能发生异常的代码放到try {…}中，然后使用catch捕获对应的Exception及其子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// try...catch</span></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="comment">// 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException:</span></span><br><span class="line">            System.out.println(e); <span class="comment">// 打印异常信息</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(); <span class="comment">// 尝试使用用默认编码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果我们不捕获UnsupportedEncodingException，会出现编译失败的问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// try...catch</span></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会报错，错误信息类似：unreported exception UnsupportedEncodingException; must be caught or declared to be thrown，并且准确地指出需要捕获的语句是return s.getBytes(“GBK”);。意思是说，像UnsupportedEncodingException这样的Checked Exception，必须被捕获。</p>
<p>这是因为String.getBytes(String)方法定义是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] getBytes(String charsetName) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在方法定义的时候，使用throws Xxx表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。</p>
<p>在toGBK()方法中，因为调用了String.getBytes(String)方法，就必须捕获UnsupportedEncodingException。我们也可以不捕获它，而是在方法定义处用throws表示toGBK()方法可能会抛出UnsupportedEncodingException，就可以让toGBK()方法通过编译器检查：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// try...catch</span></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码仍然会得到编译错误，但这一次，编译器提示的不是调用return s.getBytes(“GBK”);的问题，而是byte[] bs &#x3D; toGBK(“中文”);。因为在main()方法中，调用toGBK()，没有捕获它声明的可能抛出的UnsupportedEncodingException。</p>
<p>修复方法是在main()方法中捕获异常并处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// try...catch</span></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">            System.out.println(Arrays.toString(bs));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，只要是方法声明的Checked Exception，不在调用层捕获，也必须在更高的调用层捕获。所有未捕获的异常，最终也必须在main()方法中捕获，不会出现漏写try的情况。这是由编译器保证的。main()方法也是最后捕获Exception的机会。</p>
<p>如果是测试代码，上面的写法就略显麻烦。如果不想写任何try代码，可以直接把main()方法定义为throws Exception：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// try...catch</span></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为main()方法声明了可能抛出Exception，也就声明了可能抛出所有的Exception，因此在内部就无需捕获了。代价就是一旦发生异常，程序会立刻退出。</p>
<p>还有一些童鞋喜欢在toGBK()内部“消化”异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="comment">// 什么也不干</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">这种捕获后不处理的方式是非常不好的，即使真的什么也做不了，也要先把异常记录下来：</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="comment">// 先记下来再说:</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有异常都可以调用printStackTrace()方法打印异常栈，这是一个简单有用的快速打印异常的方法。</p>
<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个try … catch被捕获为止：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process1</span><span class="params">()</span> &#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process2</span><span class="params">()</span> &#123;</span><br><span class="line">        Integer.parseInt(<span class="literal">null</span>); <span class="comment">// 会抛出NumberFormatException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NullPointerException"><a href="#NullPointerException" class="headerlink" title="NullPointerException"></a>NullPointerException</h3><p>在所有的RuntimeException异常中，Java程序员最熟悉的恐怕就是NullPointerException了。</p>
<p>NullPointerException即空指针异常，俗称NPE。如果一个对象为null，调用其方法或访问其字段就会产生NullPointerException，这个异常通常是由JVM抛出的，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(s.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果遇到NullPointerException，我们应该如何处理？首先，必须明确，NullPointerException是一种代码逻辑错误，遇到NullPointerException，遵循原则是早暴露，早修复，严禁使用catch来隐藏这种编码错误。</p>
<blockquote>
<p>Java使用异常来表示错误，并通过try … catch捕获异常；</p>
<p>Java的异常是class，并且从Throwable继承；</p>
<p>Error是无需捕获的严重错误，Exception是应该捕获的可处理的错误；</p>
<p>RuntimeException无需强制捕获，非RuntimeException（Checked Exception）需强制捕获，或者用throws声明；</p>
<p>不推荐捕获了异常但不进行任何处理。</p>
</blockquote>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626225454.png"></p>
<h3 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h3><p>反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息。</p>
<p>正常情况下，如果我们要调用一个对象的方法，或者访问一个对象的字段，通常会传入对象实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">import</span> com.itranswarp.learnjava.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    String <span class="title function_">getFullName</span><span class="params">(Person p)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p.getFirstName() + <span class="string">&quot; &quot;</span> + p.getLastName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，如果不能获得Person类，只有一个Object实例，比如这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getFullName</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>怎么办？有童鞋会说：强制转型啊！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getFullName</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">    <span class="keyword">return</span> p.getFirstName() + <span class="string">&quot; &quot;</span> + p.getLastName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>强制转型的时候，你会发现一个问题：编译上面的代码，仍然需要引用Person类。不然，去掉import语句，你看能不能编译通过？</p>
<p>所以，反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。</p>
<h3 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h3><p>除了int等基本类型外，Java的其他类型全部都是class（包括interface）。例如：</p>
<ul>
<li>String</li>
<li>Object</li>
<li>Runnable</li>
<li>Exception</li>
<li>…</li>
</ul>
<p>仔细思考，我们可以得出结论：class（包括interface）的本质是数据类型（Type）。无继承关系的数据类型无法赋值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Number</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">123.456</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">123.456</span>); <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure>

<p>而class是由JVM在执行过程中动态加载的。JVM在第一次读取到一种class类型时，将其加载进内存。</p>
<p>每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来。注意：这里的Class类型是一个名叫Class的class。它长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Class</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Class</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以String类为例，当JVM加载String类时，它首先读取String.class文件到内存，然后，为String类创建一个Class实例并关联起来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Class</span>(String);</span><br></pre></td></tr></table></figure>

<p>这个Class实例是JVM内部创建的，如果我们查看JDK源码，可以发现Class类的构造方法是private，只有JVM能创建Class实例，我们自己的Java程序是无法创建Class实例的。</p>
<p>所以，JVM持有的每个Class实例都指向一个数据类型（class或interface）：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626225515.png"></p>
<p>一个Class实例包含了该class的所有完整信息：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626225533.png"></p>
<p>由于JVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息。</p>
<p>这种通过Class实例获取class信息的方法称为反射（Reflection）。</p>
<p>如何获取一个class的Class实例？有三个方法：</p>
<p>方法一：直接通过一个class的静态变量class获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> String.class;</span><br></pre></td></tr></table></figure>

<p>方法二：如果我们有一个实例变量，可以通过该实例变量提供的getClass()方法获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> s.getClass();</span><br></pre></td></tr></table></figure>

<p>方法三：如果知道一个class的完整类名，可以通过静态方法Class.forName()获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>因为Class实例在JVM中是唯一的，所以，上述方法获取的Class实例是同一个实例。</p>
<h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><p>JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            create(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当执行Main.java时，由于用到了Main，因此，JVM首先会把Main.class加载到内存。然而，并不会加载Person.class，除非程序执行到create()方法，JVM发现需要加载Person类时，才会首次加载Person.class。如果没有执行create()方法，那么Person.class根本就不会被加载。</p>
<p>这就是JVM动态加载class的特性。</p>
<p>动态加载class的特性对于Java程序非常重要。利用JVM动态加载class的特性，我们才能在运行期根据条件加载不同的实现类。例如，Commons Logging总是优先使用Log4j，只有当Log4j不存在时，才使用JDK的logging。利用JVM动态加载特性，大致的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Commons Logging优先使用Log4j:</span></span><br><span class="line"><span class="type">LogFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (isClassPresent(<span class="string">&quot;org.apache.logging.log4j.Logger&quot;</span>)) &#123;</span><br><span class="line">    factory = createLog4j();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    factory = createJdkLog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isClassPresent</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是为什么我们只需要把Log4j的jar包放到classpath中，Commons Logging就会自动使用Log4j的原因。</p>
<h3 id="访问字段-调用方法"><a href="#访问字段-调用方法" class="headerlink" title="访问字段&#x2F;调用方法"></a>访问字段&#x2F;调用方法</h3><p>对任意的一个Object实例，只要我们获取了它的Class，就可以获取它的一切信息。</p>
<p>我们先看看如何通过Class实例获取字段信息。Class类提供了以下几个方法来获取字段：</p>
<ul>
<li>Field getField(name)：根据字段名获取某个public的field（包括父类）</li>
<li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</li>
<li>Field[] getFields()：获取所有public的field（包括父类）</li>
<li>Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）</li>
</ul>
<p>一个Field对象包含了一个字段的所有信息：</p>
<ul>
<li>getName()：返回字段名称，例如，”name”；</li>
<li>getType()：返回字段类型，也是一个Class实例，例如，String.class；</li>
<li>getModifiers()：返回字段的修饰符，它是一个int，不同的bit表示不同的含义。</li>
</ul>
<p>我们已经能通过Class实例获取所有Field对象，同样的，可以通过Class实例获取所有Method信息。Class类提供了以下几个方法来获取Method：</p>
<ul>
<li>Method getMethod(name, Class…)：获取某个public的Method（包括父类）</li>
<li>Method getDeclaredMethod(name, Class…)：获取当前类的某个Method（不包括父类）</li>
<li>Method[] getMethods()：获取所有public的Method（包括父类）</li>
<li>Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类）</li>
</ul>
<p>一个Method对象包含一个方法的所有信息：</p>
<ul>
<li>getName()：返回方法名称，例如：”getScore”；</li>
<li>getReturnType()：返回方法返回值类型，也是一个Class实例，例如：String.class；</li>
<li>getParameterTypes()：返回方法的参数类型，是一个Class数组，例如：{String.class, int.class}；</li>
<li>getModifiers()：返回方法的修饰符，它是一个int，不同的bit表示不同的含义。</li>
</ul>
<p>通过Class实例获取Constructor的方法如下：</p>
<ul>
<li>getConstructor(Class…)：获取某个public的Constructor；</li>
<li>getDeclaredConstructor(Class…)：获取某个Constructor；</li>
<li>getConstructors()：获取所有public的Constructor；</li>
<li>getDeclaredConstructors()：获取所有Constructor。</li>
</ul>
<p>注意Constructor总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。</p>
<p>调用非public的Constructor时，必须首先通过setAccessible(true)设置允许访问。setAccessible(true)可能会失败。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>我们来比较Java的class和interface的区别：</p>
<ul>
<li>可以实例化class（非abstract）；</li>
<li>不能实例化interface。</li>
</ul>
<p>所有interface类型的变量总是通过某个实例向上转型并赋值给接口类型变量的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CharSequence</span> <span class="variable">cs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure>

<p>有没有可能不编写实现类，直接在运行期创建某个interface的实例呢？</p>
<p>这是可能的，因为Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个interface的实例。</p>
<p>什么叫运行期动态创建？听起来好像很复杂。所谓动态代理，是和静态相对应的。我们来看静态代码怎么写：</p>
<p>定义接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">morning</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> <span class="keyword">implements</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">morning</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Good morning, &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建实例，转型为接口并调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloWorld</span>();</span><br><span class="line">hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这种方式就是我们通常编写代码的方式。</p>
<p>还有一种方式是动态代码，我们仍然先定义了接口Hello，但是我们并不去编写实现类，而是直接通过JDK提供的一个Proxy.newProxyInstance()创建了一个Hello接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。</p>
<p>一个最简单的动态代理实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(method);</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;morning&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Good morning, &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello) Proxy.newProxyInstance(</span><br><span class="line">            Hello.class.getClassLoader(), <span class="comment">// 传入ClassLoader</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Hello.class &#125;, <span class="comment">// 传入要实现的接口</span></span><br><span class="line">            handler); <span class="comment">// 传入处理调用方法的InvocationHandler</span></span><br><span class="line">        hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">morning</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在运行期动态创建一个interface实例的方法如下：</p>
<ol>
<li><p>定义一个InvocationHandler实例，它负责实现接口的方法调用；</p>
</li>
<li><p>通过Proxy.newProxyInstance()创建interface实例，它需要3个参数：</p>
<ol>
<li>使用的ClassLoader，通常就是接口类的ClassLoader；</li>
<li>需要实现的接口数组，至少需要传入一个接口进去；</li>
<li>用来处理接口方法调用的InvocationHandler实例。</li>
</ol>
</li>
<li><p>将返回的Object强制转型为接口。</p>
</li>
</ol>
<p>动态代理实际上是JVM在运行期动态创建class字节码并加载的过程，它并没有什么黑魔法，把上面的动态代理改写为静态实现类大概长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloDynamicProxy</span> <span class="keyword">implements</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    InvocationHandler handler;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloDynamicProxy</span><span class="params">(InvocationHandler handler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">morning</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        handler.invoke(</span><br><span class="line">           <span class="built_in">this</span>,</span><br><span class="line">           Hello.class.getMethod(<span class="string">&quot;morning&quot;</span>, String.class),</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; name &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实就是JVM帮我们自动编写了一个上述类（不需要源码，可以直接生成字节码），并不存在可以直接实例化接口的黑魔法。</p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626225600.png"></p>
<h3 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h3><ul>
<li>Annotation是JDK5.0引入的新技术</li>
<li>Annotation的作用：<ul>
<li>不是程序本身，可以对程序作出解释（这一点和注释没什么区别）</li>
<li>可以被其他程序（比如编译器）读取</li>
</ul>
</li>
<li>Annotation的格式<ul>
<li>注解是以“@注释名”在代码中存在的，还可以添加一些参数值，例如：@SuppressWarnings（value&#x3D;“unchecked”）</li>
</ul>
</li>
<li>Annotation在哪里使用？<ul>
<li>可以附加在package，class，method，field等上面，相当于给他们添加了额外的辅助信息。我们可以通过反射机制变成实现对这些元数据的访问。</li>
</ul>
</li>
</ul>
<h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h3><p>Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。</p>
<p>作用在代码的注解是</p>
<ul>
<li>@Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li>
<li>@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。</li>
<li>@SuppressWarnings - 指示编译器去忽略注解中声明的警告。</li>
</ul>
<p>作用在其他注解的注解(或者说 元注解)是:</p>
<ul>
<li>@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li>
<li>@Documented - 标记这些注解是否包含在用户文档中。</li>
<li>@Target - 标记这个注解应该是哪种 Java 成员。</li>
<li>@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li>
</ul>
<p>从 Java 7 开始，额外添加了 3 个注解:</p>
<ul>
<li>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li>
<li>@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。</li>
<li>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li>
</ul>
<h3 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h3><p>我们总结一下定义Annotation的步骤：</p>
<p>第一步，用@interface定义注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步，添加参数、默认值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把最常用的参数定义为value()，推荐所有参数都尽量设置默认值。</p>
<p>第三步，用元注解配置注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，必须设置@Target和@Retention，@Retention一般设置为RUNTIME，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写@Inherited和@Repeatable。</p>
<h3 id="处理注解"><a href="#处理注解" class="headerlink" title="处理注解"></a>处理注解</h3><p>Java的注解本身对代码逻辑没有任何影响。根据@Retention的配置：</p>
<ul>
<li>SOURCE类型的注解在编译期就被丢掉了；</li>
<li>CLASS类型的注解仅保存在class文件中，它们不会被加载进JVM；</li>
<li>RUNTIME类型的注解会被加载进JVM，并且在运行期可以被程序读取。</li>
</ul>
<p>如何使用注解完全由工具决定。SOURCE类型的注解主要由编译器使用，因此我们一般只使用，不编写。CLASS类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有RUNTIME类型的注解不但要使用，还经常需要编写。</p>
<p>因此，我们只讨论如何读取RUNTIME类型的注解。</p>
<p>因为注解定义后也是一种class，所有的注解都继承自java.lang.annotation.Annotation，因此，读取注解，需要使用反射API。</p>
<p>Java提供的使用反射API读取Annotation的方法包括：</p>
<p>判断某个注解是否存在于Class、Field、Method或Constructor：</p>
<ul>
<li>Class.isAnnotationPresent(Class)</li>
<li>Field.isAnnotationPresent(Class)</li>
<li>Method.isAnnotationPresent(Class)</li>
<li>Constructor.isAnnotationPresent(Class)</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断@Report是否存在于Person类:</span></span><br><span class="line">Person.class.isAnnotationPresent(Report.class);</span><br></pre></td></tr></table></figure>

<p>使用反射API读取Annotation：</p>
<ul>
<li>Class.getAnnotation(Class)</li>
<li>Field.getAnnotation(Class)</li>
<li>Method.getAnnotation(Class)</li>
<li>Constructor.getAnnotation(Class)</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取Person定义的@Report注解:</span></span><br><span class="line"><span class="type">Report</span> <span class="variable">report</span> <span class="operator">=</span> Person.class.getAnnotation(Report.class);</span><br><span class="line"><span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> report.type();</span><br><span class="line"><span class="type">String</span> <span class="variable">level</span> <span class="operator">=</span> report.level();</span><br></pre></td></tr></table></figure>

<p>使用反射API读取Annotation有两种方法。方法一是先判断Annotation是否存在，如果存在，就直接读取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Person.class;</span><br><span class="line"><span class="keyword">if</span> (cls.isAnnotationPresent(Report.class)) &#123;</span><br><span class="line">    <span class="type">Report</span> <span class="variable">report</span> <span class="operator">=</span> cls.getAnnotation(Report.class);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方法是直接读取Annotation，如果Annotation不存在，将返回null：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Person.class;</span><br><span class="line"><span class="type">Report</span> <span class="variable">report</span> <span class="operator">=</span> cls.getAnnotation(Report.class);</span><br><span class="line"><span class="keyword">if</span> (report != <span class="literal">null</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取方法、字段和构造方法的Annotation和Class类似。但要读取方法参数的Annotation就比较麻烦一点，因为方法参数本身可以看成一个数组，而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。例如，对于以下方法定义的注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(<span class="meta">@NotNull</span> <span class="meta">@Range(max=5)</span> String name, <span class="meta">@NotNull</span> String prefix)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要读取方法参数的注解，我们先用反射获取Method实例，然后读取方法参数的所有注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取Method实例:</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="comment">// 获取所有参数的Annotation:</span></span><br><span class="line">Annotation[][] annos = m.getParameterAnnotations();</span><br><span class="line"><span class="comment">// 第一个参数（索引为0）的所有Annotation:</span></span><br><span class="line">Annotation[] annosOfName = annos[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (Annotation anno : annosOfName) &#123;</span><br><span class="line">    <span class="keyword">if</span> (anno <span class="keyword">instanceof</span> Range) &#123; <span class="comment">// @Range注解</span></span><br><span class="line">        <span class="type">Range</span> <span class="variable">r</span> <span class="operator">=</span> (Range) anno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anno <span class="keyword">instanceof</span> NotNull) &#123; <span class="comment">// @NotNull注解</span></span><br><span class="line">        <span class="type">NotNull</span> <span class="variable">n</span> <span class="operator">=</span> (NotNull) anno;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h3><p>注解如何使用，完全由程序自己决定。例如，JUnit是一个测试框架，它会自动运行所有标记为@Test的方法。</p>
<p>我们来看一个@Range注解，我们希望用它来定义一个String字段的规则：字段长度满足@Range的参数定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Range &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">max</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在某个JavaBean中，我们可以使用该注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Range(min=1, max=20)</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Range(max=10)</span></span><br><span class="line">    <span class="keyword">public</span> String city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。这里，我们编写一个Person实例的检查方法，它可以检查Person实例的String字段长度是否满足@Range的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">check</span><span class="params">(Person person)</span> <span class="keyword">throws</span> IllegalArgumentException, ReflectiveOperationException &#123;</span><br><span class="line">    <span class="comment">// 遍历所有Field:</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : person.getClass().getFields()) &#123;</span><br><span class="line">        <span class="comment">// 获取Field定义的@Range:</span></span><br><span class="line">        <span class="type">Range</span> <span class="variable">range</span> <span class="operator">=</span> field.getAnnotation(Range.class);</span><br><span class="line">        <span class="comment">// 如果@Range存在:</span></span><br><span class="line">        <span class="keyword">if</span> (range != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取Field的值:</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> field.get(person);</span><br><span class="line">            <span class="comment">// 如果值是String:</span></span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) value;</span><br><span class="line">                <span class="comment">// 判断值是否满足@Range的min/max:</span></span><br><span class="line">                <span class="keyword">if</span> (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid field: &quot;</span> + field.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，我们通过@Range注解，配合check()方法，就可以完成Person实例的检查。注意检查逻辑完全是我们自己编写的，JVM不会自动给注解添加任何额外的逻辑。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20220626225628.png"></p>
<h3 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h3><ul>
<li>泛型就是编写模板代码来适应任意类型；</li>
<li>泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查；</li>
<li>注意泛型的继承关系：可以把ArrayList<Integer>向上转型为List<Integer>（T不能变！），但不能把ArrayList<Integer>向上转型为ArrayList<Number>（T不能变成父类）。</li>
</ul>
<p>泛型就是定义一种模板，例如ArrayList<T>，然后在代码中为用到的类创建对应的ArrayList&lt;类型&gt;：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<p>由编译器针对类型作检查：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">strList.add(<span class="string">&quot;hello&quot;</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> strList.get(<span class="number">0</span>); <span class="comment">// OK</span></span><br><span class="line">strList.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>)); <span class="comment">// compile error!</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> strList.get(<span class="number">0</span>); <span class="comment">// compile error!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样一来，既实现了编写一次，万能匹配，又通过编译器保证了类型安全：这就是泛型。</p>
<p><strong>向上转型</strong></p>
<p>在Java标准库中的ArrayList<T>实现了List<T>接口，它可以向上转型为List<T>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;T&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<p>即类型ArrayList<T>可以向上转型为List<T>。</p>
<p>要特别注意：不能把ArrayList<Integer>向上转型为ArrayList<Number>或List<Number>。</p>
<h3 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h3><p>使用泛型时，把泛型参数<T>替换为需要的class类型，例如：ArrayList<String>，ArrayList<Number>等；</p>
<p>可以省略编译器能自动推断出的类型，例如：List<String> list &#x3D; new ArrayList&lt;&gt;();；</p>
<p>不指定泛型参数类型时，编译器会给出警告，且只能将<T>视为Object类型；</p>
<p>可以在接口中定义泛型类型，实现此接口的类必须实现正确的泛型类型。</p>
<h3 id="编写泛型"><a href="#编写泛型" class="headerlink" title="编写泛型"></a>编写泛型</h3><p>编写泛型类比普通类要复杂。通常来说，泛型类一般用在集合类中，例如ArrayList<T>，我们很少需要编写泛型类。</p>
<p>如果我们确实需要编写一个泛型类，那么，应该如何编写它？</p>
<p>可以按照以下步骤来编写一个泛型类。</p>
<p>首先，按照某种类型，例如：String，来编写类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String first;</span><br><span class="line">    <span class="keyword">private</span> String last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(String first, String last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，，把特定类型String替换为T，并申明<T>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>编写泛型时，需要定义泛型类型<T>；</p>
</li>
<li><p>静态方法不能引用泛型类型<T>，必须定义其他类型（例如<K>）来实现静态泛型方法；</p>
</li>
<li><p>泛型可以同时定义多种类型，例如Map&lt;K, V&gt;。</p>
</li>
</ul>
<h3 id="擦拭法"><a href="#擦拭法" class="headerlink" title="擦拭法"></a>擦拭法</h3><p>泛型是一种类似”模板代码“的技术，不同语言的泛型实现方式不一定相同。</p>
<p>Java语言的泛型实现方式是擦拭法（Type Erasure）。</p>
<p>所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。</p>
<p>例如，我们编写了一个泛型类Pair<T>，这是编译器看到的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而虚拟机根本不知道泛型。这是虚拟机执行的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    <span class="keyword">private</span> Object last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(Object first, Object last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，Java使用擦拭法实现泛型，导致了：</p>
<ul>
<li>编译器把类型<T>视为Object；</li>
<li>编译器根据<T>实现安全的强制转型。</li>
</ul>
<p>使用泛型的时候，我们编写的代码也是编译器看到的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line"><span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> p.getLast();</span><br></pre></td></tr></table></figure>

<p>而虚拟机执行的代码并没有泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Pair</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> (String) p.getFirst();</span><br><span class="line"><span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> (String) p.getLast();</span><br></pre></td></tr></table></figure>

<p>所以，Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型T视为Object处理，但是，在需要转型的时候，编译器会根据T的类型自动为我们实行安全地强制转型。</p>
<p>了解了Java泛型的实现方式——擦拭法，我们就知道了Java泛型的局限,擦拭法决定了泛型<T>：</p>
<ul>
<li>不能是基本类型，例如：int；</li>
<li>不能获取带泛型类型的Class，例如：Pair<String>.class；</li>
<li>不能判断带泛型类型的类型，例如：x instanceof Pair<String>；</li>
<li>不能实例化T类型，例如：new T()。</li>
</ul>
<p>泛型方法要防止重复定义方法，例如：public boolean equals(T obj)；</p>
<p>子类可以获取父类的泛型类型<T>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.liaoxuefeng.com/">https://www.liaoxuefeng.com</a></li>
<li><a href="https://www.bilibili.com/video/BV1p4411P7V3?p=1">https://www.bilibili.com/video/BV1p4411P7V3?p=1</a></li>
</ul>
</br>
</br>]]></content>
      <categories>
        <category>专业知识</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP常见概念</title>
    <url>/2019/11/09/cs-basic/cs-basic-language/cs-basic-language-php/PHP%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC是一个<strong>设计模式</strong>，它强制性的使应用程序的<strong>输入</strong>、<strong>处理</strong>和<strong>输出</strong>分开。使用MVC应用程序被分成三个核心部件：<strong>模型</strong>（M）、<strong>视图</strong>（V）、<strong>控制器</strong>（C），它们各自处理自己的任务。</p>
<ul>
<li><p><strong>视图：视图是用户看到并与之交互的界面</strong>。对老式的Web应用程序来说，视图就是由HTML元素组成的界面，在新式的Web应用程序中，HTML依旧在视图中扮演着重要的角色，但一些新的技术已层出不穷，它们包括Adobe Flash和象XHTML，XML&#x2F;XSL，WML等一些标识语言和Web services。如何处理应用程序的界面变得越来越有挑战性。MVC一个大的好处是它能为你的应用程序处理很多不同的视图。在视图中其实没有真正的处理发生，不管这些数据是联机存储的还是一个雇员列表，作为视图来讲，它只是作为一种输出数据并允许用户操纵的方式。</p>
</li>
<li><p><strong>模型：模型表示企业数据和业务规则</strong>。在MVC的三个部件中，模型拥有最多的处理任务。例如它可能用象EJBs和ColdFusion Components这样的构件对象来处理数据库。被模型返回的数据是中立的，就是说模型与数据格式无关，这样一个模型能为多个视图提供数据。由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。</p>
</li>
<li><p><strong>控制器：控制器接受用户的输入并调用模型和视图去完成用户的需求</strong>。所以当单击Web页面中的超链接和发送HTML表单时，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后确定用哪个视图来显示模型处理返回的数据。</p>
</li>
</ul>
<p>现在我们总结MVC的处理过程，首先控制器接收用户的请求，并决定应该调用哪个模型来进行处理，然后模型用业务逻辑来处理用户的请求并返回数据，最后控制器用相应的视图格式化模型返回的数据，并通过表示层呈现给用户。</p>
<h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><p><strong>面向对象编程</strong>（Object Oriented Programming，OOP，面向对象程序设计）是一种计算机编程架构。OOP 的一条基本原则是，计算机程序是由单个能够起到子程序作用的单元或对象组合而成。OOP 达到了软件工程的三个主要目标：<strong>重用性、灵活性和扩展性</strong>。为了实现整体运算，每个对象都能够接收信息、处理数据和向其它对象发送信息。OOP 主要有以下的概念和组件：</p>
<ul>
<li><p><strong>组件</strong> － 数据和功能一起在运行着的计算机程序中形成的单元，组件在 OOP 计算机程序中是模块和结构化的基础。</p>
</li>
<li><p><strong>抽象性</strong> － 程序有能力忽略正在处理中信息的某些方面，即对信息主要方面关注的能力。</p>
</li>
<li><p><strong>封装性</strong> － 也叫做信息封装：确保组件不会以不可预期的方式改变其它组件的内部状态；只有在那些提供了内部状态改变方法的组件中，才可以访问其内部状态。每类组件都提供了一个与其它组件联系的接口，并规定了其它组件进行调用的方法。</p>
</li>
<li><p><strong>继承性</strong> － 允许在现存的组件基础上创建子类组件，这统一并增强了多态性和封装性。典型地来说就是用类来对组件进行分组，而且还可以定义新类为现存的类的扩展，这样就可以将类组织成树形或网状结构，这体现了动作的通用性。</p>
</li>
<li><p><strong>多态性</strong> － 组件的引用和类集会涉及到其它许多不同类型的组件，而且引用组件所产生的结果得依据实际调用的类型。</p>
</li>
</ul>
<p>由于抽象性、封装性、重用性以及便于使用等方面的原因，以组件为基础的编程在脚本语言中已经变得特别流行。</p>
<h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><p>对象-关系映射（Object&#x2F;Relation Mapping，简称ORM），是随着面向对象的软件开发方法发展而产生的。面向对象的开发方法是当今企业级应用开发环境中的主流开发方法，关系数据库是企业级应用环境中永久存放数据的主流数据存储系统。对象和关系数据是业务实体的两种表现形式，业务实体在内存中表现为对象，在数据库中表现为关系数据。内存中的对象之间存在关联和继承关系，而在数据库中，关系数据无法直接表达多对多关联和继承关系。因此，对象-关系映射(ORM)系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。</p>
<p>面向对象是从软件工程基本原则（如耦合、聚合、封装）的基础上发展起来的，而关系数据库则是从数学理论发展而来的，两套理论存在显著的区别。为了解决这个不匹配的现象,对象关系映射技术应运而生。</p>
<h2 id="CURD"><a href="#CURD" class="headerlink" title="CURD"></a>CURD</h2><p>CURD是一个数据库技术中的缩写词，一般的项目开发的各种参数的基本功能都是CURD。它代表创建（Create）、更新（Update）、读取（Read）和删除（Delete）操作。CURD 定义了用于处理数据的基本原子操作。之所以将CURD 提升到一个技术难题的高度，是因为完成一个涉及在多个数据库系统中进行CURD操作的汇总相关的活动，其性能可能会随数据关系的变化而有非常大的差异。</p>
<p>CURD在具体的应用中并非一定使用create、update、read和delete字样的方法，但是他们完成的功能是一致的。例如，ThinkPHP就是使用add、save、select和delete方法表示模型的CURD操作。</p>
<h2 id="ActiveRecord"><a href="#ActiveRecord" class="headerlink" title="ActiveRecord"></a>ActiveRecord</h2><p>ActiveRecord也属于ORM层，由Rails最早提出，遵循标准的ORM模型：表映射到记录，记录映射到对象，字段映射到对象属性。配合遵循的命名和配置惯例，能够很大程度的快速实现模型的操作，而且简洁易懂。</p>
<p>ActiveRecord的主要思想是：</p>
<ol>
<li>每一个数据库表对应创建一个类，类的每一个对象实例对应于数据库中表的一行记录；通常表的每个字段在类中都有相应的Field；</li>
<li>ActiveRecord同时负责把自己持久化，在ActiveRecord中封装了对数据库的访问，即CURD;</li>
<li>ActiveRecord是一种领域模型(Domain Model)，封装了部分业务逻辑；</li>
</ol>
<p>ActiveRecord比较适用于：</p>
<ol>
<li>业务逻辑比较简单，当你的类基本上和数据库中的表一一对应时, ActiveRecord是非常方便的，即你的业务逻辑大多数是对单表操作；</li>
<li>当发生跨表的操作时, 往往会配合使用事务脚本(Transaction Script)，把跨表事务提升到事务脚本中；</li>
<li>ActiveRecord最大优点是简单, 直观。 一个类就包括了数据访问和业务逻辑. 如果配合代码生成器使用就更方便了；<br>这些优点使ActiveRecord特别适合WEB快速开发。</li>
</ol>
<h2 id="单一入口"><a href="#单一入口" class="headerlink" title="单一入口"></a>单一入口</h2><p>单一入口通常是指一个项目或者应用具有一个统一（但并不一定是唯一）的入口文件，也就是说项目的所有功能操作都是通过这个入口文件进行的，并且往往入口文件是第一步被执行的。</p>
<p>单一入口的好处是项目整体比较规范，因为同一个入口，往往其不同操作之间具有相同的规则。另外一个方面就是单一入口带来的好处是控制较为灵活，因为拦截方便了，类似如一些权限控制、用户登录方面的判断和操作可以统一处理了。</p>
<p>或者有些人会担心所有网站都通过一个入口文件进行访问，是否会造成太大的压力，其实这是杞人忧天的想法。</p>
]]></content>
      <categories>
        <category>专业知识</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP底层的运行机制与原理</title>
    <url>/2019/11/08/cs-basic/cs-basic-language/cs-basic-language-php/PHP%E5%BA%95%E5%B1%82%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>记得我刚开始学习PHP的时候，许多面试官会经常问我PHP是什么，那时的标准回答是PHP是一种弱类型动态脚本编程语言，开源，免费，是超文本预处理器的缩写。</p>
<p>这只是很浅的解释，PHP对我来说是一个工具，是我手里的一把锤子，虽然这把锤子时常被调侃为两边都是起钉器的锤子。</p>
<p>使用「现实世界」中的任何工具时，如果理解这个工具的运作原理，那么你会更加得心应手的使用这个工具。应用开发也是这样。当你明白你的开发工具如何运行的，你就会对它们的使用游刃有余。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20191107151742.png"></p>
<h2 id="PHP-的特点"><a href="#PHP-的特点" class="headerlink" title="PHP 的特点"></a>PHP 的特点</h2><p><strong>多进程模型</strong></p>
<p>PHP是以多进程模型设计的，这样的好处是请求之间互不干涉，一个请求失败也不会对其他进程造成影响，作为最开始仅仅用于个人网站的一个工具集这样的设计并没有什么不妥，随着PHP的应用变大，访问量增加这种方式显然是不合适的，因为启动一个进程的开销对于海量请求是不划算的，所以现在PHP基本都是运行在PHP-FPM的管理下的，这是一个PHP进程管理器，它常驻内存启动一些PHP进程待命，当请求进入时分配一个进程进行处理，PHP进程处理完毕后回收进程，但并不销毁进程，这让PHP也能应对高流量的访问请求。</p>
<p>当然现在也有PHP多线程的解决方案和基于协程的解决方案让PHP更高效的处理WEB请求。</p>
<p><strong>弱类型</strong></p>
<p>与 JAVA、C&#x2F;C++ 不同，PHP是一门若类型的语言，变量在声明的那一刻是不需要确定它的类型的，而在运行时类型也会发生显式或隐式的类型改变，这也是PHP开发应用迅速、方便的原因之一。</p>
<p><strong>其他</strong></p>
<p>Zend 引擎 + Ext 扩展 的模式降低了内部耦合，可以方便的为PHP本身增加功能和去除功能。<br>语法简单，没有太多强制规范，编程风格上既可以用过程式、也可以用面向对象的方式进行开发，当然函数式也可以。</p>
<h2 id="PHP-的架构"><a href="#PHP-的架构" class="headerlink" title="PHP 的架构"></a>PHP 的架构</h2><p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20191107193632.png"></p>
<p>以目前的 PHP 主流版本 PHP7 和 PHP5 来说架构是如上图所示，主要有四层体系构成，从下到上依次是 Zend 引擎、Extensions 扩展、SAPI 接口、Application。</p>
<h3 id="Zend-引擎"><a href="#Zend-引擎" class="headerlink" title="Zend 引擎"></a>Zend 引擎</h3><p>Zend 引擎是 PHP4 以后加入 PHP 的，是对原有PHP解释器的重写，整体使用 C 语言进行开发，也就是说可以把PHP理解成用C写的一个编程语言软件，引擎的作用是将PHP代码翻译为一种叫opcode的中间语言，它类似于JAVA的ByteCode（字节码）。<br>引擎对PHP代码会执行四个步骤：</p>
<ul>
<li>词法分析 Scanning（Lexing），将 PHP 代码转换为语言片段（Tokens）。</li>
<li>解析 Parsing， 将 Tokens 转换成简单而有意义的表达式。</li>
<li>编译 Compilation，将表达式编译成Opcode。</li>
<li>执行 Execution，顺序执行Opcode，每次一条，以实现PHP代码所表达的功能。</li>
</ul>
<p>APC、Opchche 这些扩展可以将Opcode缓存以加速PHP应用的运行速度，使用它们就可以在请求再次来临时省略前三步。</p>
<p>引擎也实现了基本的数据结构（如hashtable、oo）、内存分配及管理、提供了相应的api方法供外部调用，是一切的核心，所有的外围功能均围绕Zend实现。</p>
<h3 id="Extensions-扩展"><a href="#Extensions-扩展" class="headerlink" title="Extensions 扩展"></a>Extensions 扩展</h3><p>围绕着 Zend 引擎，extensions 通过组件式的方式提供各种基础服务，我们常见的各种内置函数（如array系列）、标准库等都是通过 extension 来实现，用户也可以根据需要实现自己的 extension 以达到功能扩展、性能优化等目的（如贴吧正在使用的PHP中间层、富文本解析就是 extension 的典型应用）。</p>
<h3 id="SAPI"><a href="#SAPI" class="headerlink" title="SAPI"></a>SAPI</h3><p>SAPI 是 Server Application Programming Interface 的缩写，中文为服务端应用编程接口，它通过一系列钩子函数使得PHP可以和外围交换数据，SAPI 就是 PHP 和外部环境的代理器，它把外部环境抽象后，为内部的PHP提供一套固定的，统一的接口，使得 PHP 自身实现能够不受错综复杂的外部环境影响，保持一定的独立性。</p>
<p>通过 SAPI 的解耦，PHP 可以不再考虑如何针对不同应用进行兼容，而应用本身也可以针对自己的特点实现不同的处理方式。</p>
<h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>程序员编写的PHP程序，无论是 Web 应用还是 Cli 方式运行的应用都是上层应用，PHP 程序员主要工作就是编写它们。</p>
<blockquote>
<p>如果PHP是一辆车，那么车的框架就是PHP本身，Zend是车的引擎（发动机），Ext下面的各种组件就是车的轮子，Sapi可以看做是公路，车可以跑在不同类型的公路上，而一次PHP程序的执行就是汽车跑在公路上。因此，我们需要：性能优异的引擎+合适的车轮+正确的跑道。</p>
</blockquote>
<h2 id="SAPI-1"><a href="#SAPI-1" class="headerlink" title="SAPI"></a>SAPI</h2><p>如前所述，sapi通过通过一系列的接口，使得外部应用可以和PHP交换数据，并可以根据不同应用特点实现特定的处理方法，我们常见的一些sapi有：</p>
<ul>
<li><strong>apache2handler</strong>：这是以apache作为webserver，采用mod_PHP模式运行时候的处理方式。</li>
<li><strong>cgi</strong>：这是webserver和PHP之间的另一种交互方式，也就是大名鼎鼎的fastcgi协议，在最近今年fastcgi+PHP得到越来越多的应用，也是异步webserver所唯一支持的方式。</li>
<li><strong>cli</strong>：命令行调用的应用模式</li>
</ul>
<h2 id="PHP-的执行流程"><a href="#PHP-的执行流程" class="headerlink" title="PHP 的执行流程"></a>PHP 的执行流程</h2><p>我们先来看看PHP代码的执行所经过的流程。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20191107213413.png"></p>
<p>从图上可以看到，PHP实现了一个典型的动态语言执行过程：<strong>拿到一段代码后，经过词法解析、语法解析等阶段后，源程序会被翻译成一个个指令(opcodes)，然后ZEND虚拟机顺次执行这些指令完成操作</strong>。PHP本身是用C实现的，因此最终调用的也都是C的函数，实际上，我们可以把PHP看做是一个C开发的软件。</p>
<p>PHP的执行的核心是翻译出来的一条一条指令，也即opcode。</p>
<p>Opcode是PHP程序执行的最基本单位。一个opcode由两个参数(op1,op2)、返回值和处理函数组成。PHP程序最终被翻译为一组opcode处理函数的顺序执行。</p>
<p>常见的几个处理函数：</p>
<p>ZEND_ASSIGN_SPEC_CV_CV_HANDLER : 变量分配 （$a&#x3D;$b）</p>
<p>ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER：函数调用</p>
<p>ZEND_CONCAT_SPEC_CV_CV_HANDLER：字符串拼接 $a.$b</p>
<p>ZEND_ADD_SPEC_CV_CONST_HANDLER: 加法运算 $a+2</p>
<p>ZEND_IS_EQUAL_SPEC_CV_CONST：判断相等 $a&#x3D;&#x3D;1</p>
<p>ZEND_IS_IDENTICAL_SPEC_CV_CONST：判断相等 $a&#x3D;&#x3D;&#x3D;1</p>
<h2 id="核心数据结构——HashTable"><a href="#核心数据结构——HashTable" class="headerlink" title="核心数据结构——HashTable"></a>核心数据结构——HashTable</h2><p>HashTable是Zend的<strong>核心数据结构</strong>，在PHP里面几乎并用来实现所有常见功能，我们知道的PHP数组即是其典型应用，此外，在zend内部，如函数符号表、全局变量等也都是基于hash table来实现。</p>
<p>PHP的hash table具有如下特点：</p>
<ul>
<li>支持典型的key-&gt;value查询</li>
<li>可以当做数组使用</li>
<li>添加、删除节点是 O(1) 复杂度</li>
<li>key支持混合类型：同时存在关联数组合索引数组</li>
<li>Value支持混合类型：array (“string”, 2332)</li>
<li>支持线性遍历：如foreach</li>
</ul>
<p>Zend hash table实现了典型的hash表散列结构，同时通过附加一个双向链表，提供了正向、反向遍历数组的功能。其结构如下图：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20191107224545.png"></p>
<p>可以看到，在hash table中既有key-&gt;value形式的散列结构，也有双向链表模式，使得它能够非常方便的支持快速查找和线性遍历。</p>
<ul>
<li><strong>散列结构</strong>：Zend的散列结构是典型的hash表模型，通过链表的方式来解决冲突。需要注意的是zend的hash table是一个自增长的数据结构，当hash表数目满了之后，其本身会动态以2倍的方式扩容并重新元素位置。初始大小均为8。另外，在进行key-&gt;value快速查找时候，zend本身还做了一些优化，通过空间换时间的方式加快速度。比如在每个元素中都会用一个变量nKeyLength标识key的长度以作快速判定。</li>
<li><strong>双向链表</strong>：Zend hash table通过一个链表结构，实现了元素的线性遍历。理论上，做遍历使用单向链表就够了，之所以使用双向链表，主要目的是为了快速删除，避免遍历。Zend hash table是一种复合型的结构，作为数组使用时，即支持常见的关联数组也能够作为顺序索引数字来使用，甚至允许2者的混合。</li>
<li><strong>PHP关联数组</strong>：关联数组是典型的hash_table应用。一次查询过程经过如下几步（从代码可以看出，这是一个常见的hash查询过程，并增加一些快速判定加速查找。）：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">getKeyHashValue h;</span><br><span class="line">index = n &amp; nTableMask;</span><br><span class="line">Bucket *p = arBucket[index];</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((p-&gt;h == h) &amp; (p-&gt;nKeyLength == nKeyLength)) &#123;</span><br><span class="line">        RETURN p-&gt;data;   </span><br><span class="line">    &#125;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">RETURN FALTURE;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>PHP索引数组</strong>：索引数组就是我们常见的数组，通过下标访问。例如 $arr[0]，Zend HashTable内部进行了归一化处理，对于index类型key同样分配了hash值和nKeyLength(为0)。内部成员变量nNextFreeElement就是当前分配到的最大id，每次push后自动加一。正是这种归一化处理，PHP才能够实现关联和非关联的混合。由于push操作的特殊性，索引key在PHP数组中先后顺序并不是通过下标大小来决定，而是由push的先后决定。例如 $arr[1] &#x3D; 2; $arr[2] &#x3D; 3; 对于double类型的key，Zend HashTable会将他当做索引key处理</li>
</ul>
<h2 id="PHP-变量"><a href="#PHP-变量" class="headerlink" title="PHP 变量"></a>PHP 变量</h2><p>PHP是一门弱类型语言，本身不严格区分变量的类型。PHP在变量申明的时候不需要指定类型。PHP在程序运行期间可能进行变量类型的隐示转换。和其他强类型语言一样，程序中也可以进行显示的类型转换。PHP变量可以分为简单类型(int、string、bool)、集合类型(array resource object)和常量(const)。以上所有的变量在底层都是同一种结构 zval。</p>
<p>Zval是zend中另一个非常重要的数据结构，用来标识并实现PHP变量，其数据结构如下</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20191108054721.png"></p>
<p>Zval主要由三部分组成：</p>
<ul>
<li><strong>type</strong>：指定了变量所述的类型（整数、字符串、数组等）</li>
<li><strong>refcount&amp;is_ref</strong>：用来实现引用计数(后面具体介绍)</li>
<li><strong>value</strong>：核心部分，存储了变量的实际数据</li>
</ul>
<p>Zvalue是用来保存一个变量的实际数据。因为要存储多种类型，所以zvalue是一个union，也由此实现了弱类型。</p>
<p>PHP变量类型和其实际存储对应关系如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IS_LONG   -&gt; lvalue</span><br><span class="line">IS_DOUBLE -&gt; dvalue</span><br><span class="line">IS_ARRAY  -&gt; ht</span><br><span class="line">IS_STRING -&gt; str</span><br><span class="line">IS_RESOURCE -&gt; lvalue</span><br></pre></td></tr></table></figure>

<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>引用计数在内存回收、字符串操作等地方使用非常广泛。PHP中的变量就是引用计数的典型应用。Zval的引用计数通过成员变量is_ref和ref_count实现，通过引用计数，多个变量可以共享同一份数据。避免频繁拷贝带来的大量消耗。</p>
<p>在进行赋值操作时，zend将变量指向相同的zval同时ref_count++，在unset操作时，对应的ref_count-1。只有ref_count减为0时才会真正执行销毁操作。如果是引用赋值，则zend会修改is_ref为1。</p>
<p>PHP变量通过引用计数实现变量共享数据，那如果改变其中一个变量值呢？当试图写入一个变量时，Zend若发现该变量指向的zval被多个变量共享，则为其复制一份ref_count为1的zval，并递减原zval的refcount，这个过程称为“zval分离”。可见，只有在有写操作发生时zend才进行拷贝操作，因此也叫copy-on-write(写时拷贝)</p>
<p>对于引用型变量，其要求和非引用型相反，引用赋值的变量间必须是捆绑的，修改一个变量就修改了所有捆绑变量。</p>
<h3 id="整数和浮点数"><a href="#整数和浮点数" class="headerlink" title="整数和浮点数"></a>整数和浮点数</h3><p>整数、浮点数是PHP中的基础类型之一，也是一个简单型变量。对于整数和浮点数，在zvalue中直接存储对应的值。其类型分别是long和double。</p>
<p>从zvalue结构中可以看出，对于整数类型，和c等强类型语言不同，PHP是不区分int、unsigned int、long、long long等类型的，对它来说，整数只有一种类型也就是long。由此，可以看出，在PHP里面，整数的取值范围是由编译器位数来决定而不是固定不变的。</p>
<p>对于浮点数，类似整数，它也不区分float和double而是统一只有double一种类型。</p>
<p>在PHP中，如果整数范围越界了怎么办？这种情况下会自动转换为double类型，这个一定要小心，很多trick都是由此产生。</p>
<h3 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h3><p>和整数一样，字符变量也是PHP中的基础类型和简单型变量。通过zvalue结构可以看出，在PHP中，字符串是由由指向实际数据的指针和长度结构体组成，这点和c++中的string比较类似。由于通过一个实际变量表示长度，和c不同，它的字符串可以是2进制数据（包含\0），同时在PHP中，求字符串长度strlen是O(1)操作。</p>
<p>在新增、修改、追加字符串操作时，PHP都会重新分配内存生成新的字符串。最后，出于安全考虑，PHP在生成一个字符串时末尾仍然会添加\0。</p>
<p>常见的字符串拼接方式及速度比较：</p>
<p>假设有如下4个变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$strA = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">$strB = <span class="string">&#x27;456&#x27;</span>;</span><br><span class="line">$intA = <span class="number">123</span>;</span><br><span class="line">$intB = <span class="number">456</span>;</span><br></pre></td></tr></table></figure>

<p>现在对如下的几种字符串拼接方式做一个比较和说明：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面两张情况，zend会重新malloc一块内存并进行相应处理，其速度一般</span></span><br><span class="line"><span class="variable">$res</span> = <span class="variable">$strA</span> . <span class="variable">$strB</span></span><br><span class="line"><span class="variable">$res</span> = <span class="string">&quot;<span class="subst">$strA</span><span class="subst">$strB</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种是速度最快的，zend会在当前strA基础上直接relloc，避免重复拷贝</span></span><br><span class="line"><span class="variable">$strA</span> = <span class="variable">$strA</span> . <span class="variable">$strB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种速度较慢，因为需要做隐式的格式转换，实际编写程序中也应该注意尽量避免</span></span><br><span class="line"><span class="variable">$res</span> = <span class="variable">$intA</span> . <span class="variable">$intB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这会是最慢的一种方式，因为sprintf在PHP中并不是一个语言结构，</span></span><br><span class="line"><span class="comment">// 本身对于格式识别和处理就需要耗费比较多时间，另外本身机制也是malloc。</span></span><br><span class="line"><span class="comment">// 不过sprintf的方式最具可读性，实际中可以根据具体情况灵活选择。</span></span><br><span class="line"><span class="variable">$strA</span> = <span class="title function_ invoke__">sprintf</span> (<span class="string">&quot;%s%s&quot;</span>, <span class="variable">$strA</span> . <span class="variable">$strB</span>);</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>PHP的数组通过Zend HashTable来天然实现。</p>
<p>foreach操作如何实现？对一个数组的foreach就是通过遍历hashtable中的双向链表完成。对于索引数组，通过foreach遍历效率比for高很多，省去了key-&gt;value的查找。count操作直接调用HashTable-&gt;NumOfElements，O(1)操作。对于 ‘123’ 这样的字符串，zend会转换为其整数形式。$arr[‘123’]和$arr[123]是等价的。</p>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>资源类型变量是PHP中最复杂的一种变量，也是一种复合型结构。</p>
<p>PHP的zval可以表示广泛的数据类型，但是对于自定义的数据类型却很难充分描述。由于没有有效的方式描绘这些复合结构，因此也没有办法对它们使用传统的操作符。要解决这个问题，只需要通过一个本质上任意的标识符（label）引用指针，这种方式被称为资源。</p>
<p>在zval中，对于resource，lval作为指针来使用，直接指向资源所在的地址。Resource可以是任意的复合结构，我们熟悉的mysqli、fsock、memcached等都是资源。</p>
<p>如何使用资源：</p>
<ul>
<li><strong>注册</strong>：对于一个自定义的数据类型，要想将它作为资源。首先需要进行注册，zend会为它分配全局唯一标示。</li>
<li><strong>获取一个资源变量</strong>：对于资源，zend维护了一个id-&gt;实际数据的hash_tale。对于一个resource，在zval中只记录了它的id。fetch的时候通过id在hash_table中找到具体的值返回。</li>
<li><strong>资源销毁</strong>：资源的数据类型是多种多样的。Zend本身没有办法销毁它。因此需要用户在注册资源的时候提供销毁函数。当unset资源时，zend调用相应的函数完成析构。同时从全局资源表中删除它。</li>
</ul>
<p>资源可以长期驻留，不只是在所有引用它的变量超出作用域之后，甚至是在一个请求结束了并且新的请求产生之后。这些资源称为持久资源，因为它们贯通SAPI的整个生命周期持续存在，除非特意销毁。很多情况下，持久化资源可以在一定程度上提高性能。比如我们常见的mysql_pconnect ,持久化资源通过pemalloc分配内存，这样在请求结束的时候不会释放。 对zend来说，对两者本身并不区分。</p>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>PHP中的局部变量和全局变量是如何实现的？对于一个请求，任意时刻PHP都可以看到两个符号表(symbol_table和active_symbol_table)，其中前者用来维护全局变量。后者是一个指针，指向当前活动的变量符号表，当程序进入到某个函数中时，zend就会为它分配一个符号表x同时将active_symbol_table指向a。通过这样的方式实现全局、局部变量的区分。</p>
<ul>
<li><p><strong>获取变量值</strong>：PHP的符号表是通过hash_table实现的，对于每个变量都分配唯一标识，获取的时候根据标识从表中找到相应zval返回。</p>
</li>
<li><p><strong>函数中使用全局变量</strong>：在函数中，我们可以通过显式申明global来使用全局变量。在active_symbol_table中创建symbol_table中同名变量的引用，如果symbol_table中没有同名变量则会先创建。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>专业知识</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>Session原理解析</title>
    <url>/2019/11/09/cs-basic/cs-basic-language/cs-basic-language-php/Session%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>Session存在的意义，估计每个做web开发的人都是了解的，就为了解决HTTP是无状态协议所带来的问题，不多说了。这里主要想说的是服务端与客户端是如何利用session进行交互的。</p>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>先看下面这幅流程图：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20191108194847.png"></p>
<p>当用户第一次访问站点时，PHP会用session_start()函数为用户创建一个session ID，这就是针对这个用户的唯一标识，每一个访问的用户都会得到一个自己独有的session ID，这个session ID会存放在响应头里的cookie中，之后发送给客户端。这样客户端就会拥有一个该站点给他的session ID。</p>
<p>当用户第二次访问该站点时，浏览器会带着本地存放的cookie（里面存有上次得到的session ID）随着请求一起发送到服务器，服务端接到请求后会检测是否有session ID，如果有就会找到响应的session文件，把其中的信息读取出来；如果没有就跟第一次一样再创建个新的。</p>
<p>通常站点的退出功能，实际上就是调用一下session_destroy()函数(也有可能更复杂些)，把该用户的session文件删除，再把用户的cookie清除。这样客户端和服务端就算没有联系了。</p>
<p>图中的红框部分就是一次完整的HTTP请求，因为HTTP是无状态的，所以一次请求完成后客户端和服务端就不再有任何关系了，谁也不认识谁。但由于一些需要（如保持登录状态等），必须让服务端和客户端保持联系，session ID就成了这种联系的媒介了。</p>
<h2 id="客户端的工作"><a href="#客户端的工作" class="headerlink" title="客户端的工作"></a>客户端的工作</h2><p>通过上面的分析我们可以知道session实际上是依赖与cookie的，当用户访问某一站点时，浏览器会根据用户访问的站点自动搜索可用的cookie，如果有可用的就随着请求一起发送到了服务端。每次接收到服务端的响应时又会更新本地的cookie信息。</p>
<p>当然也可以用GET方式来传递session ID，但不推荐用GET，这样不安全。</p>
<p>实际工程中都是通过将多个字段（一般包含用户ID，sessionId等）编码生成Cookie，每次访问接口的时候通过解码Cookie拿到sessionId的方式工作的。</p>
<h2 id="服务端的工作"><a href="#服务端的工作" class="headerlink" title="服务端的工作"></a>服务端的工作</h2><p>由上面的流程图可以看到，服务端实际上是把产生的一些数据存放在了session文件中，该文件的名字就是”sess“加上session ID，这些文件的存放位置就是phpinfo()查到的session.savepath值。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20191108195320.png"></p>
<p>由上图我们可以很清楚的看到，服务端和客户端保存着同样的session ID信息，这就是两者保持联系的钥匙。</p>
<h2 id="反面影响"><a href="#反面影响" class="headerlink" title="反面影响"></a>反面影响</h2><p>有好处必然也有坏处，session带来的最主要问题就是对性能的影响，可以想象一下，对于一个千万用户级的web站点，如果每个用户都保存session文件，那每次用户访问光寻找相应的session文件就要耗掉不少系统资源的。所以这时就要对session的存储做一些自定义的设定了，如分目录或哈希等等。除了保存到session文件，也可以抛弃PHP自带的session功能，自己实现session，将session信息存放到数据库当中，这样做最好对数据库进行一下缓存的设置了，不然对上千万的数据进行太频繁的检索，也是蛮耗资源的。</p>
<p>实际工作中都是通过缓存来进行session校验的。</p>
<h2 id="定时清除"><a href="#定时清除" class="headerlink" title="定时清除"></a>定时清除</h2><p>客户端和服务端的这种联系必然是需要有时间的规定的，所以需要定期清除session。这个问题就需要在两方面考虑了，一个是清除服务端session文件，一个是清除客户端的cookie信息，因为两者都各保存着一半的信息。</p>
<p>PHP GC进程可以扫描session存放目录清除session文件，但这个进程是特别耗资源的，所以PHP默认是1%的几率在一个session启动时去清理一次过期的session，所以并不是说一个用户session过期了，他对应的session文件就马上被清除，99%的几率是没被清除的。这就需要我们程序员自己动手了。可以在session信息中存放一个过期时间，值为用户最后一次访问的时间。当用户一访问，就用当前时间减去上次访问时间看是否超时，如果超时了就删除相应session文件，并设置cookie的Expires属性为负值，使其客户端的cookie信息也过期，这样浏览器就自动把它删掉了。</p>
<h2 id="PHP关于Session的常用函数"><a href="#PHP关于Session的常用函数" class="headerlink" title="PHP关于Session的常用函数"></a>PHP关于Session的常用函数</h2><ul>
<li>**session_start()**： 启动session，这个没什么说的了。根据session ID打开session文件，如果没有session ID就创建一个ID和对应的session文件</li>
<li>**$SESSION[]**：存放用户信息的全局数组，session文件中除了存放$SESSION中的数据实际也会存放其他的信息，如id等</li>
<li>**sessionunset()**： 清空$SESSION数组，它是把数组里的值清空了，而$SESSION这个变量还是存在的，和unset($SESSION)是完全不同的概念</li>
<li>**sessioncommit()**：提交session数据并结束session，把$SESSION数据写到文件里并结束session。实际上当一个页面执行结束后，php会自动执行与这个函数相同的操作。所以这个函数也很少能用上</li>
<li>**session_destroy()**：注销session，这个就是关闭session，并删除掉相应的session文件了。切断了客户端和服务端的联系。</li>
</ul>
]]></content>
      <categories>
        <category>专业知识</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP：array_merge 的坑</title>
    <url>/2018/12/12/cs-basic/cs-basic-language/cs-basic-language-php/array-merge%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwly1fy4986ubwhj310w07k0td.jpg"></p>
<p><font color=#FF0000><strong>如果传入的值中有null，无论其他数组是否有值都将返回null。</strong></font></p>
<p><strong>实例</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$array1</span>=[</span><br><span class="line">    <span class="number">123</span>,</span><br><span class="line">    <span class="number">456</span>,</span><br><span class="line">    <span class="number">789</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="variable">$array2</span>=<span class="literal">null</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">array_merge</span>(<span class="variable">$array1</span>,<span class="variable">$array2</span>));</span><br></pre></td></tr></table></figure>
<p>输出</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwly1fy49ck5j1qj31mo056gmy.jpg"></p>
<p><strong>正确的用法</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$array1</span>=[</span><br><span class="line">    <span class="number">123</span>,</span><br><span class="line">    <span class="number">456</span>,</span><br><span class="line">    <span class="number">789</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="variable">$array2</span>=<span class="literal">null</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">array_merge</span>(<span class="variable">$array1</span>??[],<span class="variable">$array2</span>??[]));</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwly1fy49ep0dc4j311m0auwfl.jpg"></p>
]]></content>
      <categories>
        <category>专业知识</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP：array_search的坑</title>
    <url>/2018/12/12/cs-basic/cs-basic-language/cs-basic-language-php/array-search%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwly1fy48swju8wj317c084q3x.jpg"></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$array</span>=[</span><br><span class="line">    <span class="number">123</span>,</span><br><span class="line">    <span class="number">465</span>,</span><br><span class="line">    <span class="number">789</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">array_search</span>(<span class="number">123</span>,<span class="variable">$array</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;查询成功！&quot;</span>.PHP_EOL;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;查询失败！&quot;</span>.PHP_EOL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例将会输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">查询失败！</span></span><br></pre></td></tr></table></figure>

<p>为什么是查询失败呢？$array中不是有123吗？<br>其实查询确实成功了，只不过返回的是0，会被当作false处理。</p>
<p>正确的使用方式如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$array</span>=[</span><br><span class="line">    <span class="number">123</span>,</span><br><span class="line">    <span class="number">465</span>,</span><br><span class="line">    <span class="number">789</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">array_search</span>(<span class="number">123</span>,<span class="variable">$array</span>) !== <span class="literal">false</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;查询成功！&quot;</span>.PHP_EOL;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;查询失败！&quot;</span>.PHP_EOL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>专业知识</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在phpstorm中查看yaf框架源码</title>
    <url>/2019/03/25/cs-basic/cs-basic-language/cs-basic-language-php/%E5%A6%82%E4%BD%95%E5%9C%A8phpstorm%E4%B8%AD%E6%9F%A5%E7%9C%8Byaf%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<p><strong>1.到github下载yaf框架的doc</strong></p>
<p>下载链接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">https://github.com/haxianhe/php-yaf-doc.git</span><br></pre></td></tr></table></figure>

<p><strong>2.解压zip包</strong><br><strong>3.phpstrom配置</strong></p>
<p>打开phpstorm开发工具，找到Preferences…-&gt;php-&gt;Include Path:</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tKfTcly1g1eveg1htpj30dw0bv3ze.jpg"></p>
<p><strong>4.点击下方的+号，将上面解压后的目录添加到Include Path点击保存：</strong></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tKfTcgy1g1evf45aa8j30dw02kjri.jpg"></p>
<p><strong>5.验证一下配置是否成功</strong></p>
<p>比如打开项目中的index.php入口文件：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tKfTcly1g1evfw28rwj30jg06fwfd.jpg"></p>
<p>按住Ctrl键同时点击yaf框架的类Yaf_Application，如果能进去说明配置成功：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tKfTcly1g1evg7globj30go05h0ti.jpg"></p>
]]></content>
      <categories>
        <category>专业知识</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx核心模块之location匹配规则浅析</title>
    <url>/2019/11/01/cs-basic/cs-basic-middleware/cs-basic-middleware-nginx/Nginx%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%B9%8Blocation%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="location-规则"><a href="#location-规则" class="headerlink" title="location 规则"></a>location 规则</h2><p><strong>匹配规则</strong></p>
<ol>
<li>先匹配前缀字符串，然后记住最长匹配。</li>
<li>再匹配正则，如果正则的location中有匹配上的则返回第一个匹配上的正则，否则返回上一步中记住的最长前缀匹配。</li>
</ol>
<p>当前缀字符串使用 &#x3D;, ^~ 修饰的时候且匹配成功时直接返回结果，不进行正则匹配。</p>
<p><strong>修饰符</strong></p>
<p>匹配前缀字符串</p>
<ul>
<li>&#x3D; 表示精确匹配。只有请求的url路径与后面的字符串完全相等时，才会命中。</li>
<li>^~ 表示如果该符号后面的字符是最佳匹配，采用该规则，不再进行后续的查找。</li>
</ul>
<p><strong>注：当前缀字符串匹配规则前有修饰符修饰时，如果匹配成功不进行正则匹配。</strong></p>
<p>匹配正则</p>
<ul>
<li>~ 表示该规则是使用正则定义的，区分大小写。</li>
<li>~* 表示该规则是使用正则定义的，不区分大小写。</li>
</ul>
<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Syntax: location [ = | ~ | ~* | ^~ ] uri &#123; ... &#125;                </span><br><span class="line">        location @name &#123; ... &#125;             </span><br><span class="line">Default:	—               </span><br><span class="line">Context:	server, location</span><br></pre></td></tr></table></figure>
<p>Sets configuration depending on a request URI.</p>
<p>The matching is performed against a normalized URI, after decoding the text encoded in the “%XX” form, resolving references to relative path components “.” and “..”, and possible compression of two or more adjacent slashes into a single slash.</p>
<p>A location can either be defined by a prefix string, or by a regular expression. Regular expressions are specified with the preceding “<del>*” modifier (for case-insensitive matching), or the “</del>” modifier (for case-sensitive matching). To find location matching a given request, nginx first checks locations defined using the prefix strings (prefix locations). Among them, the location with the longest matching prefix is selected and remembered. Then regular expressions are checked, in the order of their appearance in the configuration file. The search of regular expressions terminates on the first match, and the corresponding configuration is used. If no match with a regular expression is found then the configuration of the prefix location remembered earlier is used.</p>
<p>location blocks can be nested, with some exceptions mentioned below.</p>
<p>For case-insensitive operating systems such as macOS and Cygwin, matching with prefix strings ignores a case (0.7.7). However, comparison is limited to one-byte locales.</p>
<p>Regular expressions can contain captures (0.7.40) that can later be used in other directives.</p>
<p>If the longest matching prefix location has the “^~” modifier then regular expressions are not checked.</p>
<p>Also, using the “&#x3D;” modifier it is possible to define an exact match of URI and location. If an exact match is found, the search terminates. For example, if a “&#x2F;” request happens frequently, defining “location &#x3D; &#x2F;” will speed up the processing of these requests, as search terminates right after the first comparison. Such a location cannot obviously contain nested locations.</p>
<p>Let’s illustrate the above by an example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location = / &#123;</span><br><span class="line">    [ configuration A ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">    [ configuration B ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /documents/ &#123;</span><br><span class="line">    [ configuration C ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ^~ /images/ &#123;</span><br><span class="line">    [ configuration D ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* \.(gif|jpg|jpeg)$ &#123;</span><br><span class="line">    [ configuration E ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The “&#x2F;” request will match configuration A, the “&#x2F;index.html” request will match configuration B, the “&#x2F;documents&#x2F;document.html” request will match configuration C, the “&#x2F;images&#x2F;1.gif” request will match configuration D, and the “&#x2F;documents&#x2F;1.jpg” request will match configuration E.</p>
<p>The “@” prefix defines a named location. Such a location is not used for a regular request processing, but instead used for request redirection. They cannot be nested, and cannot contain nested locations.</p>
<p>If a location is defined by a prefix string that ends with the slash character, and requests are processed by one of proxy_pass, fastcgi_pass, uwsgi_pass, scgi_pass, memcached_pass, or grpc_pass, then the special processing is performed. In response to a request with URI equal to this string, but without the trailing slash, a permanent redirect with the code 301 will be returned to the requested URI with the slash appended. If this is not desired, an exact match of the URI and location could be defined like this:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /user/ &#123;</span><br><span class="line">    proxy_pass http://user.example.com;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location = /user &#123;</span><br><span class="line">    proxy_pass http://login.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#location">ngx_http_core_module_location</a></li>
</ul>
]]></content>
      <categories>
        <category>专业知识</category>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>《实战Nginx：取代Apache的高性能Web服务器》</title>
    <url>/2018/12/04/cs-basic/cs-basic-middleware/cs-basic-middleware-nginx/%E5%AE%9E%E6%88%98Nginx%EF%BC%9A%E5%8F%96%E4%BB%A3Apache%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BDWeb%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>Web服务器也称为WWW服务器、HTTP服务器，其主要功能是提供网上信息浏览服务。</p>
<p>Unix和Linux平台下常用的Web服务器有Apache、Nginx、Lighttpd、Tomcat、IBM WebSphere等，其中应用最广泛的是Apache。而Windows NT&#x2F;2000&#x2F;2003平台下最常用的服务器测试微软公司的IIS(INternet Information Server)。</p>
<h1 id="mac下nginx安装及其目录配置"><a href="#mac下nginx安装及其目录配置" class="headerlink" title="mac下nginx安装及其目录配置"></a>mac下nginx安装及其目录配置</h1><p>背景：mac开发机，本地搭建nginx服务，对服务端存储的文档做展示。</p>
<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><p>直接通过brew安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install nginx</span><br></pre></td></tr></table></figure>

<h2 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo brew services start nginx</span><br></pre></td></tr></table></figure>

<h2 id="停止nginx"><a href="#停止nginx" class="headerlink" title="停止nginx"></a>停止nginx</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo brew services stop nginx</span><br></pre></td></tr></table></figure>

<h2 id="重新加载nginx"><a href="#重新加载nginx" class="headerlink" title="重新加载nginx"></a>重新加载nginx</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo brew service restart nginx</span><br></pre></td></tr></table></figure>

<h2 id="配置文件遍历"><a href="#配置文件遍历" class="headerlink" title="配置文件遍历"></a>配置文件遍历</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /usr/local/etc/nginx/nginx.conf</span><br><span class="line"># server 节点</span><br><span class="line">location ~ \.php$ &#123;</span><br><span class="line">              root           html;</span><br><span class="line">              fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">              fastcgi_index  index.php;</span><br><span class="line">              fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">              include        fastcgi_params;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>几个关键点：</p>
<ul>
<li>~ 和root 配置的目录必须是可达到的路径 <font color=#FF0000><strong>即&#x2F;Users&#x2F;yourusername&#x2F;dir_needed 此路径可达，否则访问时会报404</strong></font></li>
</ul>
<h2 id="一些文件路径"><a href="#一些文件路径" class="headerlink" title="一些文件路径"></a>一些文件路径</h2><p>用brew安装的nginx 一些文件路径不一样需要注意</p>
<ul>
<li><p>安装目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/Cellar/nginx/1.10.3</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>日志文件路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/var/log/nginx $ ls -lrt</span><br><span class="line">total 80</span><br><span class="line">-rw-r--r--  1 staff  admin  29646  3 19 14:45 access.log</span><br><span class="line">-rw-r--r--  1 staff  admin   6430  3 19 19:11 error.log</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Nginx与PHP-FastCGI-的安装、配置与优化"><a href="#Nginx与PHP-FastCGI-的安装、配置与优化" class="headerlink" title="Nginx与PHP(FastCGI)的安装、配置与优化"></a>Nginx与PHP(FastCGI)的安装、配置与优化</h1><p><strong>LNMP</strong></p>
<p>在互联网服务器架构中，我们经常可以听到LAMP(Linux+Apache+Mysql+Perl&#x2F;PHP&#x2F;Python)架构。</p>
<p>现在，由于Nginx拥有超越Apache的卓越性能，LAMP架构正在逐渐被LNMP()Linux+Nginx+Mysql+PHP)架构所取代。</p>
<p><strong>FastCGI</strong></p>
<p>FastCGI是语言无关的、可伸缩的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中并因此获得较高的性能。众所周知，CGI解释器的反复加载是CGI性能低下的主要原因，如果CGI解释器保持在内存中并接受FastCGI进程管理器调度，则可以提供良好的性能、伸缩性、Fail-Over特性等。</p>
<p><strong>FastCGI工作原理</strong></p>
<ol>
<li>FastCGI进程管理器自身初始化，启动多个CGI解释器进程（多个php-cgi）并等待来自Web Server的连接。在本文中，采用PHP-FPM进程管理器启动多个php-cgi FastCGI进程。启动php-cgi FastCGI进程时，可以配置以TCP和UNIX套接字两种方式启动。</li>
<li>当客户端请求到达Web服务器（Nginx）时，Web服务器将请求采用TCP协议或UNIX套接字方式转发到FastCGI主进程，FastCGI主进程选择并连接到一个CGI解释器（子进程）。Web服务器将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。</li>
<li>FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web服务器（Nginx）。当FastCGI子进程关闭连接时，请求便告知处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器的下一个连接。而在一般的普通CGI模式中，php-cgi在此便退出了。</li>
</ol>
<p>所以，你可以想象普通的CGI模式有多慢。每一个Web请求PHP都必须重新解析php.ini、重新载入全部扩展并重新初始化全部数据结构。使用FastCGI，所有的这些都只在进程启动时发生一次。</p>
<p><strong>PHP FastCGI的优点</strong></p>
<ol>
<li>PHP脚本运行速度更快。PHP解释程序被载入内存而不用每次需要时从存储器中读取，此举极大提升了依靠脚本运行站点的性能。</li>
<li>需要使用的系统资源更少。由于服务器不用再&#x3D;在每次需要时都载入PHP解释程序，你可以将站点的传输速度提升很多而不必正价CPU负担。</li>
<li>不需要对现有的代码作任何改变。运行在Apache+PHP上的陈旭，无需修改即可适用于PHP的FastCGI。</li>
</ol>
<h1 id="Nginx-HTTP-负载均衡和反向代理"><a href="#Nginx-HTTP-负载均衡和反向代理" class="headerlink" title="Nginx HTTP 负载均衡和反向代理"></a>Nginx HTTP 负载均衡和反向代理</h1><h2 id="什么是负载均衡和反向代理"><a href="#什么是负载均衡和反向代理" class="headerlink" title="什么是负载均衡和反向代理"></a>什么是负载均衡和反向代理</h2><p>随着网站访问量的快速增长，单台服务器已经无法承担大量用户的并发访问，必须采用多台服务器协同工作，以提高计算机系统的处理能力和计算强度，满足当前业务量的需求。而如何在完成同样功能的多个网络设备之间实现合理的业务量分配，使之不会出现一台设备过忙、而其他的设备却没有充分使用的情况。要解决这一问题，可以采用负载均衡的方法。</p>
<p><strong>负载均衡</strong></p>
<p>负载均衡是由多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，都可以单独对外提供服务而无需其他服务器的帮助。通过某种负载分担技术，将外部发送来的请求均匀分配到对称结构中的某一台服务器上，而接受到请求的服务器独立地回应客户的请求。均衡负载等狗平均分配客户请求到服务器阵列，籍此快速获取重要数据，解决大量兵法访问服务问题。</p>
<p><strong>反向代理</strong></p>
<p>反向代理是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返会费Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</p>
<p>通常的代理服务器，只用于代理内部网络对Internet的连接请求，客户机必须指定代理服务器，并将本来要直接发送到Web服务器上的http请求发送到代理服务器中。由于外部网络上的主机并不会配置并使用这个代理服务器，普通代理服务器也被设计为在Internet上搜寻多个不确定的服务器，而不是针对Internet上多个客户机的请求访问某个固定的服务器，因此普通的代理服务器不支持外部对内部网络的访问请求。当一个代理服务器等代理外部网络上的主机访问内部网络时，这种代理服务的方式称为反向代理服务。此时代理服务器对外就表现为一个Web服务器，外部网络就可以简单把它当作一个Web服务器而不需要特定的配置。不同之处在于，这个服务器没有保存任何网页的真实数据，所有的静态网页或CGI程序，都保存在内部的Web服务器上。因此对反向代理服务器的攻击并不会使网页信息遭到破坏，这样就增强了Web服务器的安全性。</p>
<h2 id="常见的Web负载均衡的方法"><a href="#常见的Web负载均衡的方法" class="headerlink" title="常见的Web负载均衡的方法"></a>常见的Web负载均衡的方法</h2><p><strong>用户手动选择方式</strong></p>
<p>这是一种较为古老的方式，通过在主站首页提供不同线路、不同服务器链接的方式，来实现负载均衡。这种方式在一些提供下载业务的网站中比较常见。</p>
<img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fxuhhyk8euj31620gk776.jpg" width="50%" heigh="50%" >

<p><strong>DNS轮询</strong></p>
<p>大多域名注册上都支持对同一主机名添加多条A记录，这就是DNS轮询，DNS服务器将解析按照A记录的顺序，随机分配到不同的IP上，这样就完成了简单的负载均衡。</p>
<p>DNS轮询的成本非常低，在一些不重要的服务上，被经常使用。</p>
<p>虽然DNS轮询成本低廉，但是，DNS负载均衡存在两个明显的缺点。</p>
<ol>
<li>可靠性低</li>
<li>负载分配不均衡</li>
</ol>
<p><strong>四&#x2F;七层负载均衡设备</strong></p>
<p>OSI七层模型</p>
<p>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>
<p>现代负载均衡技术通常操作于OSI网络模型的第四层或第七层。</p>
<p>第四层负载均衡将一个Internet上合法注册的IP地址映射为内部服务器的IP地址，对每次TCP连接请求动态使用其中一个内部IP地址，达到负载均衡的目的。在第四层交换机中，此种均衡技术得到广泛应用。<br>第七层负载均衡控制应用层服务的内容，提供了一种对访问流量的高层控制方式，适合对HTTP服务器群的应用。第七层负载均衡技术通过检查流经HTTP报头，根据报头内的信息来执行负载均衡任务。</p>
<h1 id="Nginx的Rewrite规则"><a href="#Nginx的Rewrite规则" class="headerlink" title="Nginx的Rewrite规则"></a>Nginx的Rewrite规则</h1><p><strong>什么是Nginx的Rewrite规则</strong></p>
<p>Rewrite的主要功能就是实现URL的重写。</p>
<p>正则表达式在计算机科学中，是指一个用来描述或匹配一系列符合某个句法规则的字符串的单个字符串。</p>
<p>通过Rewrite规则，可以实现规范的URL、根据变量来做URL转向及选择配置。</p>
]]></content>
      <categories>
        <category>专业知识</category>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>解决在nginx中不能执行php程序的问题</title>
    <url>/2019/01/30/cs-basic/cs-basic-middleware/cs-basic-middleware-nginx/%E8%A7%A3%E5%86%B3%E5%9C%A8nginx%E4%B8%AD%E4%B8%8D%E8%83%BD%E6%89%A7%E8%A1%8Cphp%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>先来简单介绍一下我遇到问题的症状，毕竟对症下药嘛。<br>访问：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">localhost:8080/index.html</span><br></pre></td></tr></table></figure>

<p>没有问题。</p>
<p>但是，访问.php结尾的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">localhost:8080/php_info.php</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNc79gy1fzotk4sc4aj304j00y0sk.jpg"></p>
<p>接下来简单介绍一下修改过程：</p>
<ol>
<li>修改一下nginx的配置文件</li>
<li>修改一下php-fpm的配置文件并重启</li>
</ol>
<h1 id="修改nginx的配置文件"><a href="#修改nginx的配置文件" class="headerlink" title="修改nginx的配置文件"></a>修改nginx的配置文件</h1><p>配置文件位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /usr/local/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNc79ly1fzotsoyap6j31a609uq4y.jpg"></p>
<p>将第71行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br></pre></td></tr></table></figure>
<p>改为第72行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br></pre></td></tr></table></figure>

<p>配置好后重新启动nginx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /usr/local/bin/nginx/nginx -s reload</span><br></pre></td></tr></table></figure>

<h1 id="修改php-fpm配置文件并重启"><a href="#修改php-fpm配置文件并重启" class="headerlink" title="修改php-fpm配置文件并重启"></a>修改php-fpm配置文件并重启</h1><p>php-fpm的配置文件位于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /usr/local/etc/php/7.0/php-fpm.conf </span><br></pre></td></tr></table></figure>

<p>修改这两个配置</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNc79ly1fzotzgzj9lj31d609c768.jpg"></p>
<p>或者</p>
<p>可以在启动php-fpm的位置加上  <em>–prefix &#x2F;usr&#x2F;local&#x2F;var</em> 参数</p>
<p>接下来修改php-fpm的启动端口，否则会提示9000已被占用（我查了一下占用这个端口的就是php-fpm，所以应该是可以通过重启的，但是我直接换了一个端口启动，绕过这个问题了）。</p>
<p>修改位置在：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNc79ly1fzou4fmkpdj30v202mjsa.jpg"></p>
<p>可以看到在php-fpm.conf 对这个配置文件进行了引用，修改端口就在这个文件中修改。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNc79ly1fzou5rsf3sj31jo0dctcj.jpg"></p>
<p>在这个位置可以对php-fpm，进行修改，改完端口记得修改nginx中对应的php-fpm对应的端口。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNc79gy1fzou6y99ukj31e609qgnq.jpg"></p>
<p>最后，重新启动php-fpm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo php-fpm --fpm-config /usr/local/etc/php/7.0/php-fpm.conf --prefix /usr/local/var</span><br></pre></td></tr></table></figure>

<p>然后再访问一次 <em>localhost:8080&#x2F;php_info.php</em></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNc79ly1fzou9l3uk0j31l60fsgph.jpg"></p>
<p>php_info.php的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?</span><br><span class="line">	phpinfo();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>专业知识</category>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Modify column Vs change column</title>
    <url>/2018/11/14/cs-basic/cs-basic-middleware/cs-basic-middleware-mysql/Modify-column-Vs-change-column/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>I know, we can not rename a column using modify column syntax,but can change column syntax.</p>
<p>My question is: what is the main usage of modify syntax?</p>
<p><strong>For example,</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tablename change col1 col1 <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<p>instead of</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tablename modify col1 <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p><strong>Edited</strong></p>
<p>Question replaced</p>
<p>What is the main usage of modify syntax?</p>
<p>Above question was replaced by below</p>
<p>Why we have to use change column instead of modify column?</p>
<h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>CHANGE COLUMN If you have already created your MySQL database, and decide after the fact that one of your columns is named incorrectly, you don’t need to remove it and make a replacement, you can simply rename it using change column.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> MyTable CHANGE <span class="keyword">COLUMN</span> foo bar <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">FIRST</span>;</span><br></pre></td></tr></table></figure>

<p>MODIFY COLUMN This command does everything CHANGE COLUMN can, but without renaming the column.You can use the modify SQL command if you need to resize a column in MySQL. By doing this you can allow more or less characters than before. You can’t rename a column using modify and other</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> MyTable MODIFY <span class="keyword">COLUMN</span> foo <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AFTER baz;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note : ALTER TABLE is used for altering a table means to change column name, size, drop column. CHANGE COLUMN and MODIFY COLUMN commands cannot be used without help of ALTER TABLE command.</p>
</blockquote>
]]></content>
      <categories>
        <category>专业知识</category>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 核心技术 - 主从复制</title>
    <url>/2021/09/25/cs-basic/cs-basic-middleware/cs-basic-middleware-mysql/MySQL%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%20-%20%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>主要涉及三个线程：binlog 线程、I&#x2F;O 线程和 SQL 线程。</p>
<ul>
<li>binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li>
<li>I&#x2F;O 线程 ：负责从主服务器上读取- 二进制日志，并写入从服务器的中继日志（Relay log）。</li>
<li>SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20230412162901.png"></p>
<h1 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h1><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p>
<p>读写分离能提高性能的原因在于：</p>
<ul>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li>
<li>增加冗余，提高可用性。</li>
</ul>
<p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20230412162920.png"></p>
<h1 id="如何解决主从延迟问题"><a href="#如何解决主从延迟问题" class="headerlink" title="如何解决主从延迟问题"></a>如何解决主从延迟问题</h1><ol>
<li>强制读主库。</li>
<li>加缓存</li>
<li>强同步。</li>
</ol>
</br>
</br>]]></content>
      <categories>
        <category>专业知识</category>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 核心技术 - 事务</title>
    <url>/2021/09/25/cs-basic/cs-basic-middleware/cs-basic-middleware-mysql/MySQL%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%20-%20%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>事务的四个特性是什么？</li>
<li>Mysql的四种隔离级别以及带来的问题</li>
<li>MVCC熟悉吗，它的底层原理？</li>
<li>InnoDB 是如何解决幻读？原理？</li>
<li>介绍一下InnoDB的日志？</li>
<li>InnoDB的事务是如何实现的</li>
<li>事务的实现原理</li>
<li>InnoDB 是如何保证事务的原子性的&#x2F;持久性？</li>
</ul>
</blockquote>
<p>事务是指满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>
<h1 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h1><p>事务最基本的莫过于 ACID 四个特性了，这四个特性分别是：</p>
<ul>
<li>Atomicity：原子性</li>
<li>Consistency：一致性</li>
<li>Isolation：隔离性</li>
<li>Durability：持久性</li>
</ul>
<p><strong>原子性</strong></p>
<p>事务被视为不可分割的最小单元，事务的所有操作要么全部成功，要么全部失败回滚。</p>
<p><strong>一致性</strong></p>
<p>数据库在事务执行前后都保持一致性状态，在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p>
<p><strong>隔离性</strong></p>
<p>一个事务所做的修改在最终提交以前，对其他事务是不可见的。</p>
<p><strong>持久性</strong></p>
<p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢。</p>
<h2 id="ACID-之间的关系"><a href="#ACID-之间的关系" class="headerlink" title="ACID 之间的关系"></a>ACID 之间的关系</h2><p><strong>执行结果正确 &#x3D; 一致性 &#x3D; 原子性 + 隔离性</strong></p>
<p><strong>应对数据库崩溃 &#x3D; 持久性</strong></p>
<p>事务的 ACID 特性概念很简单，但不好理解，主要是因为这几个特性不是一种平级关系：</p>
<ul>
<li>只有满足一致性，事务的结果才是正确的。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对数据库崩溃的情况。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20230412161935.png"></p>
<h2 id="InnoDB-如何实现-ACID-的特性"><a href="#InnoDB-如何实现-ACID-的特性" class="headerlink" title="InnoDB 如何实现 ACID 的特性"></a>InnoDB 如何实现 ACID 的特性</h2><p>事务的隔离性由 Next-Key Lock 实现，redo log 用来保证事务的原子性和持久性，undo log 用来保证事务的一致性。</p>
<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p><strong>未提交读（READ UNCOMMITTED）</strong></p>
<p>事务中的修改，即使没有提交，对其他事务也是可见的。</p>
<p><strong>提交读（READ COMMITTED）</strong></p>
<p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其他事务是不可见的。</p>
<p><strong>可重复读（REPEATABLE READ）</strong></p>
<p>保证在同一个事务中多次读取同样数据的结果是一样的。</p>
<p><strong>可串行化（SERIALIZABLE）</strong></p>
<p>强制事务串行执行。</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻影读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">未提交读</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">提交读</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">可串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<blockquote>
<ol>
<li>事务的隔离级别定义的的是当前读。</li>
<li>InnoDB在可重复读级别下的当前读通过Next-Key Lock锁机制解决了幻读问题。</li>
<li>InnoDB在可重复读级别下的快照读存在“幻读”问题，解决方案是（1）改为可串行化隔离级别（2）改为当前读（读操作加锁）</li>
</ol>
</blockquote>
<h1 id="事务并发处理带来的问题"><a href="#事务并发处理带来的问题" class="headerlink" title="事务并发处理带来的问题"></a>事务并发处理带来的问题</h1><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p>脏读指的是不同事务下，当前事务可以读取到另外事务未提交的数据。</p>
<p>例如：</p>
<p>T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20230412162003.png"></p>
<h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>不可重复读指的是同一事务内多次读取同一数据集合，读取到的数据是不一样的情况。</p>
<p>例如：</p>
<p>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20230412162029.png"></p>
<h2 id="Phantom-Proble（幻影读）"><a href="#Phantom-Proble（幻影读）" class="headerlink" title="Phantom Proble（幻影读）"></a>Phantom Proble（幻影读）</h2><p>Phantom Proble 是指在同一事务下，连续执行两次同样的 sql 语句可能返回不同的结果，第二次的 sql 语句可能会返回之前不存在的行。</p>
<p>幻影读是一种特殊的不可重复读问题。</p>
<h2 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h2><p>一个事务的更新操作会被另一个事务的更新操作所覆盖。</p>
<p>例如：</p>
<p>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20230412162049.png"></p>
<p>这类型问题可以通过给 SELECT 操作加上排他锁来解决，不过这可能会引入性能问题，具体使用要视业务场景而定。</p>
<h1 id="“读”"><a href="#“读”" class="headerlink" title="“读”"></a>“读”</h1><p>在可重复读级别中，通过MVCC机制，虽然让数据变得可重复读，但我们读到的数据可能是历史数据，是不及时的数据，不是数据库当前的数据！这在一些对于数据的时效特别敏感的业务中，就很可能出问题。</p>
<p>对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)，而读取数据库当前版本数据的方式，叫当前读 (current read)。很显然，在MVCC中：</p>
<h2 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h2><p>MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> ….;</span><br></pre></td></tr></table></figure>

<h2 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h2><p>MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span>;</span><br><span class="line"><span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">DELETE</span>;</span><br></pre></td></tr></table></figure>

<p>在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="operator">-</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>事务的隔离级别实际上都是定义的当前读的级别，MySQL为了减少锁处理（包括等待其它锁）的时间，提升并发能力，引入了快照读的概念，使得select不用加锁。而update、insert这些“当前读”的隔离性，就需要通过加锁来实现了。</p>
<h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p><strong>版本号</strong></p>
<ul>
<li>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li>
<li>事务版本号：事务开始时的系统版本号。</li>
</ul>
<p><strong>隐藏的列</strong></p>
<p>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：</p>
<ul>
<li>创建版本号：指示创建一个数据行的快照时的系统版本号；</li>
<li>删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。</li>
</ul>
<p><strong>Undo 日志</strong></p>
<p>MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20230412162115.png"></p>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>以下实现过程针对可重复读隔离级别。</p>
<p>当开始一个事务时，该事务的版本号肯定大于当前所有数据行快照的创建版本号，理解这一点很关键。数据行快照的创建版本号是创建数据行快照时的系统版本号，系统版本号随着创建事务而递增，因此新创建一个事务时，这个事务的系统版本号比之前的系统版本号都大，也就是比所有数据行快照的创建版本号都大。</p>
<p><strong>SELECT</strong></p>
<p>多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。</p>
<p>把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于等于 T 的版本号，因为如果大于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。除此之外，T 所要读取的数据行快照的删除版本号必须是未定义或者大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。</p>
<p><strong>INSERT</strong></p>
<p>将当前系统版本号作为数据行快照的创建版本号。</p>
<p><strong>DELETE</strong></p>
<p>将当前系统版本号作为数据行快照的删除版本号。</p>
<p><strong>UPDATE</strong></p>
<p>将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>锁是数据库系统区别于文件系统的一个关键特性。锁机制用于管理对共享资源的并发访问。</p>
<h2 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h2><p><strong>共享锁（S Lock）</strong></p>
<p>允许事务读一行数据</p>
<p><strong>排他锁（X Lock）</strong></p>
<p>允许事务删除或者更新一行数据</p>
<p><strong>意向共享锁（IS Lock）</strong></p>
<p>事务想要获得一张表中某几行的共享锁</p>
<p><strong>意向排他锁</strong></p>
<p>事务想要获得一张表中某几行的排他锁</p>
<h2 id="锁算法"><a href="#锁算法" class="headerlink" title="锁算法"></a>锁算法</h2><p><strong>Record Lock</strong></p>
<p>锁定一个记录上的索引，而不是记录本身。</p>
<p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p>
<p><strong>Gap Lock</strong></p>
<p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Next-Key Lock</strong></p>
<p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(<span class="operator">-</span>∞, <span class="number">10</span>]</span><br><span class="line">(<span class="number">10</span>, <span class="number">11</span>]</span><br><span class="line">(<span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line">(<span class="number">13</span>, <span class="number">20</span>]</span><br><span class="line">(<span class="number">20</span>, <span class="operator">+</span>∞)</span><br></pre></td></tr></table></figure>

<h1 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h1><h2 id="redo-log-重做日志"><a href="#redo-log-重做日志" class="headerlink" title="redo log(重做日志)"></a>redo log(重做日志)</h2><p><strong>作用</strong></p>
<p>确保事务的原子性和持久性。</p>
<p>防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。</p>
<p><strong>内容</strong></p>
<p>物理格式的日志，记录的是物理数据页面的修改的信息，其redo log是顺序写入redo log file的物理文件中去的。</p>
<p><strong>什么时候产生</strong></p>
<p>事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。</p>
<p><strong>什么时候释放</strong></p>
<p>当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。</p>
<p><strong>对应的物理文件</strong></p>
<p>默认情况下，对应的物理文件位于数据库的data目录下的ib_logfile1&amp;ib_logfile2</p>
<ul>
<li>innodb_log_group_home_dir 指定日志文件组所在的路径，默认.&#x2F; ，表示在数据库的数据目录下。　　</li>
<li>innodb_log_files_in_group 指定重做日志文件组中文件的数量，默认2</li>
</ul>
<p>　　</p>
<p>关于文件的大小和数量，由一下两个参数配置</p>
<ul>
<li>innodb_log_file_size 重做日志文件的大小。　　</li>
<li>innodb_mirrored_log_groups 指定了日志镜像文件组的数量，默认1其他：</li>
</ul>
<p>　　</p>
<p>很重要一点，redo log是什么时候写盘的？</p>
<p>前面说了是在事物开始之后逐步写盘的。</p>
<p>之所以说重做日志是在事务开始之后逐步写入重做日志文件，而不一定是事务提交才写入重做日志缓存，原因就是，重做日志有一个缓存区Innodb_log_buffer，Innodb_log_buffer的默认大小为8M(这里设置的16M)，Innodb存储引擎先将重做日志写入innodb_log_buffer中。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20230412162140.png"></p>
<p><strong>然后会通过以下三种方式将innodb日志缓冲区的日志刷新到磁盘：</strong>　　</p>
<ol>
<li>Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件。</li>
<li>每个事务提交时会将重做日志刷新到重做日志文件。</li>
<li>当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件。</li>
</ol>
<p>由此可以看出，重做日志通过不止一种方式写入到磁盘，尤其是对于第一种方式，Innodb_log_buffer到重做日志文件是Master Thread线程的定时任务。因此重做日志的写盘，并不一定是随着事务的提交才写入重做日志文件的，而是随着事务的开始，逐步开始的。　　</p>
<blockquote>
<p>另外引用《MySQL技术内幕 Innodb 存储引擎》（page37）上的原话：”即使某个事务还没有提交，Innodb存储引擎仍然每秒会将重做日志缓存刷新到重做日志文件。”这一点是必须要知道的，因为这可以很好地解释再大的事务的提交（commit）的时间也是很短暂的。</p>
</blockquote>
<h2 id="undo-log（回滚日志）"><a href="#undo-log（回滚日志）" class="headerlink" title="undo log（回滚日志）"></a>undo log（回滚日志）</h2><p><strong>作用</strong></p>
<p><strong>保存了事务发生之前的数据的一个版本</strong>（比如一条 INSERT 语句，对应一条 DELETE 的 undo log ，对于每个 UPDATE 语句，对应一条相反的 UPDATE 的 undo log），<strong>可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</strong></p>
<p><strong>内容</strong></p>
<p>逻辑格式的日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的。</p>
<p><strong>什么时候产生</strong></p>
<p>事务开始之前，将当前的版本生成undo log，undo 也会产生 redo 来保证undo log的持久性。</p>
<p><strong>什么时候释放</strong></p>
<p>当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。</p>
<p><strong>对应的物理文件</strong></p>
<p>MySQL5.6之前，undo表空间位于共享表空间的回滚段中，共享表空间的默认的名称是ibdata，位于数据文件目录中。</p>
<p>MySQL5.6之后，undo表空间可以配置成独立的文件，但是提前需要在配置文件中配置，完成数据库初始化后生效且不可改变undo log文件的个数，如果初始化数据库之前没有进行相关配置，那么就无法配置成独立的表空间了。</p>
<p>关于MySQL5.7之后的独立undo 表空间配置参数如下：</p>
<ul>
<li>innodb_undo_directory &#x3D; &#x2F;data&#x2F;undospace&#x2F; –undo独立表空间的存放目录</li>
<li>innodb_undo_logs &#x3D; 128 –回滚段为128KB</li>
<li>innodb_undo_tablespaces &#x3D; 4 –指定有4个undo log文件</li>
</ul>
<p>如果undo使用的共享表空间，这个共享表空间中又不仅仅是存储了undo的信息，共享表空间的默认为与MySQL的数据目录下面，其属性由参数innodb_data_file_path配置。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20230412162200.png"></p>
<p><strong>其他</strong></p>
<p>undo log是在事务开始之前保存的被修改数据的一个版本，产生undo日志的时候，同样会伴随类似于保护事务持久化机制的redo log的产生。</p>
<p>默认情况下undo文件是保持在共享表空间的，也即ibdatafile文件中，当数据库中发生一些大的事务性操作的时候，要生成大量的undo信息，全部保存在共享表空间中的。</p>
<p>因此共享表空间可能会变的很大，默认情况下，也就是undo 日志使用共享表空间的时候，被“撑大”的共享表空间是不会也不能自动收缩的。</p>
<p>因此，mysql5.7之后的“独立undo 表空间”的配置就显得很有必要了。</p>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p><strong>作用</strong></p>
<ol>
<li><strong>复制</strong>：在主从同步中，从库利用主库上的 binlog 进行重放，实现主从同步。</li>
<li><strong>恢复</strong>：用于数据库的基于时间点的还原。</li>
</ol>
<p><strong>内容</strong></p>
<p>逻辑格式的日志，可以简单认为就是执行过的事务中的sql语句。</p>
<p>但又不完全是sql语句这么简单，而是包括了执行的sql语句（增删改）信息。</p>
<p>在使用mysqlbinlog解析binlog之后一些都会真相大白。</p>
<p>因此可以基于binlog做到类似于oracle的闪回功能，其实都是依赖于binlog中的日志记录。</p>
<p><strong>什么时候产生</strong></p>
<p>事务提交的时候，一次性将事务中的sql语句（一个事物可能对应多个sql语句）按照一定的格式记录到binlog中。</p>
<p>这里与redo log很明显的差异就是redo log并不一定是在事务提交的时候刷新到磁盘，redo log是在事务开始之后就开始逐步写入磁盘。</p>
<p>因此对于事务的提交，即便是较大的事务，提交（commit）都是很快的，但是在开启了bin_log的情况下，对于较大事务的提交，可能会变得比较慢一些。</p>
<p>这是因为binlog是在事务提交的时候一次性写入的造成的，这些可以通过测试验证。</p>
<p><strong>什么时候释放</strong></p>
<p>binlog的默认是保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20230412162220.png"><br>　　<br><strong>对应的物理文件</strong></p>
<p>配置文件的路径为log_bin_basename，binlog日志文件按照指定大小，当日志文件达到指定的最大的大小之后，进行滚动更新，生成新的日志文件。</p>
<p>对于每个binlog日志文件，通过一个统一的index文件来组织。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20230412162239.png"></p>
<p><strong>其他</strong></p>
<p>二进制日志的作用之一是还原数据库的，这与redo log很类似，很多人混淆过，但是两者有本质的不同</p>
<ol>
<li>作用不同：redo log是保证事务的持久性的，是事务层面的，binlog作为还原的功能，是数据库层面的（当然也可以精确到事务层面的），虽然都有还原的意思，但是其保护数据的层次是不一样的。<br>2.内容不同：redo log是物理日志，是数据页面的修改之后的物理记录，binlog是逻辑日志，可以简单认为记录的就是sql语句</li>
<li>另外，两者日志产生的时间，可以释放的时间，在可释放的情况下清理机制，都是完全不同的。<br>4.恢复数据时候的效率，基于物理日志的redo log恢复数据的效率要高于语句逻辑日志的binlog</li>
</ol>
<p>关于事务提交时，redo log和binlog的写入顺序，为了保证主从复制时候的主从一致（当然也包括使用binlog进行基于时间点还原的情况），是要严格一致的。</p>
<p>MySQL通过两阶段提交过程来完成事务的一致性的，也即redo log和binlog的一致性的，理论上是先写redo log，再写binlog，两个日志都提交成功（刷入磁盘），事务才算真正的完成。</p>
<h2 id="redo-log-undo-log总结"><a href="#redo-log-undo-log总结" class="headerlink" title="redo log &amp; undo log总结"></a>redo log &amp; undo log总结</h2><p>下面是redo log + undo log的简化过程，便于理解两种日志的过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假设有A、B两个数据，值分别为1,2.</span><br><span class="line">1. 事务开始</span><br><span class="line">2. 记录A=1的 undo log 到 redo log</span><br><span class="line">3. 记录A=1到 undo log</span><br><span class="line">4. 修改A=3</span><br><span class="line">5. 记录A=3到 redo log</span><br><span class="line">6. 记录B=2的 undo log到 redo log</span><br><span class="line">7. 记录B=2到 undo log</span><br><span class="line">8. 修改B=4</span><br><span class="line">9. 记录B=4到redo log</span><br><span class="line">10. 将redo log写入磁盘</span><br><span class="line">11. 事务提交</span><br></pre></td></tr></table></figure>

<h2 id="redo-log-和-bin-log-的区别"><a href="#redo-log-和-bin-log-的区别" class="headerlink" title="redo log 和 bin log 的区别"></a>redo log 和 bin log 的区别</h2><ul>
<li><strong>日志级别不同</strong>：重做日志是在 InnoDB 存储引擎层产生的，而二进制日志是在 MySQL 数据库的上层的产生的。</li>
<li><strong>日志内容不同</strong>：二进制日志是一种逻辑日志，记录的是执行的SQL，而重做日志是物理格式日志，其记录的是对每个页的修改。</li>
<li><strong>写入磁盘时间不同</strong>：二进制日志只在事务提交完成后一次写入，而重做日志在事务执行中不断被写入。</li>
</ul>
</br>
</br>]]></content>
      <categories>
        <category>专业知识</category>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 核心技术 - 其他问题</title>
    <url>/2021/09/25/cs-basic/cs-basic-middleware/cs-basic-middleware-mysql/MySQL%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%20-%20%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><blockquote>
<p>在实际业务中经常会使用到 JSON 数据类型，在查询过程中主要有两种使用需求：</p>
<ol>
<li>在 where 条件中有通过 json 中的某个字段去过滤返回结果的需求</li>
<li>查询 json 字段中的部分字段作为返回结果（减少内存占用）</li>
</ol>
</blockquote>
<h2 id="JSON-CONTAINS"><a href="#JSON-CONTAINS" class="headerlink" title="JSON_CONTAINS"></a>JSON_CONTAINS</h2><p><strong>JSON_CONTAINS(target, candidate[, path])</strong></p>
<p><strong>如果在 json 字段 target 指定的位置 path，找到了目标值 condidate，返回 1，否则返回 0</strong></p>
<p><strong>如果只是检查在指定的路径是否存在数据，使用JSON_CONTAINS_PATH()</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> <span class="variable">@j</span> <span class="operator">=</span> <span class="string">&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: &#123;&quot;d&quot;: 4&#125;&#125;&#x27;</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> <span class="variable">@j2</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> JSON_CONTAINS(<span class="variable">@j</span>, <span class="variable">@j2</span>, <span class="string">&#x27;$.a&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+</span></span><br><span class="line"><span class="operator">|</span> JSON_CONTAINS(<span class="variable">@j</span>, <span class="variable">@j2</span>, <span class="string">&#x27;$.a&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+</span></span><br><span class="line"><span class="operator">|</span>                             <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> JSON_CONTAINS(<span class="variable">@j</span>, <span class="variable">@j2</span>, <span class="string">&#x27;$.b&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+</span></span><br><span class="line"><span class="operator">|</span> JSON_CONTAINS(<span class="variable">@j</span>, <span class="variable">@j2</span>, <span class="string">&#x27;$.b&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+</span></span><br><span class="line"><span class="operator">|</span>                             <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> <span class="variable">@j2</span> <span class="operator">=</span> <span class="string">&#x27;&#123;&quot;d&quot;: 4&#125;&#x27;</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> JSON_CONTAINS(<span class="variable">@j</span>, <span class="variable">@j2</span>, <span class="string">&#x27;$.a&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+</span></span><br><span class="line"><span class="operator">|</span> JSON_CONTAINS(<span class="variable">@j</span>, <span class="variable">@j2</span>, <span class="string">&#x27;$.a&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+</span></span><br><span class="line"><span class="operator">|</span>                             <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> JSON_CONTAINS(<span class="variable">@j</span>, <span class="variable">@j2</span>, <span class="string">&#x27;$.c&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+</span></span><br><span class="line"><span class="operator">|</span> JSON_CONTAINS(<span class="variable">@j</span>, <span class="variable">@j2</span>, <span class="string">&#x27;$.c&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+</span></span><br><span class="line"><span class="operator">|</span>                             <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+</span></span><br></pre></td></tr></table></figure>

<h2 id="JSON-CONTAINS-PATH"><a href="#JSON-CONTAINS-PATH" class="headerlink" title="JSON_CONTAINS_PATH"></a>JSON_CONTAINS_PATH</h2><p><strong>JSON_CONTAINS_PATH(json_doc, one_or_all, path[, path] …)</strong></p>
<p><strong>如果在指定的路径存在数据返回 1，否则返回 0</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> <span class="variable">@j</span> <span class="operator">=</span> <span class="string">&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: &#123;&quot;d&quot;: 4&#125;&#125;&#x27;</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> JSON_CONTAINS_PATH(<span class="variable">@j</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;$.a&#x27;</span>, <span class="string">&#x27;$.e&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> JSON_CONTAINS_PATH(<span class="variable">@j</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;$.a&#x27;</span>, <span class="string">&#x27;$.e&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>                                           <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------+</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> JSON_CONTAINS_PATH(<span class="variable">@j</span>, <span class="string">&#x27;all&#x27;</span>, <span class="string">&#x27;$.a&#x27;</span>, <span class="string">&#x27;$.e&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> JSON_CONTAINS_PATH(<span class="variable">@j</span>, <span class="string">&#x27;all&#x27;</span>, <span class="string">&#x27;$.a&#x27;</span>, <span class="string">&#x27;$.e&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>                                           <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------+</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> JSON_CONTAINS_PATH(<span class="variable">@j</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;$.c.d&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> JSON_CONTAINS_PATH(<span class="variable">@j</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;$.c.d&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>                                      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------------------+</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> JSON_CONTAINS_PATH(<span class="variable">@j</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;$.a.d&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> JSON_CONTAINS_PATH(<span class="variable">@j</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;$.a.d&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>                                      <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>实际使用：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$conds</span> = <span class="keyword">new</span> <span class="title class_">Criteria</span>();</span><br><span class="line"><span class="variable">$conds</span>-&gt;<span class="title function_ invoke__">andWhere</span>(<span class="string">&#x27;dept_code&#x27;</span>, <span class="string">&#x27;in&#x27;</span>, <span class="variable">$deptCodes</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">empty</span>(<span class="variable">$aoiAreaId</span>)) &#123;</span><br><span class="line">    <span class="variable">$aoiAreaIdCond</span> = <span class="keyword">new</span> <span class="title class_">Criteria</span>();</span><br><span class="line">    <span class="variable">$aoiAreaIdCond</span>-&gt;<span class="title function_ invoke__">orWhere</span>(<span class="string">&quot;JSON_CONTAINS_PATH(new_aoi_area_ids,&#x27;one&#x27;, &#x27;$.\&quot;<span class="subst">$aoiAreaId</span>\&quot;&#x27;)&quot;</span>, <span class="string">&#x27;=&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="variable">$aoiAreaIdCond</span>-&gt;<span class="title function_ invoke__">orWhere</span>(<span class="string">&quot;JSON_CONTAINS_PATH(old_aoi_area_ids,&#x27;one&#x27;, &#x27;$.\&quot;<span class="subst">$aoiAreaId</span>\&quot;&#x27;)&quot;</span>, <span class="string">&#x27;=&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="variable">$conds</span>-&gt;<span class="title function_ invoke__">andWhere</span>(<span class="variable">$aoiAreaIdCond</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="column-path、column-path"><a href="#column-path、column-path" class="headerlink" title="column-&gt;path、column-&gt;&gt;path"></a>column-&gt;path、column-&gt;&gt;path</h2><p><strong>获取指定路径的值</strong></p>
<p><strong>-&gt; vs -&gt;&gt;</strong></p>
<p>Whereas the -&gt; operator simply extracts a value, the -&gt;&gt; operator in addition unquotes the extracted result.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> jemp <span class="keyword">WHERE</span> g <span class="operator">&gt;</span> <span class="number">2</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+------+</span></span><br><span class="line"><span class="operator">|</span> c                             <span class="operator">|</span> g    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+------+</span></span><br><span class="line"><span class="operator">|</span> &#123;&quot;id&quot;: &quot;3&quot;, &quot;name&quot;: &quot;Barney&quot;&#125; <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> &#123;&quot;id&quot;: &quot;4&quot;, &quot;name&quot;: &quot;Betty&quot;&#125;  <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> c<span class="operator">-</span><span class="operator">&gt;</span><span class="string">&#x27;$.name&#x27;</span> <span class="keyword">AS</span> name</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     <span class="keyword">FROM</span> jemp <span class="keyword">WHERE</span> g <span class="operator">&gt;</span> <span class="number">2</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> name     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> &quot;Barney&quot; <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> &quot;Betty&quot;  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> JSON_UNQUOTE(c<span class="operator">-</span><span class="operator">&gt;</span><span class="string">&#x27;$.name&#x27;</span>) <span class="keyword">AS</span> name</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     <span class="keyword">FROM</span> jemp <span class="keyword">WHERE</span> g <span class="operator">&gt;</span> <span class="number">2</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> Barney <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Betty  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> c<span class="operator">-</span><span class="operator">&gt;&gt;</span><span class="string">&#x27;$.name&#x27;</span> <span class="keyword">AS</span> name</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     <span class="keyword">FROM</span> jemp <span class="keyword">WHERE</span> g <span class="operator">&gt;</span> <span class="number">2</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> Barney <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Betty  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>实际使用：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$retTask</span> = <span class="title class_">AoiAreaTaskOrm</span>::<span class="title function_ invoke__">findRows</span>([<span class="string">&#x27;status&#x27;</span>, <span class="string">&#x27;extra_info-&gt;&gt;&quot;$.new_aoi_area_infos&quot; as new_aoi_area_infos&#x27;</span>, <span class="string">&#x27;extra_info-&gt;&gt;&quot;$.old_aoi_area_infos&quot; as old_aoi_area_infos&#x27;</span>], <span class="variable">$cond</span>);</span><br></pre></td></tr></table></figure>


<h1 id="关系数据库设计理论"><a href="#关系数据库设计理论" class="headerlink" title="关系数据库设计理论"></a>关系数据库设计理论</h1><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p>
<p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p>
<p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p>
<p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p>
<table>
<thead>
<tr>
<th align="center">Sno</th>
<th align="center">Sname</th>
<th align="center">Sdept</th>
<th align="center">Mname</th>
<th align="center">Cname</th>
<th align="center">Grade</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">学生-1</td>
<td align="center">学院-1</td>
<td align="center">院长-1</td>
<td align="center">课程-1</td>
<td align="center">90</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">学生-2</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
<td align="center">课程-2</td>
<td align="center">80</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">学生-2</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
<td align="center">课程-1</td>
<td align="center">100</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">学生-3</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
<td align="center">课程-2</td>
<td align="center">95</td>
</tr>
</tbody></table>
<p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p>
<ul>
<li>冗余数据：例如 <code>学生-2</code> 出现了两次。</li>
<li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li>
<li>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li>
<li>插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li>
</ul>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>范式理论是为了解决以上提到四种异常。</p>
<p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p>
<p><strong>第一范式 (1NF)</strong></p>
<p>属性不可分。</p>
<p><strong>第二范式 (2NF)</strong></p>
<p>每个非主属性完全函数依赖于键码。</p>
<p>可以通过分解来满足。</p>
<p><strong>分解前</strong></p>
<table>
<thead>
<tr>
<th align="center">Sno</th>
<th align="center">Sname</th>
<th align="center">Sdept</th>
<th align="center">Mname</th>
<th align="center">Cname</th>
<th align="center">Grade</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">学生-1</td>
<td align="center">学院-1</td>
<td align="center">院长-1</td>
<td align="center">课程-1</td>
<td align="center">90</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">学生-2</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
<td align="center">课程-2</td>
<td align="center">80</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">学生-2</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
<td align="center">课程-1</td>
<td align="center">100</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">学生-3</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
<td align="center">课程-2</td>
<td align="center">95</td>
</tr>
</tbody></table>
<p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
<li>Sno, Cname-&gt; Grade</li>
</ul>
<p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p>
<p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p>
<p><strong>分解后</strong></p>
<p>关系-1</p>
<table>
<thead>
<tr>
<th align="center">Sno</th>
<th align="center">Sname</th>
<th align="center">Sdept</th>
<th align="center">Mname</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">学生-1</td>
<td align="center">学院-1</td>
<td align="center">院长-1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">学生-2</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">学生-3</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
</tr>
</tbody></table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
</ul>
<p>关系-2</p>
<table>
<thead>
<tr>
<th align="center">Sno</th>
<th align="center">Cname</th>
<th align="center">Grade</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">课程-1</td>
<td align="center">90</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">课程-2</td>
<td align="center">80</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">课程-1</td>
<td align="center">100</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">课程-2</td>
<td align="center">95</td>
</tr>
</tbody></table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno, Cname -&gt;  Grade</li>
</ul>
<p><strong>第三范式 (3NF)</strong></p>
<p>非主属性不传递函数依赖于键码。</p>
<p>上面的 关系-1 中存在以下传递函数依赖：</p>
<ul>
<li>Sno -&gt; Sdept -&gt; Mname</li>
</ul>
<p>可以进行以下分解：</p>
<p>关系-11</p>
<table>
<thead>
<tr>
<th align="center">Sno</th>
<th align="center">Sname</th>
<th align="center">Sdept</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">学生-1</td>
<td align="center">学院-1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">学生-2</td>
<td align="center">学院-2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">学生-3</td>
<td align="center">学院-2</td>
</tr>
</tbody></table>
<p>关系-12</p>
<table>
<thead>
<tr>
<th align="center">Sdept</th>
<th align="center">Mname</th>
</tr>
</thead>
<tbody><tr>
<td align="center">学院-1</td>
<td align="center">院长-1</td>
</tr>
<tr>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
</tr>
</tbody></table>
<h1 id="ER-图"><a href="#ER-图" class="headerlink" title="ER 图"></a>ER 图</h1><p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p>
<p>用来进行关系型数据库系统的概念设计。</p>
<h2 id="实体的三种联系"><a href="#实体的三种联系" class="headerlink" title="实体的三种联系"></a>实体的三种联系</h2><p>包含一对一，一对多，多对多三种。</p>
<ul>
<li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li>
<li>如果是一对一，画两个带箭头的线段；</li>
<li>如果是多对多，画两个不带箭头的线段。</li>
</ul>
<p>下图的 Course 和 Student 是一对多的关系。</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122154629.png"></p>
<h2 id="表示出现多次的关系"><a href="#表示出现多次的关系" class="headerlink" title="表示出现多次的关系"></a>表示出现多次的关系</h2><p>一个实体在联系出现几次，就要用几条线连接。</p>
<p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20200520092446.png"></p>
<h2 id="联系的多向性"><a href="#联系的多向性" class="headerlink" title="联系的多向性"></a>联系的多向性</h2><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20230412162952.png"></p>
<h2 id="表示子类"><a href="#表示子类" class="headerlink" title="表示子类"></a>表示子类</h2><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20230412163018.png"></p>
</br>
</br>]]></content>
      <categories>
        <category>专业知识</category>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 核心技术 - 分库分表</title>
    <url>/2021/09/25/cs-basic/cs-basic-middleware/cs-basic-middleware-mysql/MySQL%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%20-%20%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
    <content><![CDATA[<blockquote>
<p>怎么实现的分库分表</p>
</blockquote>
<h1 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h1><p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p>
<p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20230412162804.png"></p>
<h1 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h1><p>垂直切分是将一张表按列分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直气氛将经常被使用的列喝不经常被使用的列切分到不同的表中。</p>
<p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不通的库中，例如将原来电商数据部署库垂直切分称商品数据库、用户数据库等。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20230412162830.png"></p>
<h1 id="Sharding-策略"><a href="#Sharding-策略" class="headerlink" title="Sharding 策略"></a>Sharding 策略</h1><ul>
<li>哈希取模：hash(key)%N</li>
<li>范围：可以是 ID 范围也可以是时间范围</li>
<li>映射表：使用单独的一个数据库来存储映射关系</li>
</ul>
<h1 id="Sharding-存在的问题"><a href="#Sharding-存在的问题" class="headerlink" title="Sharding 存在的问题"></a>Sharding 存在的问题</h1><p><strong>事务问题</strong></p>
<p>使用分布式事务来解决，比如 XA 接口</p>
<p><strong>连接</strong></p>
<p>可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。</p>
<p><strong>唯一性</strong></p>
<ul>
<li><p>使用全局唯一 ID （GUID）</p>
</li>
<li><p>为每个分片指定一个 ID 范围</p>
</li>
<li><p>分布式 ID 生成器（如 Twitter 的 Snowflake 算法）</p>
</li>
<li><p><a href="https://xie.infoq.cn/article/200e90b980e8fec1ad6850878">Mysql 学习笔记：分库分表 (sharding)</a></p>
</li>
<li><p><a href="https://juejin.cn/post/6908220694929080333">炸！业界难题，跨库分页的几种常见方案</a></p>
</li>
<li><p><a href="https://xie.infoq.cn/article/10a98e12934a048ed80d36450">百亿级数据分表后怎么分页查询？</a></p>
</li>
</ul>
</br>
</br>]]></content>
      <categories>
        <category>专业知识</category>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 核心技术 - 性能优化</title>
    <url>/2021/09/25/cs-basic/cs-basic-middleware/cs-basic-middleware-mysql/MySQL%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%20-%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>在上一篇文章 <a href="https://haxianhe.com/2021/01/30/CS-Technical-mysql/break-mysql-index/">「《破壁MySQL》 - MySQL索引」</a> 中我们简单介绍了MySQL 索引的相关知识，那么在这一篇文章中我们主要介绍的是 <strong>MySQL 性能优化的常用方案</strong>，文章中在每介绍一部分知识点后都会给出<strong>知识点相对应的常见面试题以及答案</strong>，达到理论和实践相结合的效果。</p>
<blockquote>
<p><strong>面试题1: 分页查询到后期耗时很大怎么办？</strong></p>
</blockquote>
<p>Mysql的优化，大体可以分为三部分：索引的优化，sql语句的优化，表的优化</p>
<h1 id="优化慢查询的步骤"><a href="#优化慢查询的步骤" class="headerlink" title="优化慢查询的步骤"></a>优化慢查询的步骤</h1><p>0.先运行看看是否真的很慢，注意设置SQL_NO_CACHE</p>
<p>1.where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高</p>
<p>2.explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）</p>
<p>3.order by limit 形式的sql语句让排序的表优先查</p>
<p>4.了解业务方使用场景</p>
<p>5.加索引时参照建索引的几大原则</p>
<p>6.观察结果，不符合预期继续从0分析</p>
<h1 id="使用-explain-分析-select-查询语句"><a href="#使用-explain-分析-select-查询语句" class="headerlink" title="使用 explain 分析 select 查询语句"></a>使用 explain 分析 select 查询语句</h1><blockquote>
<p>explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p>
</blockquote>
<h2 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h2><p>常用的有 SIMPLE 简单查询，UNION 联合查询，SUBQUERY 子查询等。</p>
<h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><p>要查询的表</p>
<h2 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h2><blockquote>
<p>The possible indexes to choose</p>
</blockquote>
<p>可选择的索引</p>
<h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><blockquote>
<p>The index actually chosen</p>
</blockquote>
<p>实际使用的索引</p>
<h2 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h2><blockquote>
<p>Estimate of rows to be examined</p>
</blockquote>
<p>扫描的行数</p>
<h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>索引查询类型，经常用到的索引查询类型：</p>
<p><strong>const：使用主键或者唯一索引进行查询的时候只有一行匹配<br>ref：使用非唯一索引<br>range：使用主键、单个字段的辅助索引、多个字段的辅助索引的最后一个字段进行范围查询<br>index：和all的区别是扫描的是索引树<br>all：扫描全表：</strong></p>
<p><strong>system</strong></p>
<p><strong>触发条件：表只有一行，这是一个 const type 的特殊情况</strong></p>
<p><strong>const</strong></p>
<p><strong>触发条件：在使用主键或者唯一索引进行查询的时候只有一行匹配。</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> primary_key<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> primary_key_part1<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> primary_key_part2<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20230406195049.png"></p>
<p><strong>eq_ref</strong></p>
<p><strong>触发条件：在进行联接查询的，使用主键或者唯一索引并且只匹配到一行记录的时候</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ref_table,other_table</span><br><span class="line">  <span class="keyword">WHERE</span> ref_table.key_column<span class="operator">=</span>other_table.column;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ref_table,other_table</span><br><span class="line">  <span class="keyword">WHERE</span> ref_table.key_column_part1<span class="operator">=</span>other_table.column</span><br><span class="line">  <span class="keyword">AND</span> ref_table.key_column_part2<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>ref</strong></p>
<p>触发条件：使用非唯一索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ref_table <span class="keyword">WHERE</span> key_column<span class="operator">=</span>expr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ref_table,other_table</span><br><span class="line">  <span class="keyword">WHERE</span> ref_table.key_column<span class="operator">=</span>other_table.column;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ref_table,other_table</span><br><span class="line">  <span class="keyword">WHERE</span> ref_table.key_column_part1<span class="operator">=</span>other_table.column</span><br><span class="line">  <span class="keyword">AND</span> ref_table.key_column_part2<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20230406195118.png"></p>
<p><strong>range</strong></p>
<p><strong>触发条件：只有在使用主键、单个字段的辅助索引、多个字段的辅助索引的最后一个字段进行范围查询才是 range</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_column <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_column <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_column <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_part1 <span class="operator">=</span> <span class="number">10</span> <span class="keyword">AND</span> key_part2 <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20230406195142.png"></p>
<p><strong>index</strong></p>
<blockquote>
<p>The index join type is the same as ALL, except that the index tree is scanned. This occurs two ways:</p>
</blockquote>
<p>触发条件：</p>
<p>只扫描索引树</p>
<p>1）查询的字段是索引的一部分，覆盖索引。<br>2）使用主键进行排序</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20230406195205.png"></p>
<p><strong>all</strong></p>
<p>触发条件：全表扫描，不走索引</p>
<h1 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h1><p>关于索引原理在另一篇文章中有单独的介绍，这里就省略了。</p>
<h2 id="索引建立的原则"><a href="#索引建立的原则" class="headerlink" title="索引建立的原则"></a>索引建立的原则</h2><p>1.最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p>
<p>2.尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)&#x2F;count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。 </p>
<p>3.索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) &#x3D; ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time &#x3D; unix_timestamp(’2014-05-29’)。</p>
<p>4.&#x3D;和in可以乱序，比如a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p>
<p>5.尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p>
<h2 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h2><p><strong>索引不能是表达式的一部分</strong></p>
<p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p>
<p>例如下面的查询不能使用 actor_id 列的索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h2 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h2><p><strong>多个字段最好建立联合索引</strong></p>
<p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, actor_ id <span class="keyword">FROM</span> sakila.film_actor</span><br><span class="line"><span class="keyword">WHERE</span> actor_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> film_id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="索引列的顺序"><a href="#索引列的顺序" class="headerlink" title="索引列的顺序"></a>索引列的顺序</h2><p>让选择性最强的索引列放在前面。</p>
<p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p>
<p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> staff_id)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> staff_id_selectivity,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> customer_id)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> customer_id_selectivity,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> payment;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">   staff_id_selectivity: 0.0001</span><br><span class="line">customer_id_selectivity: 0.0373</span><br><span class="line">               COUNT(*): 16049</span><br></pre></td></tr></table></figure>

<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>索引包含所有需要查询的字段的值。</p>
<p>具有以下优点：</p>
<ul>
<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li>
<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>
<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li>
</ul>
<h2 id="不走索引的情况"><a href="#不走索引的情况" class="headerlink" title="不走索引的情况"></a>不走索引的情况</h2><ul>
<li>如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)</li>
<li>对于联合索引，不是使用的第一部分(第一个)，则不会使用索引</li>
<li>like查询是以%开头</li>
<li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引（值类型不同）</li>
</ul>
<h1 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h1><h2 id="减少请求的数据量"><a href="#减少请求的数据量" class="headerlink" title="减少请求的数据量"></a>减少请求的数据量</h2><ul>
<li>只返回必要的列：最好不要使用 SELECT * 语句。</li>
<li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li>
<li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li>
</ul>
<h2 id="减少服务器端扫描的行数"><a href="#减少服务器端扫描的行数" class="headerlink" title="减少服务器端扫描的行数"></a>减少服务器端扫描的行数</h2><p>最有效的方式是使用索引来覆盖查询。</p>
<h1 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h1><h2 id="切分大查询"><a href="#切分大查询" class="headerlink" title="切分大查询"></a>切分大查询</h2><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> messages <span class="keyword">WHERE</span> <span class="keyword">create</span> <span class="operator">&lt;</span> DATE_SUB(NOW(), <span class="type">INTERVAL</span> <span class="number">3</span> <span class="keyword">MONTH</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">rows_affected <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">do &#123;</span><br><span class="line">    rows_affected <span class="operator">=</span> do_query(</span><br><span class="line">    &quot;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;)</span><br><span class="line">&#125; while rows_affected <span class="operator">&gt;</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="分解大连接查询"><a href="#分解大连接查询" class="headerlink" title="分解大连接查询"></a>分解大连接查询</h2><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p>
<ul>
<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li>
<li>减少锁竞争；</li>
<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li>
<li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag</span><br><span class="line"><span class="keyword">JOIN</span> tag_post <span class="keyword">ON</span> tag_post.tag_id<span class="operator">=</span>tag.id</span><br><span class="line"><span class="keyword">JOIN</span> post <span class="keyword">ON</span> tag_post.post_id<span class="operator">=</span>post.id</span><br><span class="line"><span class="keyword">WHERE</span> tag.tag<span class="operator">=</span><span class="string">&#x27;mysql&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag<span class="operator">=</span><span class="string">&#x27;mysql&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id<span class="operator">=</span><span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post.id <span class="keyword">IN</span> (<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>,<span class="number">9098</span>,<span class="number">8904</span>);</span><br></pre></td></tr></table></figure>


</br>
</br>]]></content>
      <categories>
        <category>专业知识</category>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 核心技术 - 概述</title>
    <url>/2021/09/25/cs-basic/cs-basic-middleware/cs-basic-middleware-mysql/MySQL%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%20-%20%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<blockquote>
<p>文章每周六持续更新，可以微信搜一搜「 荒古传说 」抢先阅读。</p>
</blockquote>
<p>在正式开始总结MySQL之前，先给大家介绍一下“破壁”是什么意思，很久之前我老大曾说过一句 <strong>“互联网本来没有什么行业壁垒，但是通过制造一些专业名词，人为的制造了很多行业壁垒出来”</strong>，我深以为然。  </p>
<p><strong>计算机的本质是0和1</strong>，之后通过层层封装、抽象构建出了我们今天看到的互联网世界。	</p>
<p>我不否认计算机中难度很高的知识，但是就我目前接触到的知识来说还没有到那种程度，我想这种可以称之为行业壁垒的核心知识占总知识量的0.01%都不到，绝大多数人一生都不会遇到这些问题。</p>
<p>那么剩下的就是这一个一个人为制造的、可以通过花时间掌握的“行业壁垒”。</p>
<p><strong>破壁的意思就是打破这些人为制造的“行业壁垒”</strong>，让我们技术人员人人如龙。</p>
<hr>
<p><strong>破壁系列的第一个专题我选择了互联网的数据存储基石 - MySQL。</strong></p>
<p>这个专题将会总结事务、索引、SQL性能优化、分库分表、主从复制等MySQL核心内容。详情参见下面的思维导图：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20230406193419.png"></p>
<h2 id="MySQL-是什么"><a href="#MySQL-是什么" class="headerlink" title="MySQL 是什么"></a>MySQL 是什么</h2><p>MySQL 是一个免费、开源的关系型数据库管理软件，在互联网行业被广泛使用。</p>
<h2 id="MySQL-架构"><a href="#MySQL-架构" class="headerlink" title="MySQL 架构"></a>MySQL 架构</h2><p>MySQL中插件式存储引擎架构一直是其非常有特色的亮点，其灵活的处理方式，高度可定制化及完全开放的实现一直被很多高级用户所肯定，下图是官方文档中的一张架构图：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20230406193442.png"></p>
<ul>
<li><p>连接层：<strong>这一层主要是提供授权认证、连接处理等功能。</strong> </p>
<ul>
<li>在该层上引入了线程池的概念，为通过安全认证的客户端请求提供线程。</li>
<li>在该层上也可以实现基于SSL的安全链接。</li>
<li>该层会为通过授权认证的客户端请求分配相应的权限。</li>
</ul>
</li>
<li><p>服务层：这一层实现了很多核心功能，像<strong>查询解析、分析、优化、缓存、以及内置函数</strong>的实现等，所有跨存储引擎的功能也都在这一层实现，像<strong>触发器、存储过程、视图</strong>等。</p>
</li>
<li><p>引擎层：存储引擎负责的是MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。MySQL中插件式存储引擎架构的特点，使得我们可以根据自己的实际需要进行存储引擎的选取。</p>
</li>
<li><p>存储层：将数据存储在文件系统上。</p>
</li>
</ul>
<p><strong>常见面试题：</strong></p>
<blockquote>
<p>MySQL 的查询流程具体是？or 一条 SQL 语句在 MySQL 中如何执行的？<br>介绍一下 MySQL 的架构</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20230406193508.png"></p>
<ol>
<li>客户发起请求。</li>
<li>在连接层进行权限校验、线程分配。</li>
<li>查询缓存（存在缓存则直接返回，不存在则执行后续操作）</li>
<li>分析器（对SQL进行词法分析和语法分析操作）</li>
<li>优化器（主要对执行的sql优化选择最优的执行方案方法）</li>
<li>执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）</li>
<li>去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）</li>
</ol>
<h2 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h2><p>MySQL中采用的是插件式存储引擎架构，可以根据需要选择不同的存储引擎。</p>
<p>现在互联网普遍使用的都是 InnoDB 存储引擎，常见的面试题是 InnoDB 存储引擎和 MyISAM 存储的对比，比如像下面这样问：</p>
<blockquote>
<p>Innodb 和 MyISAM 的区别是什么?</p>
</blockquote>
<p>可以从如下的角度进行回答：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20230406193534.png"></p>
<ul>
<li>事务：InnoDB 支持事务，MyISAM 不支持事务</li>
<li>锁：InnoDB 支持行级锁，MyISAM 只支持表级锁</li>
<li>外键：InnoDB 支持外键</li>
<li>InnoDB 支持在线热备份</li>
<li>MyISAM 支持空间索引</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>MySQL 是现在互联网大小厂主流使用的关系型数据库管理软件，平时工作中也是围绕着它进行开发，所以几乎是面试必考题。</p>
<p>这篇文章是《破壁》系列，第一个专题的第一篇文章，下面是本系列的其他文章，欢迎阅读～</p>
<ul>
<li><a href="https://haxianhe.com/2021/01/09/CS-Technical-mysql/break-mysql-overview/">《破壁MySQL》 - MySQL概述</a></li>
<li><a href="https://haxianhe.com/2021/01/30/CS-Technical-mysql/break-mysql-index/">《破壁MySQL》 - MySQL索引</a></li>
</ul>
<p>文章中首先介绍了一下我接下来要写的内容（第一个专题 MySQL），其次是从技术原理和面试题两个角度介绍了 MySQL 架构和 MySQL 存储引擎。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/">官方文档</a></li>
<li><a href="https://juejin.cn/post/6850037271233331208">MySQL 三万字精华总结</a></li>
</ul>
<hr>
<blockquote>
<p>文章每周六持续更新，可以微信搜一搜「 荒古传说 」抢先阅读。</p>
</blockquote>
</br>
</br>]]></content>
      <categories>
        <category>专业知识</category>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 核心技术 - 索引</title>
    <url>/2021/09/25/cs-basic/cs-basic-middleware/cs-basic-middleware-mysql/MySQL%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%20-%20%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<blockquote>
<p>文章每周六持续更新，可以微信搜一搜「 荒古传说 」抢先阅读。</p>
</blockquote>
<p>在上一篇文章 <a href="https://haxianhe.com/2021/01/09/CS-Technical-mysql/break-mysql-overview/">「《破壁MySQL》 - MySQL概述」</a> 中我们简单介绍了MySQL 架构和 MySQL 存储引擎的相关知识，那么在这一篇文章中我们主要介绍的是 <strong>InnoDB存储引擎的索引实现原理</strong>，文章中在每介绍一部分知识点后都会给出<strong>知识点相对应的常见面试题以及答案</strong>，达到理论和实践相结合的效果。</p>
<blockquote>
<p><strong>面试题1：说说你对 MySQL 索引的理解？&#x2F;InnoDB引擎中的索引策略，了解过吗？</strong></p>
</blockquote>
<h2 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h2><p>索引（Index）是帮助MySQL高效获取数据的数据结构，所以说<strong>索引的本质是：数据结构</strong>。</p>
<p><strong>索引的目的在于提高查询效率</strong>，可以类比字典、 火车站的车次表、图书的目录等</p>
<h2 id="B-Tree-原理"><a href="#B-Tree-原理" class="headerlink" title="B+ Tree 原理"></a>B+ Tree 原理</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>B Tree 指的是 Balance Tree，也就是平衡树，平衡树是一颗查找树，并且所有叶子节点位于同一层。</p>
<p><strong>B+ Tree 是 B 树的一种变形，它是基于 B Tree 和叶子节点顺序访问指针进行实现，通常用于数据库和操作系统的文件系统中。</strong> </p>
<p>B+ 树有两种类型的节点：<strong>内部节点</strong>（也称索引节点）和<strong>叶子节点。</strong></p>
<p>内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存在叶子节点。</p>
<p>内部节点中的 key 都按照从小到大的顺序排列，对于内部节点中的一个 key，左子树中的所有 key 都小于它，右子树中的 key 都大于等于它，叶子节点的记录也是按照从小到大排列的。</p>
<p>每个叶子节点都存有相邻叶子节点的指针。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20230406194149.png"></p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p><strong>查找</strong></p>
<p>查找以典型的方式进行，类似于二叉查找树。起始于根节点，自顶向下遍历树，选择其分离值在要查找值的任意一边的子指针。在节点内部典型的使用是二分查找来确定这个位置。</p>
<p><strong>插入</strong></p>
<ul>
<li><p>Perform a search to determine what bucket the new record should go into.</p>
</li>
<li><p>If the bucket is not full(a most b - 1 entries after the insertion，b 是节点中的元素个数，一般是页的整数倍),add tht record.</p>
</li>
<li><p>Otherwise,before inserting the new record</p>
<ul>
<li>split the bucket.<ul>
<li>original node has 「(L+1)&#x2F;2」items</li>
<li>new node has 「(L+1)&#x2F;2」items</li>
</ul>
</li>
<li>Move  「(L+1)&#x2F;2」-th key to the parent,and insert the new node to the parent.</li>
<li>Repeat until a parent is found that need not split.</li>
</ul>
</li>
<li><p>If the root splits,treat it as if it has an empty parent ans split as outline above.</p>
</li>
</ul>
<p>B-trees grow as the root and not at the leaves.</p>
<p><strong>删除</strong></p>
<p>和插入类似，只不过是自下而上的合并操作。</p>
<h3 id="常见树介绍"><a href="#常见树介绍" class="headerlink" title="常见树介绍"></a>常见树介绍</h3><p><strong>AVL 树</strong></p>
<p>平衡二叉树，一般是用平衡因子差值决定并通过旋转来实现，左右子树树高差不超过1，那么和红黑树比较它是严格的平衡二叉树，平衡条件非常严格（树高差只有1），只要插入或删除不满足上面的条件就要通过旋转来保持平衡。由于旋转是非常耗费时间的。所以 AVL 树适用于插入&#x2F;删除次数比较少，但查找多的场景。</p>
<p><strong>红黑树</strong></p>
<p>通过对从根节点到叶子节点路径上各个节点的颜色进行约束，确保没有一条路径会比其他路径长2倍，因而是近似平衡的。所以相对于严格要求平衡的AVL树来说，它的旋转保持平衡次数较少。适合，查找少，插入&#x2F;删除次数多的场景。（现在部分场景使用跳表来替换红黑树，可搜索“为啥 redis 使用跳表(skiplist)而不是使用 red-black？”）</p>
<p><strong>B&#x2F;B+ 树</strong></p>
<p>多路查找树，出度高，磁盘IO低，一般用于数据库系统中。</p>
<blockquote>
<p><strong>面试题2：B+ 树和 B 树的区别是什么？</strong></p>
</blockquote>
<h3 id="B-树与-B-树的比较"><a href="#B-树与-B-树的比较" class="headerlink" title="B + 树与 B 树的比较"></a>B + 树与 B 树的比较</h3><ul>
<li>B+ 树的内部节点并没有指向关键字具体信息的指针</li>
<li>B+ 树的叶子节点具有指向左右叶子节点的指针</li>
</ul>
<p>B+ 树的磁盘 IO 更低</p>
<p>B+ 树的内部节点并没有指向关键字具体信息的指针。因此其内部节点相对 B 树更小。</p>
<p>如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p>
<p>B+ 树的范围查询、遍历效率高</p>
<p>B+ 树的叶子节点具有指向左右叶子节点的指针。因此其范围查询效率更高、遍历效率更高。</p>
<p>B+ 树的查询效率更加稳定</p>
<p>由于非叶子结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
<h3 id="B-树与红黑树的比较"><a href="#B-树与红黑树的比较" class="headerlink" title="B + 树与红黑树的比较"></a>B + 树与红黑树的比较</h3><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：</p>
<p>（一）磁盘 IO 次数</p>
<p>B+ 树一个节点可以存储多个元素，相对于红黑树的树高更低，磁盘 IO 次数更少。</p>
<p>（二）磁盘预读特性</p>
<p>为了减少磁盘 I&#x2F;O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道。每次会读取页的整数倍。</p>
<p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I&#x2F;O 就能完全载入一个节点。</p>
<h2 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h2><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>
<h3 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B+ Tree 索引"></a>B+ Tree 索引</h3><p>是大多数 MySQL 存储引擎的默认索引类型。</p>
<ul>
<li><p>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</p>
</li>
<li><p>因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。</p>
</li>
<li><p>可以指定多个列作为索引列，多个索引列共同组成键。</p>
</li>
<li><p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p>
</li>
</ul>
<p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20230406194216.png"></p>
<p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找，这个过程也被称作回表。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20230406194239.png"></p>
<blockquote>
<p><strong>面试题3：分页SQL后期查询比较慢是什么原因？怎么处理？</strong></p>
</blockquote>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> type <span class="operator">=</span> <span class="number">1</span> limit <span class="number">0</span>,<span class="number">10</span> </span><br></pre></td></tr></table></figure>

<p>这个没有问题，但是当进入分页后期就有问题了，比如下面这条sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> type <span class="operator">=</span> <span class="number">1</span> limit <span class="number">100000</span>,<span class="number">10</span> </span><br></pre></td></tr></table></figure>

<p>首先你需要了解B+树的实现原理，当做数据量比较大的分页的时候：</p>
<ol>
<li>（根据索引）找到起始位置（叶子结点）</li>
<li><strong>沿着叶子结点向后遍历，过滤掉前面不在本次返回范围内的数据</strong></li>
<li>找到目标数据后返回</li>
</ol>
<p>从上述过程中可以看到，后期的主要耗时都在沿着叶子结点遍历上边，那么有没有什么方案可以省去这部分耗时呢？</p>
<p>有的，可以每次遍历结束后记录一下本页id最大值，然后在下一轮查询的时候，在where条件中加上这个id限制，这样可以保证每次查询速度都和第一页保持一致了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> type <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> id <span class="operator">&gt;</span> max_id limit <span class="number">100000</span>,<span class="number">10</span> </span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>面试题4：什么是覆盖索引？</strong></p>
</blockquote>
<p>覆盖索引是要查询的数据列只从索引中就能够取得，不必回表查询主索引树。</p>
<p>要回答好这个问题，需要你了解上面介绍的B+树的实现原理，理解了原理回答起来就简单了。</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p>
<ul>
<li>无法用于排序与分组；</li>
<li>只支持精确查找，无法用于部分查找和范围查找。</li>
</ul>
<p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p>
<p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p>
<p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>
<p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p>
<h3 id="空间数据索引"><a href="#空间数据索引" class="headerlink" title="空间数据索引"></a>空间数据索引</h3><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>
<p>必须使用 GIS 相关的函数来维护数据。</p>
<h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><ul>
<li><p>大大减少了服务器需要扫描的数据行数。</p>
</li>
<li><p>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</p>
</li>
<li><p>将随机 I&#x2F;O 变为顺序 I&#x2F;O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</p>
</li>
</ul>
<h3 id="索引的使用条件"><a href="#索引的使用条件" class="headerlink" title="索引的使用条件"></a>索引的使用条件</h3><ul>
<li><p>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</p>
</li>
<li><p>对于中到大型的表，索引就非常有效；</p>
</li>
<li><p>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</p>
</li>
</ul>
<blockquote>
<p><strong>为什么对于非常小的表，大部分情况下简单的全表扫描比建立索引更高效？</strong></p>
</blockquote>
<p>如果一个表比较小，那么显然直接遍历表比走索引要快（因为需要回表）。</p>
<p>注：首先，要注意这个答案隐含的条件是查询的数据不是索引的构成部分，否也不需要回表操作。其次，查询条件也不是主键，否则可以直接从聚簇索引中拿到数据。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章是《破壁》系列的第二篇文章，主要介绍了一下索引相关内容。</p>
<ul>
<li><a href="https://haxianhe.com/2021/01/09/CS-Technical-mysql/break-mysql-overview/">《破壁MySQL》 - MySQL概述</a></li>
<li><a href="https://haxianhe.com/2021/01/30/CS-Technical-mysql/break-mysql-index/">《破壁MySQL》 - MySQL索引</a></li>
</ul>
<p>文中首先从<strong>数据结构</strong>、<strong>操作</strong>、<strong>常见树的比较等</strong>角度介绍了 <strong>B+ 树相关的原理知识</strong>。</p>
<p>其次着重介绍了一下 *<em>InnoDB 的 B+ 索引的实现原理</em>***。</p>
<hr>
<p>老规矩，文中出现的面试题如下：</p>
<ul>
<li>面试题1：说说你对 MySQL 索引的理解？&#x2F;InnoDB引擎中的索引策略，了解过吗？</li>
<li>面试题2：B+ 树和 B 树的区别是什么？</li>
<li>面试题3：分页SQL后期查询比较慢是什么原因？怎么处理？</li>
<li>面试题4：什么是覆盖索引？</li>
</ul>
<p>上面所有面试题都是在文中出现过的，如果如果答不上来可以回到文中再看一下答案以及相应的知识点。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/">官方文档</a></li>
<li><a href="https://juejin.cn/post/6850037271233331208">MySQL 三万字精华总结</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#b-tree-%E5%8E%9F%E7%90%86">CS-Notes-MySQL</a></li>
</ul>
<hr>
<blockquote>
<p>文章每周六持续更新，可以微信搜一搜「 荒古传说 」抢先阅读。</p>
</blockquote>
</br>
</br>]]></content>
      <categories>
        <category>专业知识</category>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>一个死锁的case</title>
    <url>/2021/09/16/cs-basic/cs-basic-middleware/cs-basic-middleware-mysql/%E4%B8%80%E4%B8%AA%E6%AD%BB%E9%94%81%E7%9A%84case/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>今天线上流水的consumer出现了一个insert导致的死锁问题，这里通过一个DEMO复现一下case的整个过程，并进行详细的分析。</p>
<p>表结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show create table test_table;</span><br><span class="line">| Table      | Create Table                                                                                </span><br><span class="line">| test_table | CREATE TABLE `test_table` (</span><br><span class="line">  `id` int NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `a` int NOT NULL,</span><br><span class="line">  `b` int DEFAULT &#x27;0&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `test_table_a_uindex` (`a`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=51 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |</span><br><span class="line"></span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>表数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from test_table;</span><br><span class="line">+----+----+------+</span><br><span class="line">| id | a  | b    |</span><br><span class="line">+----+----+------+</span><br><span class="line">|  1 |  1 |    1 |</span><br><span class="line">| 20 | 20 |   20 |</span><br><span class="line">| 50 | 50 |   50 |</span><br><span class="line">+----+----+------+</span><br><span class="line">3 rows in set (0.02 sec)</span><br></pre></td></tr></table></figure>

<p><strong>事务中的代码是先update，如果记录不存在再去insert。</strong></p>
<p>事务1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update test_table set b = 1 where a = 30;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Rows matched: 0  Changed: 0  Warnings: 0</span><br></pre></td></tr></table></figure>

<p>事务1开启事务，并update一条不存在的记录（此时会对a，[20,50]加间隙锁）。</p>
<p>事务2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update test_table set b = 1 where a = 31;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Rows matched: 0  Changed: 0  Warnings: 0</span><br></pre></td></tr></table></figure>

<p>事务2开启事务，并update一条不存在的记录（此时同样会对a，[20,50加间隙锁]）。</p>
<p>事务1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into test_table values(30,30,1);</span><br><span class="line">mysql&gt; waiting...</span><br></pre></td></tr></table></figure>

<p>事务1插入一条记录，此时会被阻塞…</p>
<p>事务2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ysql&gt; insert into test_table values(31,31,1);</span><br><span class="line">ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</span><br></pre></td></tr></table></figure>

<p>事务2同样插入一条记录，此时会报错，死锁，并回滚事务。</p>
<p>事务1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into test_table values(30,30,1);</span><br><span class="line">Query OK, 1 row affected (12.58 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>事务2回滚后，事务1插入成功，事务提交成功。</p>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>1.事务1、事务2中分别进行了一次update操作，并且操作的记录都不存在，此时，事务1、2分别会对a，[20,50]范围加一个间隙锁。</p>
<p>注：间隙锁与间隙锁之间可以兼容（共享锁）</p>
<p>2.事务1中进行了一次insert操作，此时由于事务2对a，[20,50]范围加了一个间隙锁，所以事务1的insert操作处于阻塞状态。</p>
<p>3.事务2中也进行了一次insert操作，同样被事务1的间隙锁阻塞。<strong>此时事务1在等事务2释放间隙锁，而事务2也在等事务1释放间隙锁，构成死锁，所以事务2报错“死锁”并进行事务回滚。</strong></p>
<p>4.事务2回滚后，事务2的间隙锁被释放，事务1的insert操作执行成功，事务1提交成功。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>考虑了两种解决方案：</p>
<p><strong>方案一</strong></p>
<p>将事务中的插入操作提到事务之前执行，每次事务开始前先select一下，如果记录不存在插入一条空记录进去，在事务中只需要执行update操作。</p>
<p>缺点：多进行了一次select操作，可能对接口性能造成影响，需要重新进行压测判断。</p>
<p><strong>方案二</strong></p>
<p>降低mysql事务隔离级别，从RR下调到RC。</p>
<p>缺点：存在幻读问题</p>
<p>综合考虑，由于这个集群只用于流水和统计数据的存储，所以采用了 <strong>方案二：调低事务隔离级别</strong>。</p>
<h1 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h1><p><strong>InnoDB中RR隔离级别是否存在幻读问题？</strong></p>
<p>回答这个问题前，我先假设你知道<strong>数据库隔离级别的定义针对的都是“当前读”</strong>。</p>
<p>首先我们来看一段InnoDB官方文档的话：</p>
<blockquote>
<p>For locking reads (SELECT with FOR UPDATE or LOCK IN SHARE MODE), UPDATE, and DELETE statements, locking depends on whether the statement uses a unique index with a unique search condition, or a range-type search condition. For a unique index with a unique search condition, InnoDB locks only the index record found, not the gap before it. For other search conditions, InnoDB locks the index range scanned, using gap locks or next-key locks to block insertions by other sessions into the gaps covered by the range.</p>
</blockquote>
<p>大致意思就是，在 RR 级别下，如果查询条件能使用上唯一索引，或者是一个唯一的查询条件，那么仅加行锁，如果是一个范围查询，那么就会给这个范围加上 gap 锁或者 next-key锁 (行锁+gap锁)。</p>
<p>InnoDB 的 RR 隔离界别对范围会加上 GAP，不会存在幻读。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>事务最好不要太长，否则容易出现锁等待、死锁等问题</li>
<li>insert操作最好不要放到事务里，否则容易引发死锁问题（相互等待）。</li>
</ul>
</br>
</br>]]></content>
      <categories>
        <category>专业知识</category>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么MySQL字段要设置为NOT NULL?</title>
    <url>/2020/05/16/cs-basic/cs-basic-middleware/cs-basic-middleware-mysql/%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E5%AD%97%E6%AE%B5%E8%A6%81%E8%AE%BE%E7%BD%AE%E4%B8%BANOT-NULL/</url>
    <content><![CDATA[<p>平时开发过程中，MySQL 字段的一般都会设置为NOT NULL，原因如下：</p>
<p><strong>1、空值(“”) 和 “NULL” 的区别：</strong></p>
<ol>
<li>空值是不占用空间的</li>
<li>MySQL中的NULL其实是占用空间的</li>
</ol>
<blockquote>
<p>NULL columns require additional space in the row to record whether their values are NULL. For MyISAM tables, each NULL column takes one bit extra, rounded up to the nearest byte.</p>
</blockquote>
<p>所谓的NULL就是什么都没有，连\0都没有，\0在字符串中是结束符，但是在物理内存是占空间的，等于一个字节，而NULL就是连这一个字节都没有。</p>
<p><strong>2、不利于查询优化</strong></p>
<p>如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL的列会使索引、索引统计和值比较都更复杂。</p>
<p>当可为NULL的列被索引时，每个索引记录需要一个额外的字节，在MyISAM里面甚至可能导致固定大小的索引（例如只有一个整数列的索引）变成可变大小的索引。</p>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://www.jianshu.com/p/766ccd8d216e">MySQL 数据库优化之字段尽量避免NULL</a></li>
<li><a href="https://www.cnblogs.com/liaokaichang/p/7879010.html">MySQL字段属性应该尽量设置为NOT NULL</a></li>
</ul>
]]></content>
      <categories>
        <category>专业知识</category>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么对于非常小的表，大部分情况下简单的全表扫描比建立索引更高效？</title>
    <url>/2020/05/10/cs-basic/cs-basic-middleware/cs-basic-middleware-mysql/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AF%B9%E4%BA%8E%E9%9D%9E%E5%B8%B8%E5%B0%8F%E7%9A%84%E8%A1%A8%EF%BC%8C%E5%A4%A7%E9%83%A8%E5%88%86%E6%83%85%E5%86%B5%E4%B8%8B%E7%AE%80%E5%8D%95%E7%9A%84%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F%E6%AF%94%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E6%9B%B4%E9%AB%98%E6%95%88%EF%BC%9F/</url>
    <content><![CDATA[<blockquote>
<p>最近刚刚和泽康和素鑫聊过这个问题，这里简单整理一下。</p>
</blockquote>
<p>标题中的 <strong>‘对于非常小的表，大部分情况下简单的全表扫描比建立索引更高效’</strong> ，其实是问题 <strong>‘索引的使用条件’</strong> 的答案的一部分。完整答案是：</p>
<ul>
<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效</li>
<li>对于中到大型的表，索引就非常有效；</li>
</ul>
<p>那么为什么对于非常小的表，大部分情况下简单的全表扫描比建立索引更高效呢？理由如下：</p>
<p>MySQL的默认存储引擎是InnoDB，在InnoDB中索引是通过 B+ 树实现的，MySQL的数据是存储在聚簇索引（聚簇索引也叫主键索引、一级索引）的叶子节点上。</p>
<p>在辅助索引（包括唯一索引和非唯一索引）的的叶子节点上存储着构成索引的字段和主键。</p>
<p>如果查询的字段不是索引的组成部分，就需要拿着从辅助索引中查到的主键值去聚簇索引中查询数据，这个过程也叫做回表。</p>
<p>所以，如果一个表比较小，那么显然直接遍历表比走索引要快（因为需要回表）。</p>
<blockquote>
<p><strong>注：首先，要注意这个答案隐含的条件是查询的数据不是索引的构成部分，否也不需要回表操作。其次，查询条件也不是主键，否则可以直接从聚簇索引中拿到数据。</strong></p>
</blockquote>
<p>这里有一个概念这里简单总结一下：</p>
<p><strong>B+Tree 索引</strong></p>
<p>是大多数 MySQL 存储引擎的默认索引类型。</p>
<p>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</p>
<p>因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。</p>
<p>可以指定多个列作为索引列，多个索引列共同组成键。</p>
<p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p>
<p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20200510142905.png"></p>
<p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20200510143156.png"></p>
<p><strong>覆盖索引</strong></p>
<p>索引包含所有需要查询的字段的值。</p>
<p>具有以下优点：</p>
<ul>
<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li>
<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>
<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引（无需回表）。</li>
</ul>
<p><strong>索引的使用条件</strong></p>
<ul>
<li><p>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</p>
</li>
<li><p>对于中到大型的表，索引就非常有效；</p>
</li>
<li><p>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>专业知识</category>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ（1）：安装、使用教程</title>
    <url>/2018/12/14/cs-basic/cs-basic-middleware/cs-basic-middleware-rabbitmq/RabbitMQ%EF%BC%881%EF%BC%89%EF%BC%9A%E5%AE%89%E8%A3%85%E3%80%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>rabbitmq官网支持各种操作系统的下载安装。</p>
<p><a href="http://www.rabbitmq.com/download.html">rabbitmq 官网下载</a></p>
<p>因为我用的是MAC OS所以我简单记录一下在mac上的安装、使用。</p>
<h1 id="使用Homebrew安装RabbitMQ"><a href="#使用Homebrew安装RabbitMQ" class="headerlink" title="使用Homebrew安装RabbitMQ"></a>使用Homebrew安装RabbitMQ</h1><p>在安装前，先更新一下brew，确保软件版本是最新的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew update</span><br></pre></td></tr></table></figure>

<p>使用下面的命令安装rabbitmq</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install rabbitmq</span><br></pre></td></tr></table></figure>
<p>安装rabbitmq的过程中会安装相关的依赖。</p>
<p>使用Hemobrew安装的RabbitMQ的安装目录位于 <em>&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;版本号&#x2F;</em> </p>
<p>在 <em>&#x2F;user&#x2F;local&#x2F;sbin</em> 有rabbitmq server scripts 和 CTL tools 软链接。</p>
<h1 id="RabbitMQ的启动-使用"><a href="#RabbitMQ的启动-使用" class="headerlink" title="RabbitMQ的启动&amp;使用"></a>RabbitMQ的启动&amp;使用</h1><p>rabbitmq的官方文档对rabbitmq的方方面面有详尽的介绍。</p>
<p><a href="http://www.rabbitmq.com/documentation.html">rabbitmq 官方文档</a></p>
<p><a href="http://www.rabbitmq.com/cli.html">rabbitmqctl 文档</a></p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>启动很简单，找到安装后的 RabbitMQ 所在目录下的 sbin 目录，可以看到该目录下有6个以 rabbitmq 开头的可执行文件，直接执行 rabbitmq-server 即可，下面将 RabbitMQ 的安装位置以 . 代替，启动命令就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./sbin/rabbitmq-server</span><br></pre></td></tr></table></figure>
<p>启动正常的话会看到一些启动过程信息和最后的 completed with 7 plugins，这也说明启动的时候默认加载了6个插件。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNc79gy1fz9f0t94ikj319s0dejv5.jpg"></p>
<h2 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a>后台启动</h2><p>如果想让 RabbitMQ 以守护程序的方式在后台运行，可以在启动的时候加上 -detached 参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./sbin/rabbitmq-server -detached</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>专业知识</category>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ（2）：AMQP 0-9-1 和 AMQP 模型高阶概述</title>
    <url>/2018/12/17/cs-basic/cs-basic-middleware/cs-basic-middleware-rabbitmq/RabbitMQ%EF%BC%882%EF%BC%89%EF%BC%9AAMQP-0-9-1-%E5%92%8C-AMQP-%E6%A8%A1%E5%9E%8B%E9%AB%98%E9%98%B6%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="AMQP是什么"><a href="#AMQP是什么" class="headerlink" title="AMQP是什么"></a>AMQP是什么</h1><p>AMQP（高级消息队列协议）是一个网络协议。它支持符合要求的客户端应用（application）和消息中间件代理（messaging middleware broker）之间进行通信。</p>
<h1 id="消息代理和他们所扮演的角色"><a href="#消息代理和他们所扮演的角色" class="headerlink" title="消息代理和他们所扮演的角色"></a>消息代理和他们所扮演的角色</h1><p>消息代理（message brokers）从发布者（publishers）亦称生产者（producers）那儿接收消息，并根据既定的路由规则把接收到的消息发送给处理消息的消费者（consumers）。</p>
<p>由于AMQP是一个网络协议，所以这个过程中的发布者，消费者，消息代理 可以存在于不同的设备上。</p>
<h1 id="AMQP-0-9-1-模型简介"><a href="#AMQP-0-9-1-模型简介" class="headerlink" title="AMQP 0-9-1 模型简介"></a>AMQP 0-9-1 模型简介</h1><p>AMQP 0-9-1的工作过程如下图：消息（message）被发布者（publisher）发送给交换机（exchange），交换机常常被比喻成邮局或者邮箱。然后交换机将收到的消息根据路由规则分发给绑定的队列（queue）。最后AMQP代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwgy1fy9jc7r3e3j30jg094mxs.jpg"></p>
<p>发布者（publisher）发布消息时可以给消息指定各种消息属性（message meta-data）。有些属性有可能会被消息代理（brokers）使用，然而其他的属性则是完全不透明的，它们只能被接收消息的应用所使用。</p>
<p>从安全角度考虑，网络是不可靠的，接收消息的应用也有可能在处理消息的时候失败。基于此原因，AMQP模块包含了一个消息确认（message acknowledgements）的概念：当一个消息从队列中投递给消费者后（consumer），消费者会通知一下消息代理（broker），这个可以是自动的也可以由处理消息的应用的开发者执行。当“消息确认”被启用的时候，消息代理不会完全将消息从队列中删除，直到它收到来自消费者的确认回执（acknowledgement）。</p>
<p>在某些情况下，例如当一个消息无法被成功路由时，消息或许会被返回给发布者并被丢弃。或者，如果消息代理执行了延期操作，消息会被放入一个所谓的死信队列中。此时，消息发布者可以选择某些参数来处理这些特殊情况。</p>
<p>队列，交换机和绑定统称为AMQP实体（AMQP entities）。</p>
<h1 id="AMQP是一个可编的程协议"><a href="#AMQP是一个可编的程协议" class="headerlink" title="AMQP是一个可编的程协议"></a>AMQP是一个可编的程协议</h1><p>AMQP 0-9-1是一个可编程协议，某种意义上说AMQP的实体和路由规则是由应用本身定义的，而不是由消息代理定义。包括像声明队列和交换机，定义他们之间的绑定，订阅队列等等关于协议本身的操作。</p>
<p>这虽然能让开发人员自由发挥，但也需要他们注意潜在的定义冲突。当然这在实践中很少会发生，如果发生，会以配置错误（misconfiguration）的形式表现出来。</p>
<p>应用程序（Applications）声明AMQP实体，定义需要的路由方案，或者删除不再需要的AMQP实体。</p>
<h1 id="交换机和交换机类型"><a href="#交换机和交换机类型" class="headerlink" title="交换机和交换机类型"></a>交换机和交换机类型</h1><p>交换机是用来发送消息的AMQP实体。交换机拿到一个消息之后将它路由给一个或零个队列。它使用哪种路由算法是由交换机类型和被称作绑定（bindings）的规则所决定的。AMQP 0-9-1的代理提供了四种交换机</p>
<table>
<thead>
<tr>
<th><strong>Name（交换机类型）</strong></th>
<th><strong>Default pre-declared names（预声明的默认名称）</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Direct exchange（直连交换机）</td>
<td>(Empty string) and amq.direct</td>
</tr>
<tr>
<td>Fanout exchange（扇型交换机）</td>
<td>amq.fanout</td>
</tr>
<tr>
<td>Topic exchange（主题交换机）</td>
<td>amq.topic</td>
</tr>
<tr>
<td>Headers exchange（头交换机）</td>
<td>amq.match (and amq.headers in RabbitMQ)</td>
</tr>
<tr>
<td>除交换机类型外，在声明交换机时还可以附带许多其他的属性，其中最重要的几个分别是：</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>Name</li>
<li>Durability （消息代理重启后，交换机是否还存在）</li>
<li>Auto-delete （当所有与之绑定的消息队列都完成了对此交换机的使用后，删掉它）</li>
<li>Arguments（依赖代理本身）</li>
</ul>
<p>交换机可以有两个状态：持久（durable）、暂存（transient）。持久化的交换机会在消息代理（broker）重启后依旧存在，而暂存的交换机则不会（它们需要在代理再次上线后重新被声明）。然而并不是所有的应用场景都需要持久化的交换机。</p>
<h1 id="默认交换机"><a href="#默认交换机" class="headerlink" title="默认交换机"></a>默认交换机</h1><p>默认交换机（default exchange）实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的直连交换机（direct exchange）。它有一个特殊的属性使得它对于简单应用特别有用处：那就是每个新建队列（queue）都会自动绑定到默认交换机上，绑定的路由键（routing key）名称与队列名称相同。</p>
<p>举个例子：当你声明了一个名为”search-indexing-online”的队列，AMQP代理会自动将其绑定到默认交换机上，绑定（binding）的路由键名称也是为”search-indexing-online”。因此，当携带着名为”search-indexing-online”的路由键的消息被发送到默认交换机的时候，此消息会被默认交换机路由至名为”search-indexing-online”的队列中。换句话说，默认交换机看起来貌似能够直接将消息投递给队列，尽管技术上并没有做相关的操作。</p>
<h1 id="直连交换机"><a href="#直连交换机" class="headerlink" title="直连交换机"></a>直连交换机</h1><p>直连型交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应队列的。直连交换机用来处理消息的单播路由（unicast routing）（尽管它也可以处理多播路由）。下边介绍它是如何工作的：</p>
<ul>
<li>将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键（routing key）</li>
<li>当一个携带着路由键为R的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为R的队列。</li>
</ul>
<p>直连交换机经常用来循环分发任务给多个工作者（workers）。当这样做的时候，我们需要明白一点，在AMQP 0-9-1中，消息的负载均衡是发生在消费者（consumer）之间的，而不是队列（queue）之间。</p>
<p>直连型交换机图例：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwgy1fy9ji0h18kj30je0emgn6.jpg"></p>
<h1 id="扇型交换机"><a href="#扇型交换机" class="headerlink" title="扇型交换机"></a>扇型交换机</h1><p>扇型交换机（funout exchange）将消息路由给绑定到它身上的所有队列，而不理会绑定的路由键。如果N个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝分别发送给这所有的N个队列。扇型用来交换机处理消息的广播路由（broadcast routing）。</p>
<p>因为扇型交换机投递消息的拷贝到所有绑定到它的队列，所以他的应用案例都极其相似：</p>
<ul>
<li>大规模多用户在线（MMO）游戏可以使用它来处理排行榜更新等全局事件</li>
<li>体育新闻网站可以用它来近乎实时地将比分更新分发给移动客户端</li>
<li>分发系统使用它来广播各种状态和配置更新</li>
<li>在群聊的时候，它被用来分发消息给参与群聊的用户。（AMQP没有内置presence的概念，因此XMPP可能会是个更好的选择）<br>扇型交换机图例：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwgy1fy9jigjyy6j30je0cvwfh.jpg"></p>
<h1 id="主题交换机"><a href="#主题交换机" class="headerlink" title="主题交换机"></a>主题交换机</h1><p>主题交换机（topic exchanges）通过对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。主题交换机经常用来实现各种分发&#x2F;订阅模式及其变种。主题交换机通常用来实现消息的多播路由（multicast routing）。</p>
<p>主题交换机拥有非常广泛的用户案例。无论何时，当一个问题涉及到那些想要有针对性的选择需要接收消息的 多消费者&#x2F;多应用（multiple consumers&#x2F;applications） 的时候，主题交换机都可以被列入考虑范围。</p>
<p>使用案例：</p>
<ul>
<li>分发有关于特定地理位置的数据，例如销售点</li>
<li>由多个工作者（workers）完成的后台任务，每个工作者负责处理某些特定的任务</li>
<li>股票价格更新（以及其他类型的金融数据更新）</li>
<li>涉及到分类或者标签的新闻更新（例如，针对特定的运动项目或者队伍）</li>
<li>云端的不同种类服务的协调</li>
<li>分布式架构&#x2F;基于系统的软件封装，其中每个构建者仅能处理一个特定的架构或者系统。</li>
</ul>
<h1 id="头交换机"><a href="#头交换机" class="headerlink" title="头交换机"></a>头交换机</h1><p>有时消息的路由操作会涉及到多个属性，此时使用消息头就比用路由键更容易表达，头交换机（headers exchange）就是为此而生的。头交换机使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。</p>
<p>我们可以绑定一个队列到头交换机上，并给他们之间的绑定使用多个用于匹配的头（header）。这个案例中，消息代理得从应用开发者那儿取到更多一段信息，换句话说，它需要考虑某条消息（message）是需要部分匹配还是全部匹配。上边说的“更多一段消息”就是”x-match”参数。当”x-match”设置为“any”时，消息头的任意一个值被匹配就可以满足条件，而当”x-match”设置为“all”的时候，就需要消息头的所有值都匹配成功。</p>
<p>头交换机可以视为直连交换机的另一种表现形式。头交换机能够像直连交换机一样工作，不同之处在于头交换机的路由规则是建立在头属性值之上，而不是路由键。路由键必须是一个字符串，而头属性值则没有这个约束，它们甚至可以是整数或者哈希值（字典）等。</p>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>AMQP中的队列（queue）跟其他消息队列或任务队列中的队列是很相似的：它们存储着即将被应用消费掉的消息。队列跟交换机共享某些属性，但是队列也有一些另外的属性。</p>
<ul>
<li>Name</li>
<li>Durable（消息代理重启后，队列依旧存在）</li>
<li>Exclusive（只被一个连接（connection）使用，而且当连接关闭后队列即被删除）</li>
<li>Auto-delete（当最后一个消费者退订后即被删除）</li>
<li>Arguments（一些消息代理用他来完成类似与TTL的某些额外功能）</li>
</ul>
<p>队列在声明（declare）后才能被使用。如果一个队列尚不存在，声明一个队列会创建它。如果声明的队列已经存在，并且属性完全相同，那么此次声明不会对原有队列产生任何影响。如果声明中的属性与已存在队列的属性有差异，那么一个错误代码为406的通道级异常就会被抛出。</p>
<h1 id="队列名称"><a href="#队列名称" class="headerlink" title="队列名称"></a>队列名称</h1><p>队列的名字可以由应用（application）来取，也可以让消息代理（broker）直接生成一个。队列的名字可以是最多255字节的一个utf-8字符串。若希望AMQP消息代理生成队列名，需要给队列的name参数赋值一个空字符串：在同一个通道（channel）的后续的方法（method）中，我们可以使用空字符串来表示之前生成的队列名称。之所以之后的方法可以获取正确的队列名是因为通道可以默默地记住消息代理最后一次生成的队列名称。</p>
<p>以”amq.”开始的队列名称被预留做消息代理内部使用。如果试图在队列声明时打破这一规则的话，一个通道级的403 (ACCESS_REFUSED)错误会被抛出。</p>
<h1 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h1><p>持久化队列（Durable queues）会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。没有被持久化的队列称作暂存队列（Transient queues）。并不是所有的场景和案例都需要将队列持久化。</p>
<p>持久化的队列并不会使得路由到它的消息也具有持久性。倘若消息代理挂掉了，重新启动，那么在重启的过程中持久化队列会被重新声明，无论怎样，只有经过持久化的消息才能被重新恢复。</p>
<h1 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h1><p>绑定（Binding）是交换机（exchange）将消息（message）路由给队列（queue）所需遵循的规则。如果要指示交换机“E”将消息路由给队列“Q”，那么“Q”就需要与“E”进行绑定。绑定操作需要定义一个可选的路由键（routing key）属性给某些类型的交换机。路由键的意义在于从发送给交换机的众多消息中选择出某些消息，将其路由给绑定的队列。</p>
<p>打个比方：</p>
<ul>
<li>队列（queue）是我们想要去的位于纽约的目的地</li>
<li>交换机（exchange）是JFK机场</li>
<li>绑定（binding）就是JFK机场到目的地的路线。能够到达目的地的路线可以是一条或者多条</li>
</ul>
<p>拥有了交换机这个中间层，很多由发布者直接到队列难以实现的路由方案能够得以实现，并且避免了应用开发者的许多重复劳动。</p>
<p>如果AMQP的消息无法路由到队列（例如，发送到的交换机没有绑定队列），消息会被就地销毁或者返还给发布者。如何处理取决于发布者设置的消息属性。</p>
<h1 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h1><p>消息如果只是存储在队列里是没有任何用处的。被应用消费掉，消息的价值才能够体现。在AMQP 0-9-1 模型中，有两种途径可以达到此目的：</p>
<ul>
<li>将消息投递给应用 (“push API”)</li>
<li>应用根据需要主动获取消息 (“pull API”)</li>
</ul>
<p>使用push API，应用（application）需要明确表示出它在某个特定队列里所感兴趣的，想要消费的消息。如是，我们可以说应用注册了一个消费者，或者说订阅了一个队列。一个队列可以注册多个消费者，也可以注册一个独享的消费者（当独享消费者存在时，其他消费者即被排除在外）。</p>
<p>每个消费者（订阅者）都有一个叫做消费者标签的标识符。它可以被用来退订消息。消费者标签实际上是一个字符串。</p>
<h1 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h1><p>消费者应用（Consumer applications） - 用来接受和处理消息的应用 - 在处理消息的时候偶尔会失败或者有时会直接崩溃掉。而且网络原因也有可能引起各种问题。这就给我们出了个难题，AMQP代理在什么时候删除消息才是正确的？AMQP 0-9-1 规范给我们两种建议：</p>
<ul>
<li>当消息代理（broker）将消息发送给应用后立即删除。（使用AMQP方法：basic.deliver或basic.get-ok）</li>
<li>待应用（application）发送一个确认回执（acknowledgement）后再删除消息。（使用AMQP方法：basic.ack）</li>
</ul>
<p>前者被称作自动确认模式（automatic acknowledgement model），后者被称作显式确认模式（explicit acknowledgement model）。在显式模式下，由消费者应用来选择什么时候发送确认回执（acknowledgement）。应用可以在收到消息后立即发送，或将未处理的消息存储后发送，或等到消息被处理完毕后再发送确认回执（例如，成功获取一个网页内容并将其存储之后）。</p>
<p>如果一个消费者在尚未发送确认回执的情况下挂掉了，那AMQP代理会将消息重新投递给另一个消费者。如果当时没有可用的消费者了，消息代理会死等下一个注册到此队列的消费者，然后再次尝试投递。</p>
<h1 id="拒绝消息"><a href="#拒绝消息" class="headerlink" title="拒绝消息"></a>拒绝消息</h1><p>当一个消费者接收到某条消息后，处理过程有可能成功，有可能失败。应用可以向消息代理表明，本条消息由于“拒绝消息（Rejecting Messages）”的原因处理失败了（或者未能在此时完成）。当拒绝某条消息时，应用可以告诉消息代理如何处理这条消息——销毁它或者重新放入队列。当此队列只有一个消费者时，请确认不要由于拒绝消息并且选择了重新放入队列的行为而引起消息在同一个消费者身上无限循环的情况发生。</p>
<h1 id="Negative-Acknowledgements"><a href="#Negative-Acknowledgements" class="headerlink" title="Negative Acknowledgements"></a>Negative Acknowledgements</h1><p>在AMQP中，basic.reject方法用来执行拒绝消息的操作。但basic.reject有个限制：你不能使用它决绝多个带有确认回执（acknowledgements）的消息。但是如果你使用的是RabbitMQ，那么你可以使用被称作negative acknowledgements（也叫nacks）的AMQP 0-9-1扩展来解决这个问题。更多的信息请参考帮助页面</p>
<h1 id="预取消息"><a href="#预取消息" class="headerlink" title="预取消息"></a>预取消息</h1><p>在多个消费者共享一个队列的案例中，明确指定在收到下一个确认回执前每个消费者一次可以接受多少条消息是非常有用的。这可以在试图批量发布消息的时候起到简单的负载均衡和提高消息吞吐量的作用。For example, if a producing application sends messages every minute because of the nature of the work it is doing.（？？？例如，如果生产应用每分钟才发送一条消息，这说明处理工作尚在运行。）</p>
<p>注意，RabbitMQ只支持通道级的预取计数，而不是连接级的或者基于大小的预取。</p>
<h1 id="消息属性和有效载荷（消息主体）"><a href="#消息属性和有效载荷（消息主体）" class="headerlink" title="消息属性和有效载荷（消息主体）"></a>消息属性和有效载荷（消息主体）</h1><p>AMQP模型中的消息（Message）对象是带有属性（Attributes）的。有些属性及其常见，以至于AMQP 0-9-1 明确的定义了它们，并且应用开发者们无需费心思思考这些属性名字所代表的具体含义。例如：</p>
<ul>
<li>Content type（内容类型）</li>
<li>Content encoding（内容编码）</li>
<li>Routing key（路由键）</li>
<li>Delivery mode (persistent or not)</li>
<li>投递模式（持久化 或 非持久化）</li>
<li>Message priority（消息优先权）</li>
<li>Message publishing timestamp（消息发布的时间戳）</li>
<li>Expiration period（消息有效期）</li>
<li>Publisher application id（发布应用的ID）</li>
</ul>
<p>有些属性是被AMQP代理所使用的，但是大多数是开放给接收它们的应用解释器用的。有些属性是可选的也被称作消息头（headers）。他们跟HTTP协议的X-Headers很相似。消息属性需要在消息被发布的时候定义。</p>
<p>AMQP的消息除属性外，也含有一个有效载荷 - Payload（消息实际携带的数据），它被AMQP代理当作不透明的字节数组来对待。消息代理不会检查或者修改有效载荷。消息可以只包含属性而不携带有效载荷。它通常会使用类似JSON这种序列化的格式数据，为了节省，协议缓冲器和MessagePack将结构化数据序列化，以便以消息的有效载荷的形式发布。AMQP及其同行者们通常使用”content-type” 和 “content-encoding” 这两个字段来与消息沟通进行有效载荷的辨识工作，但这仅仅是基于约定而已。</p>
<p>消息能够以持久化的方式发布，AMQP代理会将此消息存储在磁盘上。如果服务器重启，系统会确认收到的持久化消息未丢失。简单地将消息发送给一个持久化的交换机或者路由给一个持久化的队列，并不会使得此消息具有持久化性质：它完全取决与消息本身的持久模式（persistence mode）。将消息以持久化方式发布时，会对性能造成一定的影响（就像数据库操作一样，健壮性的存在必定造成一些性能牺牲）。</p>
<h1 id="消息确认-1"><a href="#消息确认-1" class="headerlink" title="消息确认"></a>消息确认</h1><p>由于网络的不确定性和应用失败的可能性，处理确认回执（acknowledgement）就变的十分重要。有时我们确认消费者收到消息就可以了，有时确认回执意味着消息已被验证并且处理完毕，例如对某些数据已经验证完毕并且进行了数据存储或者索引操作。</p>
<p>这种情形很常见，所以 AMQP 0-9-1 内置了一个功能叫做 消息确认（message acknowledgements），消费者用它来确认消息已经被接收或者处理。如果一个应用崩溃掉（此时连接会断掉，所以AMQP代理亦会得知），而且消息的确认回执功能已经被开启，但是消息代理尚未获得确认回执，那么消息会被从新放入队列（并且在还有还有其他消费者存在于此队列的前提下，立即投递给另外一个消费者）。</p>
<p>协议内置的消息确认功能将帮助开发者建立强大的软件。</p>
<h1 id="AMQP-0-9-1-方法"><a href="#AMQP-0-9-1-方法" class="headerlink" title="AMQP 0-9-1 方法"></a>AMQP 0-9-1 方法</h1><p>AMQP 0-9-1由许多方法（methods）构成。方法即是操作，这跟面向对象编程中的方法没半毛钱关系。AMQP的方法被分组在类（class）中。这里的类仅仅是对AMQP方法的逻辑分组而已。在 AMQP 0-9-1参考 中有对AMQP方法的详细介绍。</p>
<p>让我们来看看交换机类，有一组方法被关联到了交换机的操作上。这些方法如下所示：</p>
<ul>
<li>exchange.declare</li>
<li>exchange.declare-ok</li>
<li>exchange.delete</li>
<li>exchange.delete-ok</li>
</ul>
<p>（请注意，RabbitMQ网站参考中包含了特用于RabbitMQ的交换机类的扩展，这里我们不对其进行讨论）</p>
<p>以上的操作来自逻辑上的配对：exchange.declare 和 exchange.declare-ok，exchange.delete 和 exchange.delete-ok. 这些操作分为“请求 - requests”（由客户端发送）和“响应 - responses”（由代理发送，用来回应之前提到的“请求”操作）。</p>
<p>如下的例子：客户端要求消息代理使用exchange.declare方法声明一个新的交换机：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwly1fy9kpfxja4j30fb04bwet.jpg"></p>
<p>如上图所示，exchange.declare方法携带了好几个参数。这些参数可以允许客户端指定交换机名称、类型、是否持久化等等。</p>
<p>操作成功后，消息代理使用exchange.declare-ok方法进行回应：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwly1fy9kpq82v0j30fb04bjrm.jpg"></p>
<p>exchange.declare-ok方法除了通道号之外没有携带任何其他参数（通道-channel 会在本指南稍后章节进行介绍）。</p>
<p>AMQP队列类的配对方法 - queue.declare方法 和 queue.declare-ok有着与其他配对方法非常相似的一系列事件：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwly1fy9kq4qxwxj30fb04bmxg.jpg"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwly1fy9kqicilsj30fb04b3yv.jpg"></p>
<p>不是所有的AMQP方法都有与其配对的“另一半”。许多（basic.publish是最被广泛使用的）都没有相对应的“响应”方法，另外一些（如basic.get）有着一种以上与之对应的“响应”方法。</p>
<h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><p>AMQP连接通常是长连接。AMQP是一个使用TCP提供可靠投递的应用层协议。AMQP使用认证机制并且提供TLS（SSL）保护。当一个应用不再需要连接到AMQP代理的时候，需要优雅的释放掉AMQP连接，而不是直接将TCP连接关闭。</p>
<h1 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h1><p>有些应用需要与AMQP代理建立多个连接。无论怎样，同时开启多个TCP连接都是不合适的，因为这样做会消耗掉过多的系统资源并且使得防火墙的配置更加困难。AMQP 0-9-1提供了通道（channels）来处理多连接，可以把通道理解成共享一个TCP连接的多个轻量化连接。</p>
<p>在涉及多线程&#x2F;进程的应用中，为每个线程&#x2F;进程开启一个通道（channel）是很常见的，并且这些通道不能被线程&#x2F;进程共享。</p>
<p>一个特定通道上的通讯与其他通道上的通讯是完全隔离的，因此每个AMQP方法都需要携带一个通道号，这样客户端就可以指定此方法是为哪个通道准备的。</p>
<h1 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h1><p>为了在一个单独的代理上实现多个隔离的环境（用户、用户组、交换机、队列 等），AMQP提供了一个虚拟主机（virtual hosts - vhosts）的概念。这跟Web servers虚拟主机概念非常相似，这为AMQP实体提供了完全隔离的环境。当连接被建立的时候，AMQP客户端来指定使用哪个虚拟主机。</p>
<h1 id="AMQP是可扩展的"><a href="#AMQP是可扩展的" class="headerlink" title="AMQP是可扩展的"></a>AMQP是可扩展的</h1><p>AMQP 0-9-1 拥有多个扩展点：</p>
<ul>
<li>定制化交换机类型 可以让开发者们实现一些开箱即用的交换机类型尚未很好覆盖的路由方案。例如 geodata-based routing。</li>
<li>交换机和队列的声明中可以包含一些消息代理能够用到的额外属性。例如RabbitMQ中的per-queue message TTL即是使用该方式实现。</li>
<li>特定消息代理的协议扩展。例如RabbitMQ所实现的扩展。</li>
<li>新的 AMQP 0-9-1 方法类可被引入。</li>
<li>消息代理可以被其他的插件扩展，例如RabbitMQ的管理前端 和 已经被插件化的HTTP API。</li>
</ul>
<p>这些特性使得AMQP 0-9-1模型更加灵活，并且能够适用于解决更加宽泛的问题。</p>
<h1 id="AMQP-0-9-1-客户端生态系统"><a href="#AMQP-0-9-1-客户端生态系统" class="headerlink" title="AMQP 0-9-1 客户端生态系统"></a>AMQP 0-9-1 客户端生态系统</h1><p>AMQP 0-9-1 拥有众多的适用于各种流行语言和框架的客户端。其中一部分严格遵循AMQP规范，提供AMQP方法的实现。另一部分提供了额外的技术，方便使用的方法和抽象。有些客户端是异步的（非阻塞的），有些是同步的（阻塞的），有些将这两者同时实现。有些客户端支持“供应商的特定扩展”（例如RabbitMQ的特定扩展）。</p>
<p>因为AMQP的主要目标之一就是实现交互性，所以对于开发者来讲，了解协议的操作方法而不是只停留在弄懂特定客户端的库就显得十分重要。这样一来，开发者使用不同类型的库与协议进行沟通时就会容易的多。</p>
]]></content>
      <categories>
        <category>专业知识</category>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ（3）：hello-world</title>
    <url>/2018/12/14/cs-basic/cs-basic-middleware/cs-basic-middleware-rabbitmq/RabbitMQ%EF%BC%883%EF%BC%89%EF%BC%9Ahello-world/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>RabbitMQ是一个消息代理器: 它接受和转发消息。你可以把它当作一个邮局: 当你把你的邮件放到邮箱里的时候, 你可以肯定邮差最终会把你的邮件交给你邮件上的收件人。在这个比喻中, RabbitMQ扮演的就是这个邮箱、邮局和邮差的角色。</p>
<p>RabbitMQ和邮局之间的主要区别是，它不处理纸质邮件，而是接受，存储和转发二进制数据——消息。</p>
<p>RabbitMQ和一般的消息传递，有一些专业术语：</p>
<p>生产者（Producing）的工作就是发送消息。生产者是一个发送消息的程序：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwgy1fy6ce13yxdj301z01fdfq.jpg"></p>
<p>RabbitMQ包含一个队列，这个队列起类似邮箱的作用。虽然消息经过RabbitMQ和应用程序，但是他们只可以被存储在队列中。队列只受主机内存和磁盘的限制，它本质上是一个很大的消息缓冲区。生产者可以将消息发送到队列，然后消费者可以从队列接收消息。下图是我们如何表示一个队列：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwgy1fy6ceijxivj303m02j3yf.jpg"></p>
<p>消费者的工作就是接收消息。消费者是一个等待接收消息的程序。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwgy1fy6crd1ujyj301z01fa9y.jpg"></p>
<p>注意：生产者，消费者和消息代理可以不再同一台主机上；一个应用程序可以既是生产者也是消费者。</p>
<h1 id="“Hello-World”"><a href="#“Hello-World”" class="headerlink" title="“Hello World”"></a>“Hello World”</h1><blockquote>
<p><strong>(using the php-amqplib Client)</strong></p>
<p>In this part of the tutorial we’ll write two programs in PHP; a producer that sends a single message, and a consumer that receives messages and prints them out. We’ll gloss over some of the detail in the <a href="https://github.com/php-amqplib/php-amqplib">php-amqplib</a> API, concentrating on this very simple thing just to get started. It’s a “Hello World” of messaging.</p>
</blockquote>
<p>在下图中，“P”是我们的生产者，“C”是我们的消费者。中间的方框是一个缓存消息的队列。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwgy1fy6cu0ymurj30aw01nwej.jpg"></p>
<p><strong>The php-amqplib client library</strong></p>
<p>RabbitMQ应用了很多协议。这个实例中包含了AMQP 0-9-1，这是一个以开源，通用为设计目的的消息协议。RabbitMQ有很多用不同语言实现的客户端。在这个实例中我们将使用php-amqplib，并且用Composer来管理依赖。</p>
<p>在你的项目中添加一个 <em>composer.json</em> 文件：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;require&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;php-amqplib/php-amqplib&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&gt;=2.6.1&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>如何你之前没有安装Composer，你可以使用下面的命令进行安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install composer</span><br></pre></td></tr></table></figure>

<p>安装好Composer之后，执行一下下面的命令来添加依赖。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">composer install</span><br></pre></td></tr></table></figure>

<p>现在，我们的php-ampqlib库已经装好了，我们可以开始写代码了。</p>
<h1 id="Sending"><a href="#Sending" class="headerlink" title="Sending"></a>Sending</h1><p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwgy1fy6elwynd8j306002smx4.jpg"></p>
<p>我们将生产者命名为 <em>send.php</em>，将消费者命名为 <em>receive.php</em>。生产者将连接RabbitMQ，发送一条消息，然后退出。</p>
<p>在 <em>send.php</em> 中, 我们需要导入类库并使用use引入必须的类：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">require_once</span> <span class="keyword">__DIR__</span> . <span class="string">&#x27;/vendor/autoload.php&#x27;</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpAmqpLib</span>\<span class="title">Connection</span>\<span class="title">AMQPStreamConnection</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpAmqpLib</span>\<span class="title">Message</span>\<span class="title">AMQPMessage</span>;</span><br></pre></td></tr></table></figure>

<p>然后我们创建一个连接服务器的Connection：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$connection</span> = <span class="keyword">new</span> <span class="title class_">AMQPStreamConnection</span>(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">5672</span>, <span class="string">&#x27;guest&#x27;</span>, <span class="string">&#x27;guest&#x27;</span>);</span><br><span class="line"><span class="variable">$channel</span> = <span class="variable">$connection</span>-&gt;<span class="title function_ invoke__">channel</span>();</span><br></pre></td></tr></table></figure>

<p>这个连接抽象了socket连接，并且替我们完成协议版本确认和授权的工作。这里我们适用localhost连接到了本地的一个消息代理。如果我们想要连接到其他机器的消息代理上，我们只需要修改一下IP地址。</p>
<p>接下来我们初始化一个信道，在rabbitmq中大部分的API操作都集中于信道这个位置。</p>
<p>发送消息前，我们必须定义一个队列，然后我们将一个消息发送到这个队列上。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">queue_declare</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$msg</span> = <span class="keyword">new</span> <span class="title class_">AMQPMessage</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">basic_publish</span>(<span class="variable">$msg</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot; [x] Sent &#x27;Hello World!&#x27;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这里建议每次发送消息前都定义一下队列，虽然如果之前同一个名字的队列已经创建过就不会创建了，但是为了防止因为没有创建队列而出错，最好养成每次使用前创建队列的习惯。消息的内容是以字节数组的形式发送的，所以这里你可以用任何一种编码方式发送消息。</p>
<p>最后，我们需要关闭信道和服务器连接。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line"><span class="variable">$connection</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/haxianhe/rabbitmq-tutorials/blob/master/hello_world/send.php">Here’s the whole send.php class.</a></p>
<h1 id="Receiving"><a href="#Receiving" class="headerlink" title="Receiving"></a>Receiving</h1><p>消息生产者只发送一条消息，而消息消费者需要不断的处理从RabbitMQ发来的消息，所以，我们需要保持消息消费者始终处于监听状态，并将收到的消息打印出来。</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNbRwgy1fy6f042b04j306002sjrc.jpg"></p>
<p>The code (in <em>receive.php</em>) has almost the same include and uses as send:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">require_once</span> <span class="keyword">__DIR__</span> . <span class="string">&#x27;/vendor/autoload.php&#x27;</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpAmqpLib</span>\<span class="title">Connection</span>\<span class="title">AMQPStreamConnection</span>;</span><br></pre></td></tr></table></figure>

<p>Setting up is the same as the publisher; we open a connection and a channel, and declare the queue from which we’re going to consume. Note this matches up with the queue that send publishes to.</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$connection</span> = <span class="keyword">new</span> <span class="title class_">AMQPStreamConnection</span>(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">5672</span>, <span class="string">&#x27;guest&#x27;</span>, <span class="string">&#x27;guest&#x27;</span>);</span><br><span class="line"><span class="variable">$channel</span> = <span class="variable">$connection</span>-&gt;<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">queue_declare</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>Note that we declare the queue here, as well. Because we might start the consumer before the publisher, we want to make sure the queue exists before we try to consume messages from it.</p>
<p>We’re about to tell the server to deliver us the messages from the queue. We will define a PHP <a href="http://www.php.net/manual/en/language.types.callable.php">callable</a> that will receive the messages sent by the server. Keep in mind that messages are sent asynchronously from the server to the clients.</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$callback</span> = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$msg</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&#x27; [x] Received &#x27;</span>, <span class="variable">$msg</span>-&gt;body, <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">basic_consume</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="variable">$callback</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="title function_ invoke__">count</span>(<span class="variable">$channel</span>-&gt;callbacks)) &#123;</span><br><span class="line">    <span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">wait</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Our code will block while our $channel has callbacks. Whenever we receive a message our $callback function will be passed the received message.</p>
<p><a href="https://github.com/haxianhe/rabbitmq-tutorials/blob/master/hello_world/receive.php">Here’s the whole receive.php class</a></p>
<h1 id="Putting-it-all-together"><a href="#Putting-it-all-together" class="headerlink" title="Putting it all together"></a>Putting it all together</h1><p>Now we can run both scripts. In a terminal, run the consumer (receiver):</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php receive.php</span><br></pre></td></tr></table></figure>

<p>then, run the publisher (sender):</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php send.php</span><br></pre></td></tr></table></figure>

<p>The consumer will print the message it gets from the sender via RabbitMQ. The receiver will keep running, waiting for messages (Use Ctrl-C to stop it), so try running the sender from another terminal.</p>
<p><strong>Listing queues</strong></p>
<p>You may wish to see what queues RabbitMQ has and how many messages are in them. You can do it (as a privileged user) using the rabbitmqctl tool:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rabbitmqctl list_queues</span><br></pre></td></tr></table></figure>

<p>官网原文：<a href="http://www.rabbitmq.com/tutorials/tutorial-one-php.html">http://www.rabbitmq.com/tutorials/tutorial-one-php.html</a></p>
]]></content>
      <categories>
        <category>专业知识</category>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ（4）：配置文件</title>
    <url>/2019/01/18/cs-basic/cs-basic-middleware/cs-basic-middleware-rabbitmq/RabbitMQ%EF%BC%884%EF%BC%89%EF%BC%9A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>想要通过php-amqplib连接rabbitmq-server那显然要知道主机、端口、用户名、密码这些信息。</p>
<p>所以如何查看这些信息？如何配置这写信息？默认的信息又是什么？</p>
<p><a href="http://www.rabbitmq.com/configure.html#config-location">RabbitMQ 官方文档-配置</a></p>
<h1 id="通过配置文件查看rabbitmq配置信息"><a href="#通过配置文件查看rabbitmq配置信息" class="headerlink" title="通过配置文件查看rabbitmq配置信息"></a>通过配置文件查看rabbitmq配置信息</h1><p>我用的是MAC，如果你是其他操作系统，请参考<a href="http://www.rabbitmq.com/configure.html#config-location">官方文档</a></p>
<p><strong>在rabbitmq-defaults文件中有关于rabbitmq的配置文件的位置</strong></p>
<p>如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNc79ly1fzantq5qi5j31ca0bw79t.jpg"></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNc79ly1fzapd8nqk2j318i0rkjz5.jpg"></p>
<p>接下来去对应的位置就可以查看对应的配置（注：要是对应的位置没有配置文件自己新建一个就好，文件的格式参考 <a href="http://www.rabbitmq.com/configure.html#config-file-formats">官网文档</a>）</p>
<h1 id="使用命令查看当前运行着的rabbitmq环境信息"><a href="#使用命令查看当前运行着的rabbitmq环境信息" class="headerlink" title="使用命令查看当前运行着的rabbitmq环境信息"></a>使用命令查看当前运行着的rabbitmq环境信息</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmqctl environment</span><br></pre></td></tr></table></figure>

<blockquote>
<p>It is possible to print effective configuration (user provided values merged into defaults) using the <font color='#FF0000'>rabbitmqctl environment</font> command. It will print applied configuration for every application (RabbitMQ, plugins, libraries) running on the node. </p>
</blockquote>
<p><font color='#FF0000'>注：使用该命令的目录为命令所在目录，或者将rabbitmqctl加入PATH环境变量中，或者为rabbitmqctl配置别名（alias）。</font></p>
]]></content>
      <categories>
        <category>专业知识</category>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ（5）：work_queues</title>
    <url>/2019/01/21/cs-basic/cs-basic-middleware/cs-basic-middleware-rabbitmq/RabbitMQ%EF%BC%885%EF%BC%89%EF%BC%9Awork-queues/</url>
    <content><![CDATA[<p><strong>（using <a href="https://github.com/php-amqplib/php-amqplib">php-amqplib</a>）</strong></p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNc79ly1fze80ctevqj3098033q30.jpg"></p>
<p>在上一个实例中（hello_word）我们写了两个程序，一个用于发送消息，一个用于接受消息。</p>
<p>在这个实例中，我们将完成一个在给多个消费者分配耗时任务的工作队列。</p>
<p>工作队列（又称：任务队列）背后的<strong>核心思想</strong>是尽量避免立即执行资源密集型任务、必须等待当前任务执行完成才能执行其他任务。取而代之的是，稍后调度这个任务。</p>
<p>我们将任务封装为消息，并且将它发送到队列中。一个在后台运行的工作进程将从队列中pop消息，并执行它。</p>
<p>如果有多个消息消费者，所有任务将根据调度策略被分配给多个消息消费者。</p>
<p>这个概念在web应用程序中特别有用，因为HTTP请求的窗口期很短无法用来处理复杂的任务。</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>在上一个实例（hello_world）中，我们发送了一个消息（Hello，World！）。现在我们将会发送一个字符串代表一个复杂任务。我们没有真实世界的任务，比如要调整大小的图片或者要渲染的pdf文件。所以我们通过使用sleep()函数来模拟这个任务。在这个任务中我们使用.来代表它的复杂程度，每一个.代表一秒的工作时间。</p>
<p>我们稍微修改一下前面的send.php的代码。允许从命令行发送任意的消息。它将会将任务发到我们的工作队列，将它命名为new_task.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$data</span> = <span class="title function_ invoke__">implode</span>(<span class="string">&#x27; &#x27;</span>, <span class="title function_ invoke__">array_slice</span>(<span class="variable">$argv</span>, <span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$data</span>)) &#123;</span><br><span class="line">    <span class="variable">$data</span> = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$msg</span> = <span class="keyword">new</span> <span class="title class_">AMQPMessage</span>(<span class="variable">$data</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">basic_publish</span>(<span class="variable">$msg</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27; [x] Sent &#x27;</span>, <span class="variable">$data</span>, <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>我们以前的<em>receive.php</em>脚本也需要一些改变；在消息体中每一个.将代表1秒的工作时间。这个程序将会从队列中弹出任务并执行这个任务。我们将其命名为<em>worker.php</em>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$callback = function ($msg) &#123;</span><br><span class="line">  echo &#x27; [x] Received &#x27;, $msg-&gt;body, &quot;\n&quot;;</span><br><span class="line">  sleep(substr_count($msg-&gt;body, &#x27;.&#x27;));</span><br><span class="line">  echo &quot; [x] Done\n&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$channel-&gt;basic_consume(&#x27;hello&#x27;, &#x27;&#x27;, false, true, false, false, $callback);</span><br></pre></td></tr></table></figure>

<p>注意：我们模拟的任务模拟的是任务的执行的时间。</p>
<p>在实例中执行：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># shell 1</span></span><br><span class="line">php worker.php</span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># shell 2</span></span><br><span class="line">php new_task.php <span class="string">&quot;A very hard task which takes two seconds..&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="循环调度"><a href="#循环调度" class="headerlink" title="循环调度"></a>循环调度</h1><p>使用任务队列的一个优点就是能够轻松的并行工作。如果我们的任务执行压力增加，可以通过添加消费者的形式，轻松扩展。</p>
<p>首先，我们同时运行两个worker.php脚本。它们都将从消息队列中获取消息，但究竟是怎样的？让我们来看一下。</p>
<p>你需要打开三个命令行窗口，其中两个用来运行worker.php脚本。这两个命令行是我们的消费者C1和C2。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># shell 1</span></span><br><span class="line">php worker.php</span><br><span class="line"><span class="comment"># =&gt; [*] Waiting for messages. To exit press CTRL+C</span></span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># shell 2</span></span><br><span class="line">php worker.php</span><br><span class="line"><span class="comment"># =&gt; [*] Waiting for messages. To exit press CTRL+C</span></span><br></pre></td></tr></table></figure>

<p>在第三个命令行中我们将会发布新的消息。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># shell 3</span></span><br><span class="line">php new_task.php First message.</span><br><span class="line">php new_task.php Second message..</span><br><span class="line">php new_task.php Third message...</span><br><span class="line">php new_task.php Fourth message....</span><br><span class="line">php new_task.php Fifth message.....</span><br></pre></td></tr></table></figure>

<p>让我们看看任务的调度情况:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># shell 1</span></span><br><span class="line">php worker.php</span><br><span class="line"><span class="comment"># =&gt; [*] Waiting for messages. To exit press CTRL+C</span></span><br><span class="line"><span class="comment"># =&gt; [x] Received &#x27;First message.&#x27;</span></span><br><span class="line"><span class="comment"># =&gt; [x] Received &#x27;Third message...&#x27;</span></span><br><span class="line"><span class="comment"># =&gt; [x] Received &#x27;Fifth message.....&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># shell 2</span></span><br><span class="line">php worker.php</span><br><span class="line"><span class="comment"># =&gt; [*] Waiting for messages. To exit press CTRL+C</span></span><br><span class="line"><span class="comment"># =&gt; [x] Received &#x27;Second message..&#x27;</span></span><br><span class="line"><span class="comment"># =&gt; [x] Received &#x27;Fourth message....&#x27;</span></span><br></pre></td></tr></table></figure>

<p>By default, RabbitMQ will send each message to the next consumer, in sequence. On average every consumer will get the same number of messages. This way of distributing messages is called round-robin. Try this out with three or more workers.</p>
<h1 id="Message-acknowledgment"><a href="#Message-acknowledgment" class="headerlink" title="Message acknowledgment"></a>Message acknowledgment</h1><p>Doing a task can take a few seconds. You may wonder what happens if one of the consumers starts a long task and dies with it only partly done. With our current code, once RabbitMQ delivers a message to the customer it immediately marks it for deletion. In this case, if you kill a worker we will lose the message it was just processing. We’ll also lose all the messages that were dispatched to this particular worker but were not yet handled.</p>
<p>But we don’t want to lose any tasks. If a worker dies, we’d like the task to be delivered to another worker.</p>
<p>In order to make sure a message is never lost, RabbitMQ supports message acknowledgments. An ack(nowledgement) is sent back by the consumer to tell RabbitMQ that a particular message has been received, processed and that RabbitMQ is free to delete it.</p>
<p>If a consumer dies (its channel is closed, connection is closed, or TCP connection is lost) without sending an ack, RabbitMQ will understand that a message wasn’t processed fully and will re-queue it. If there are other consumers online at the same time, it will then quickly redeliver it to another consumer. That way you can be sure that no message is lost, even if the workers occasionally die.</p>
<p>There aren’t any message timeouts; RabbitMQ will redeliver the message when the consumer dies. It’s fine even if processing a message takes a very, very long time.</p>
<p>Message acknowledgments are turned off by default. It’s time to turn them on by setting the fourth parameter to basic_consume to false (true means no ack) and send a proper acknowledgment from the worker, once we’re done with a task.</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$callback</span> = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$msg</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&#x27; [x] Received &#x27;</span>, <span class="variable">$msg</span>-&gt;body, <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="title function_ invoke__">sleep</span>(<span class="title function_ invoke__">substr_count</span>(<span class="variable">$msg</span>-&gt;body, <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot; [x] Done\n&quot;</span>;</span><br><span class="line">  <span class="variable">$msg</span>-&gt;delivery_info[<span class="string">&#x27;channel&#x27;</span>]-&gt;<span class="title function_ invoke__">basic_ack</span>(<span class="variable">$msg</span>-&gt;delivery_info[<span class="string">&#x27;delivery_tag&#x27;</span>]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">basic_consume</span>(<span class="string">&#x27;task_queue&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="variable">$callback</span>);</span><br></pre></td></tr></table></figure>

<p>Using this code we can be sure that even if you kill a worker using CTRL+C while it was processing a message, nothing will be lost. Soon after the worker dies all unacknowledged messages will be redelivered.</p>
<p>Acknowledgement must be sent on the same channel the delivery it is for was received on. Attempts to acknowledge using a different channel will result in a channel-level protocol exception. See the doc guide on confirmations to learn more.</p>
<h1 id="Message-durability"><a href="#Message-durability" class="headerlink" title="Message durability"></a>Message durability</h1><p>We have learned how to make sure that even if the consumer dies, the task isn’t lost. But our tasks will still be lost if RabbitMQ server stops.</p>
<p>When RabbitMQ quits or crashes it will forget the queues and messages unless you tell it not to. Two things are required to make sure that messages aren’t lost: we need to mark both the queue and messages as durable.</p>
<p>First, we need to make sure that RabbitMQ will never lose our queue. In order to do so, we need to declare it as durable. To do so we pass the third parameter to queue_declare as true:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">queue_declare</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>Although this command is correct by itself, it won’t work in our present setup. That’s because we’ve already defined a queue called hello which is not durable. RabbitMQ doesn’t allow you to redefine an existing queue with different parameters and will return an error to any program that tries to do that. But there is a quick workaround - let’s declare a queue with different name, for example task_queue:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">queue_declare</span>(<span class="string">&#x27;task_queue&#x27;</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>This flag set to true needs to be applied to both the producer and consumer code.</p>
<p>At this point we’re sure that the task_queue queue won’t be lost even if RabbitMQ restarts. Now we need to mark our messages as persistent - by setting the delivery_mode &#x3D; 2 message property which AMQPMessage takes as part of the property array.</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$msg</span> = <span class="keyword">new</span> <span class="title class_">AMQPMessage</span>(</span><br><span class="line">    <span class="variable">$data</span>,</span><br><span class="line">    <span class="keyword">array</span>(<span class="string">&#x27;delivery_mode&#x27;</span> =&gt; <span class="title class_">AMQPMessage</span>::<span class="variable constant_">DELIVERY_MODE_PERSISTENT</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="Fair-dispatch"><a href="#Fair-dispatch" class="headerlink" title="Fair dispatch"></a>Fair dispatch</h1><p>You might have noticed that the dispatching still doesn’t work exactly as we want. For example in a situation with two workers, when all odd messages are heavy and even messages are light, one worker will be constantly busy and the other one will do hardly any work. Well, RabbitMQ doesn’t know anything about that and will still dispatch messages evenly.</p>
<p>This happens because RabbitMQ just dispatches a message when the message enters the queue. It doesn’t look at the number of unacknowledged messages for a consumer. It just blindly dispatches every n-th message to the n-th consumer.</p>
<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/006tNc79gy1fzei65a8zqj30b0033jrk.jpg"></p>
<p>In order to defeat that we can use the basic_qos method with the prefetch_count &#x3D; 1 setting. This tells RabbitMQ not to give more than one message to a worker at a time. Or, in other words, don’t dispatch a new message to a worker until it has processed and acknowledged the previous one. Instead, it will dispatch it to the next worker that is not still busy.</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">basic_qos</span>(<span class="literal">null</span>, <span class="number">1</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Putting-it-all-together"><a href="#Putting-it-all-together" class="headerlink" title="Putting it all together"></a>Putting it all together</h1><p>Final code of our new_task.php file:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">require_once __DIR__ . &#x27;/vendor/autoload.php&#x27;;</span><br><span class="line">use PhpAmqpLib\Connection\AMQPStreamConnection;</span><br><span class="line">use PhpAmqpLib\Message\AMQPMessage;</span><br><span class="line"></span><br><span class="line">$connection = new AMQPStreamConnection(&#x27;localhost&#x27;, 5672, &#x27;guest&#x27;, &#x27;guest&#x27;);</span><br><span class="line">$channel = $connection-&gt;channel();</span><br><span class="line"></span><br><span class="line">$channel-&gt;queue_declare(&#x27;task_queue&#x27;, false, true, false, false);</span><br><span class="line"></span><br><span class="line">$data = implode(&#x27; &#x27;, array_slice($argv, 1));</span><br><span class="line">if (empty($data)) &#123;</span><br><span class="line">    $data = &quot;Hello World!&quot;;</span><br><span class="line">&#125;</span><br><span class="line">$msg = new AMQPMessage(</span><br><span class="line">    $data,</span><br><span class="line">    array(&#x27;delivery_mode&#x27; =&gt; AMQPMessage::DELIVERY_MODE_PERSISTENT)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$channel-&gt;basic_publish($msg, &#x27;&#x27;, &#x27;task_queue&#x27;);</span><br><span class="line"></span><br><span class="line">echo &#x27; [x] Sent &#x27;, $data, &quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">$channel-&gt;close();</span><br><span class="line">$connection-&gt;close();</span><br></pre></td></tr></table></figure>
<p>(new_task.php source)</p>
<p>And our worker.php:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require_once</span> <span class="keyword">__DIR__</span> . <span class="string">&#x27;/vendor/autoload.php&#x27;</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpAmqpLib</span>\<span class="title">Connection</span>\<span class="title">AMQPStreamConnection</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$connection</span> = <span class="keyword">new</span> <span class="title class_">AMQPStreamConnection</span>(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">5672</span>, <span class="string">&#x27;guest&#x27;</span>, <span class="string">&#x27;guest&#x27;</span>);</span><br><span class="line"><span class="variable">$channel</span> = <span class="variable">$connection</span>-&gt;<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">queue_declare</span>(<span class="string">&#x27;task_queue&#x27;</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$callback</span> = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$msg</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27; [x] Received &#x27;</span>, <span class="variable">$msg</span>-&gt;body, <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="title function_ invoke__">sleep</span>(<span class="title function_ invoke__">substr_count</span>(<span class="variable">$msg</span>-&gt;body, <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot; [x] Done\n&quot;</span>;</span><br><span class="line">    <span class="variable">$msg</span>-&gt;delivery_info[<span class="string">&#x27;channel&#x27;</span>]-&gt;<span class="title function_ invoke__">basic_ack</span>(<span class="variable">$msg</span>-&gt;delivery_info[<span class="string">&#x27;delivery_tag&#x27;</span>]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">basic_qos</span>(<span class="literal">null</span>, <span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">basic_consume</span>(<span class="string">&#x27;task_queue&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="variable">$callback</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="title function_ invoke__">count</span>(<span class="variable">$channel</span>-&gt;callbacks)) &#123;</span><br><span class="line">    <span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">wait</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line"><span class="variable">$connection</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br></pre></td></tr></table></figure>

<p>(worker.php source)</p>
<p>Using message acknowledgments and prefetch you can set up a work queue. The durability options let the tasks survive even if RabbitMQ is restarted.</p>
<p>Now we can move on to tutorial 3 and learn how to deliver the same message to many consumers.</p>
]]></content>
      <categories>
        <category>专业知识</category>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis之数据类型</title>
    <url>/2020/05/06/cs-basic/cs-basic-middleware/cs-basic-middleware-redis/Redis-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>Redis 的数据类型有5种，分别是：字符串、列表、哈希表、集合、有序集合。</p>
<p>Redis 的编码（底层实现）有8种，分别是：long 类型的整数、embstr 编码的简单动态字符串、简单动态字符串、字典、双端链表、压缩列表、整数集合、跳跃表和字典。</p>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201021080508.png"></p>
<p><strong>字符串对象的编码可以是 int、raw 或者 embstr。</strong></p>
<p>如果一个字符串对象保存的是整数值，并且这个整数值可以用 long 类型来表示，那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面（将 void* 转换成 long），并将字符串对象的编码设置为 int。</p>
<p>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于39字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。</p>
<p>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于39字节，那么字符串对象将使用 embstr 编码的方式来保存这个字符串值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; set hello world</span><br><span class="line">OK</span><br><span class="line">&gt; get hello</span><br><span class="line">&quot;world&quot;</span><br><span class="line">&gt; del hello</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; get hello</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122193803.png"></p>
<p><strong>列表对象的编码可以是 ziplist 或者 linkedlist。</strong></p>
<p>ziplist 编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点保存了一个列表元素。</p>
<p>linkedlist 编码的列表对象使用双端链表作为底层实现，每个双端链表节点都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; rpush list-key item2</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item2&quot;</span><br><span class="line">3) &quot;item&quot;</span><br><span class="line"></span><br><span class="line">&gt; lindex list-key 1</span><br><span class="line">&quot;item2&quot;</span><br><span class="line"></span><br><span class="line">&gt; lpop list-key</span><br><span class="line">&quot;item&quot;</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) &quot;item2&quot;</span><br><span class="line">2) &quot;item&quot;</span><br></pre></td></tr></table></figure>

<h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122193823.png"></p>
<p><strong>集合对象的编码可以是 intset 或者 hashtable。</strong></p>
<p>intset 编码的集合对象使用整数集合作为底层实现。</p>
<p>hashtable 编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为 NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item3</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item2&quot;</span><br><span class="line">3) &quot;item3&quot;</span><br><span class="line"></span><br><span class="line">&gt; sismember set-key item4</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; sismember set-key item</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item3&quot;</span><br></pre></td></tr></table></figure>

<h5 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h5><p><img src="https://gitee.com/haxianhe/image/raw/master/img/20201020122624.png"></p>
<p><strong>哈希对象的编码可以是 ziplist 或者 hashtable。</strong></p>
<p>ziplist 编码的哈希对象使用压缩列表作为底层实现，每当有新的健值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾。</p>
<p>hashtable 编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都适用一个字典键值对来保存。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset hash-key sub-key2 value2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line">1) &quot;sub-key1&quot;</span><br><span class="line">2) &quot;value1&quot;</span><br><span class="line">3) &quot;sub-key2&quot;</span><br><span class="line">4) &quot;value2&quot;</span><br><span class="line"></span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; hget hash-key sub-key1</span><br><span class="line">&quot;value1&quot;</span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line">1) &quot;sub-key1&quot;</span><br><span class="line">2) &quot;value1&quot;</span><br></pre></td></tr></table></figure>

<h5 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h5><p><img src="https://gitee.com/haxianhe/image/raw/master/img/20201020122737.png"></p>
<p><strong>有序集合对象的编码可以是 ziplist 或者 skiplist。</strong></p>
<p>ziplist 编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个节点保存元素的分值。</p>
<p>skiplist 编码的有序集合对象使用 zset 结构作为底层实现，一个 zset 结构同事包含一个字典和一个跳跃表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; zadd zset-key 728 member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;728&quot;</span><br><span class="line">3) &quot;member0&quot;</span><br><span class="line">4) &quot;982&quot;</span><br><span class="line"></span><br><span class="line">&gt; zrangebyscore zset-key 0 800 withscores</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;728&quot;</span><br><span class="line"></span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) &quot;member0&quot;</span><br><span class="line">2) &quot;982&quot;</span><br></pre></td></tr></table></figure>

<h5 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h5><p><strong>简单动态字符串</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录 buf 数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于 SDS 所保存字符串的长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录 buf 数组中未使用字节的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>图 2-1 展示了一个 SDS 示例：</p>
<ul>
<li>free 属性的值为 0 ， 表示这个 SDS 没有分配任何未使用空间。</li>
<li>len 属性的值为 5 ， 表示这个 SDS 保存了一个五字节长的字符串。</li>
<li>buf 属性是一个 char 类型的数组， 数组的前五个字节分别保存了 ‘R’ 、 ‘e’ 、 ‘d’ 、 ‘i’ 、 ‘s’ 五个字符， 而最后一个字节则保存了空字符 ‘\0’ 。</li>
</ul>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122193847.png"></p>
<p><strong>链表</strong></p>
<p>每个链表节点使用一个 adlist.h&#x2F;listNode 结构来表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line"></span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<p>多个 listNode 可以通过 prev 和 next 指针组成双端链表， 如图 3-1 所示。</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/img/20201020122802.png"></p>
<p>Redis 的链表实现的特性可以总结如下：</p>
<ul>
<li>双端： 链表节点带有 prev 和 next 指针， 获取某个节点的前置节点和后置节点的复杂度都是 O(1) 。</li>
<li>无环： 表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL ， 对链表的访问以 NULL 为终点。</li>
<li>带表头指针和表尾指针： 通过 list 结构的 head 指针和 tail 指针， 程序获取链表的表头节点和表尾节点的复杂度为 O(1) 。</li>
<li>带链表长度计数器： 程序使用 list 结构的 len 属性来对 list 持有的链表节点进行计数， 程序获取链表中节点数量的复杂度为 O(1) 。</li>
<li>多态： 链表节点使用 void* 指针来保存节点值， 并且可以通过 list 结构的 dup 、 free 、 match 三个属性为节点值设置类型特定函数， 所以链表可以用于保存各种不同类型的值。</li>
</ul>
<p><strong>字典</strong></p>
<p>dictht 是一个散列表结构，使用拉链法解决哈希冲突。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p>Redis 的字典 dict 中包含两个哈希表 dictht，这是为了方便进行 rehash 操作。在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p>rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。</p>
<p>渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1] 上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。</p>
<p>在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。</p>
<p>采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Performs N steps of incremental rehashing. Returns 1 if there are still</span></span><br><span class="line"><span class="comment"> * keys to move from the old to the new hash table, otherwise 0 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that a rehashing step consists in moving a bucket (that may have more</span></span><br><span class="line"><span class="comment"> * than one key as we use chaining) from the old to the new hash table, however</span></span><br><span class="line"><span class="comment"> * since part of the hash table may be composed of empty spaces, it is not</span></span><br><span class="line"><span class="comment"> * guaranteed that this function will rehash even a single bucket, since it</span></span><br><span class="line"><span class="comment"> * will visit at max N*10 empty buckets in total, otherwise the amount of</span></span><br><span class="line"><span class="comment"> * work it does would be unbound and the function may block for a long time. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictRehash</span><span class="params">(dict *d, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> empty_visits = n * <span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can&#x27;t overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="type">unsigned</span> <span class="type">long</span>) d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span> (d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            <span class="type">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>跳跃表</strong></p>
<p>是有序集合的底层实现之一。</p>
<p>跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122193914.png"></p>
<p>在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。下图演示了查找 22 的过程。</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122193931.png"></p>
<p>与红黑树等平衡树相比，跳跃表具有以下优点：</p>
<ul>
<li>插入速度非常快速，因为不需要进行旋转等操作来维护平衡性；</li>
<li>更容易实现；</li>
<li>支持无锁操作。</li>
</ul>
<p><strong>整数集合</strong></p>
<p>整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 int16_t 、 int32_t 或者 int64_t 的整数值， 并且保证集合中不会出现重复元素。</p>
<p>每个 intset.h&#x2F;intset 结构表示一个整数集合：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line"></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p>图 6-1 展示了一个整数集合示例：</p>
<ul>
<li>encoding 属性的值为 INTSET_ENC_INT16 ， 表示整数集合的底层实现为 int16_t 类型的数组， 而集合保存的都是 int16_t 类型的整数值。</li>
<li>length 属性的值为 5 ， 表示整数集合包含五个元素。</li>
<li>contents 数组按从小到大的顺序保存着集合中的五个元素。<br>因为每个集合元素都是 int16_t 类型的整数值， 所以 contents 数组的大小等于 sizeof(int16_t) * 5 &#x3D; 16 * 5 &#x3D; 80 位。</li>
</ul>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122193951.png"></p>
<p><strong>压缩列表</strong></p>
<p>压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。</p>
<p>一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值。</p>
<p>图 7-1 展示了压缩列表的各个组成部分， 表 7-1 则记录了各个组成部分的类型、长度、以及用途。</p>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122194012.png"></p>
<p>图 7-2 展示了一个压缩列表示例：</p>
<ul>
<li>列表 zlbytes 属性的值为 0x50 （十进制 80）， 表示压缩列表的总长为 80 字节。</li>
<li>列表 zltail 属性的值为 0x3c （十进制 60）， 这表示如果我们有一个指向压缩列表起始地址的指针 p ， 那么只要用指针 p 加上偏移量 60 ， 就可以计算出表尾节点 entry3 的地址。</li>
<li>列表 zllen 属性的值为 0x3 （十进制 3）， 表示压缩列表包含三个节点。</li>
</ul>
<p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122194029.png"></p>
]]></content>
      <categories>
        <category>专业知识</category>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>MAC上GO环境配置</title>
    <url>/2019/08/16/cs-newcomer/cs-newcomer-environment/MAC%E4%B8%8AGO%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>1、安装命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install go</span><br></pre></td></tr></table></figure>

<p>2、检查go安装信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">env</span></span><br></pre></td></tr></table></figure>

<p>3、配置go路径环境<br>主要是GOROOT、GOPATH和GOBIN</p>
<ul>
<li>GOROOT：就是go的安装环境</li>
<li>GOPATH：其实通俗点来说就是go项目工作目录（作为编译后二进制的存放目的地和import包时的搜索路径）。通常情况下包含三个目录：bin、pkg、src。</li>
<li>GOBIN：go可执行文件目录。</li>
</ul>
<p>在~&#x2F;.bash_profile文件中进行环境配置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20190814100858.png"></p>
<p>编辑完之后退出保存文件，然后使用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure>

<p>使之生效，然后再使用<em>go env</em>查看当前环境，可以发现已经是你配置文件中设置的路径环境了</p>
]]></content>
      <categories>
        <category>新人入门</category>
        <category>环境问题</category>
      </categories>
      <tags>
        <tag>环境问题</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo使用theme出现报错</title>
    <url>/2024/01/18/cs-newcomer/cs-newcomer-environment/hexo%E4%BD%BF%E7%94%A8theme%E5%87%BA%E7%8E%B0%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>新人入门</category>
        <category>环境问题</category>
      </categories>
      <tags>
        <tag>环境问题</tag>
      </tags>
  </entry>
</search>
